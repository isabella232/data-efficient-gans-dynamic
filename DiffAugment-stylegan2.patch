diff --git a/.gitignore b/.gitignore
index 7de7ad1..b803796 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,4 @@
 /.stylegan2-cache/
-__pycache__/
+/results/
+/datasets/
+*.gif
diff --git a/DiffAugment_tf.py b/DiffAugment_tf.py
new file mode 100644
index 0000000..0f6ed26
--- /dev/null
+++ b/DiffAugment_tf.py
@@ -0,0 +1,73 @@
+# Differentiable Augmentation for Data-Efficient GAN Training
+# Shengyu Zhao, Zhijian Liu, Ji Lin, Jun-Yan Zhu, and Song Han
+# https://arxiv.org/pdf/2006.10738
+
+import tensorflow as tf
+
+
+def DiffAugment(x, policy='', channels_first=False):
+    if policy:
+        if channels_first:
+            x = tf.transpose(x, [0, 2, 3, 1])
+        for p in policy.split(','):
+            for f in AUGMENT_FNS[p]:
+                x = f(x)
+        if channels_first:
+            x = tf.transpose(x, [0, 3, 1, 2])
+    return x
+
+
+def rand_brightness(x):
+    magnitude = tf.random.uniform([tf.shape(x)[0], 1, 1, 1]) - 0.5
+    x = x + magnitude
+    return x
+
+
+def rand_saturation(x):
+    magnitude = tf.random.uniform([tf.shape(x)[0], 1, 1, 1]) * 2
+    x_mean = tf.reduce_mean(x, axis=3, keepdims=True)
+    x = (x - x_mean) * magnitude + x_mean
+    return x
+
+
+def rand_contrast(x):
+    magnitude = tf.random.uniform([tf.shape(x)[0], 1, 1, 1]) + 0.5
+    x_mean = tf.reduce_mean(x, axis=[1, 2, 3], keepdims=True)
+    x = (x - x_mean) * magnitude + x_mean
+    return x
+
+
+def rand_translation(x, ratio=0.125):
+    batch_size = tf.shape(x)[0]
+    image_size = tf.shape(x)[1:3]
+    shift = tf.cast(tf.cast(image_size, tf.float32) * ratio + 0.5, tf.int32)
+    translation_x = tf.random.uniform([batch_size, 1], -shift[0], shift[0] + 1, dtype=tf.int32)
+    translation_y = tf.random.uniform([batch_size, 1], -shift[1], shift[1] + 1, dtype=tf.int32)
+    grid_x = tf.clip_by_value(tf.expand_dims(tf.range(image_size[0], dtype=tf.int32), 0) + translation_x + 1, 0, image_size[0] + 1)
+    grid_y = tf.clip_by_value(tf.expand_dims(tf.range(image_size[1], dtype=tf.int32), 0) + translation_y + 1, 0, image_size[1] + 1)
+    x = tf.gather_nd(tf.pad(x, [[0, 0], [1, 1], [0, 0], [0, 0]]), tf.expand_dims(grid_x, -1), batch_dims=1)
+    x = tf.transpose(tf.gather_nd(tf.pad(tf.transpose(x, [0, 2, 1, 3]), [[0, 0], [1, 1], [0, 0], [0, 0]]), tf.expand_dims(grid_y, -1), batch_dims=1), [0, 2, 1, 3])
+    return x
+
+
+def rand_cutout(x, ratio=0.5):
+    batch_size = tf.shape(x)[0]
+    image_size = tf.shape(x)[1:3]
+    cutout_size = tf.cast(tf.cast(image_size, tf.float32) * ratio + 0.5, tf.int32)
+    offset_x = tf.random.uniform([tf.shape(x)[0], 1, 1], maxval=image_size[0] + (1 - cutout_size[0] % 2), dtype=tf.int32)
+    offset_y = tf.random.uniform([tf.shape(x)[0], 1, 1], maxval=image_size[1] + (1 - cutout_size[1] % 2), dtype=tf.int32)
+    grid_batch, grid_x, grid_y = tf.meshgrid(tf.range(batch_size, dtype=tf.int32), tf.range(cutout_size[0], dtype=tf.int32), tf.range(cutout_size[1], dtype=tf.int32), indexing='ij')
+    cutout_grid = tf.stack([grid_batch, grid_x + offset_x - cutout_size[0] // 2, grid_y + offset_y - cutout_size[1] // 2], axis=-1)
+    mask_shape = tf.stack([batch_size, image_size[0], image_size[1]])
+    cutout_grid = tf.maximum(cutout_grid, 0)
+    cutout_grid = tf.minimum(cutout_grid, tf.reshape(mask_shape - 1, [1, 1, 1, 3]))
+    mask = tf.maximum(1 - tf.scatter_nd(cutout_grid, tf.ones([batch_size, cutout_size[0], cutout_size[1]], dtype=tf.float32), mask_shape), 0)
+    x = x * tf.expand_dims(mask, axis=3)
+    return x
+
+
+AUGMENT_FNS = {
+    'color': [rand_brightness, rand_saturation, rand_contrast],
+    'translation': [rand_translation],
+    'cutout': [rand_cutout],
+}
diff --git a/Dockerfile b/Dockerfile
deleted file mode 100755
index 11430ac..0000000
--- a/Dockerfile
+++ /dev/null
@@ -1,11 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-FROM tensorflow/tensorflow:1.14.0-gpu-py3
-
-RUN pip install scipy==1.3.3
-RUN pip install requests==2.22.0
-RUN pip install Pillow==6.2.1
diff --git a/LICENSE.txt b/LICENSE.txt
index d7e8507..d70f031 100755
--- a/LICENSE.txt
+++ b/LICENSE.txt
@@ -1,3 +1,29 @@
+Copyright (c) 2020, Shengyu Zhao, Zhijian Liu, Ji Lin, Jun-Yan Zhu, and Song Han
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+--------------------------- LICENSE FOR stylegan2 --------------------------------
 Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
 
 
diff --git a/README.md b/README.md
index 90d4bfe..420bc29 100755
--- a/README.md
+++ b/README.md
@@ -1,221 +1,153 @@
-## StyleGAN2 &mdash; Official TensorFlow Implementation
-
-![Teaser image](./docs/stylegan2-teaser-1024x256.png)
-
-**Analyzing and Improving the Image Quality of StyleGAN**<br>
-Tero Karras, Samuli Laine, Miika Aittala, Janne Hellsten, Jaakko Lehtinen, Timo Aila<br>
-
-Paper: http://arxiv.org/abs/1912.04958<br>
-Video: https://youtu.be/c-NJtV9Jvp0<br>
-
-Abstract: *The style-based GAN architecture (StyleGAN) yields state-of-the-art results in data-driven unconditional generative image modeling. We expose and analyze several of its characteristic artifacts, and propose changes in both model architecture and training methods to address them. In particular, we redesign generator normalization, revisit progressive growing, and regularize the generator to encourage good conditioning in the mapping from latent vectors to images. In addition to improving image quality, this path length regularizer yields the additional benefit that the generator becomes significantly easier to invert. This makes it possible to reliably detect if an image is generated by a particular network. We furthermore visualize how well the generator utilizes its output resolution, and identify a capacity problem, motivating us to train larger models for additional quality improvements. Overall, our improved model redefines the state of the art in unconditional image modeling, both in terms of existing distribution quality metrics as well as perceived image quality.*
-
-For business inquiries, please contact [researchinquiries@nvidia.com](mailto:researchinquiries@nvidia.com)<br>
-For press and other inquiries, please contact Hector Marinez at [hmarinez@nvidia.com](mailto:hmarinez@nvidia.com)<br>
-
-**&#9733;&#9733;&#9733; NEW: [StyleGAN2-ADA-PyTorch](https://github.com/NVlabs/stylegan2-ada-pytorch) is now available; see the full list of versions [here](https://nvlabs.github.io/stylegan2/versions.html) &#9733;&#9733;&#9733;**
-
-| Additional material | &nbsp;
-| :--- | :----------
-| [StyleGAN2](https://drive.google.com/open?id=1QHc-yF5C3DChRwSdZKcx1w6K8JvSxQi7) | Main Google Drive folder
-| &boxvr;&nbsp; [stylegan2-paper.pdf](https://drive.google.com/open?id=1fnF-QsiQeKaxF-HbvFiGtzHF_Bf3CzJu) | High-quality version of the paper
-| &boxvr;&nbsp; [stylegan2-video.mp4](https://drive.google.com/open?id=1f_gbKW6FUUHKkUxciJ_lQx29mCq_fSBy) | High-quality version of the video
-| &boxvr;&nbsp; [images](https://drive.google.com/open?id=1Sak157_DLX84ytqHHqZaH_59HoEWzfB7) | Example images produced using our method
-| &boxv;&nbsp; &boxvr;&nbsp;  [curated-images](https://drive.google.com/open?id=1ydWb8xCHzDKMTW9kQ7sL-B1R0zATHVHp) | Hand-picked images showcasing our results
-| &boxv;&nbsp; &boxur;&nbsp;  [100k-generated-images](https://drive.google.com/open?id=1BA2OZ1GshdfFZGYZPob5QWOGBuJCdu5q) | Random images with and without truncation
-| &boxvr;&nbsp; [videos](https://drive.google.com/open?id=1yXDV96SFXoUiZKU7AyE6DyKgDpIk4wUZ) | Individual clips of the video as high-quality MP4
-| &boxur;&nbsp; [networks](https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/) | Pre-trained networks
-| &ensp;&ensp; &boxvr;&nbsp;  stylegan2-ffhq-config-f.pkl | StyleGAN2 for <span style="font-variant:small-caps">FFHQ</span> dataset at 1024&times;1024
-| &ensp;&ensp; &boxvr;&nbsp;  stylegan2-car-config-f.pkl | StyleGAN2 for <span style="font-variant:small-caps">LSUN Car</span> dataset at 512&times;384
-| &ensp;&ensp; &boxvr;&nbsp;  stylegan2-cat-config-f.pkl | StyleGAN2 for <span style="font-variant:small-caps">LSUN Cat</span> dataset at 256&times;256
-| &ensp;&ensp; &boxvr;&nbsp;  stylegan2-church-config-f.pkl | StyleGAN2 for <span style="font-variant:small-caps">LSUN Church</span> dataset at 256&times;256
-| &ensp;&ensp; &boxvr;&nbsp;  stylegan2-horse-config-f.pkl | StyleGAN2 for <span style="font-variant:small-caps">LSUN Horse</span> dataset at 256&times;256
-| &ensp;&ensp; &boxur;&nbsp;&#x22ef;  | Other training configurations used in the paper
-
-## Requirements
-
-* Both Linux and Windows are supported. Linux is recommended for performance and compatibility reasons.
-* 64-bit Python 3.6 installation. We recommend Anaconda3 with numpy 1.14.3 or newer.
-* We recommend TensorFlow 1.14, which we used for all experiments in the paper, but TensorFlow 1.15 is also supported on Linux. TensorFlow 2.x is not supported.
-* On Windows you need to use TensorFlow 1.14, as the standard 1.15 installation does not include necessary C++ headers.
-* One or more high-end NVIDIA GPUs, NVIDIA drivers, CUDA 10.0 toolkit and cuDNN 7.5. To reproduce the results reported in the paper, you need an NVIDIA GPU with at least 16 GB of DRAM.
-* Docker users: use the [provided Dockerfile](./Dockerfile) to build an image with the required library dependencies.
-
-StyleGAN2 relies on custom TensorFlow ops that are compiled on the fly using [NVCC](https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html). To test that your NVCC installation is working correctly, run:
-
-```.bash
-nvcc test_nvcc.cu -o test_nvcc -run
-| CPU says hello.
-| GPU says hello.
-```
-
-On Windows, the compilation requires Microsoft Visual Studio to be in `PATH`. We recommend installing [Visual Studio Community Edition](https://visualstudio.microsoft.com/vs/) and adding into `PATH` using `"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"`.
+# DiffAugment for StyleGAN2
 
-## Using pre-trained networks
+This repo is implemented upon and has the same dependencies as the official [StyleGAN2 repo](https://github.com/NVlabs/stylegan2). Specifically,
 
-Pre-trained networks are stored as `*.pkl` files on the [StyleGAN2 Google Drive folder](https://drive.google.com/open?id=1QHc-yF5C3DChRwSdZKcx1w6K8JvSxQi7). Below, you can either reference them directly using the syntax `gdrive:networks/<filename>.pkl`, or download them manually and reference by filename.
+- TensorFlow 1.15 with GPU support.
+- `tensorflow-datasets` version <= 2.1.0 should be installed to run on CIFAR, e.g., `pip install tensorflow-datasets==2.1.0`.
+- We recommend using 4 or 8 GPUs with at least 12 GB of DRAM for training.
+- If you are facing problems with `nvcc` (when building custom ops of StyleGAN2), this can be circumvented by specifying `--impl=ref` in training at the cost of a slightly longer training time.
 
-```.bash
-# Generate uncurated ffhq images (matches paper Figure 12)
-python run_generator.py generate-images --network=gdrive:networks/stylegan2-ffhq-config-f.pkl \
-  --seeds=6600-6625 --truncation-psi=0.5
+## Generating an Interpolation Video
 
-# Generate curated ffhq images (matches paper Figure 11)
-python run_generator.py generate-images --network=gdrive:networks/stylegan2-ffhq-config-f.pkl \
-  --seeds=66,230,389,1518 --truncation-psi=1.0
+<img src="../imgs/interp.gif"/>
 
-# Generate uncurated car images
-python run_generator.py generate-images --network=gdrive:networks/stylegan2-car-config-f.pkl \
-  --seeds=6000-6025 --truncation-psi=0.5
+Run the following command to generate an interpolation video:
 
-# Example of style mixing (matches the corresponding video clip)
-python run_generator.py style-mixing-example --network=gdrive:networks/stylegan2-ffhq-config-f.pkl \
-  --row-seeds=85,100,75,458,1500 --col-seeds=55,821,1789,293 --truncation-psi=1.0
+```bash
+python generate_gif.py --resume=WHICH_MODEL --output=OUTPUT_FILENAME
 ```
 
-The results are placed in `results/<RUNNING_ID>/*.png`. You can change the location with `--result-dir`. For example, `--result-dir=~/my-stylegan2-results`.
-
-You can import the networks in your own Python code using `pickle.load()`. For this to work, you need to include the `dnnlib` source directory in `PYTHONPATH` and create a default TensorFlow session by calling `dnnlib.tflib.init_tf()`. See [run_generator.py](./run_generator.py) and [pretrained_networks.py](./pretrained_networks.py) for examples.
-
-## Preparing datasets
+`WHICH_MODEL` specifies the path of a checkpoint or any pre-trained models in the tables below, e.g., `mit-han-lab:DiffAugment-stylegan2-100-shot-obama.pkl`.
 
-Datasets are stored as multi-resolution TFRecords, similar to the [original StyleGAN](https://github.com/NVlabs/stylegan). Each dataset consists of multiple `*.tfrecords` files stored under a common directory, e.g., `~/datasets/ffhq/ffhq-r*.tfrecords`. In the following sections, the datasets are referenced using a combination of `--dataset` and `--data-dir` arguments, e.g., `--dataset=ffhq --data-dir=~/datasets`.
+## CIFAR-10 and CIFAR-100
 
-**FFHQ**. To download the [Flickr-Faces-HQ](https://github.com/NVlabs/ffhq-dataset) dataset as multi-resolution TFRecords, run:
+To run the CIFAR experiments with 100% data:
 
-```.bash
-pushd ~
-git clone https://github.com/NVlabs/ffhq-dataset.git
-cd ffhq-dataset
-python download_ffhq.py --tfrecords
-popd
-python dataset_tool.py display ~/ffhq-dataset/tfrecords/ffhq
+```bash
+python run_cifar.py --dataset=WHICH_DATASET --num-gpus=NUM_GPUS --DiffAugment=color,cutout
 ```
 
-**LSUN**. Download the desired LSUN categories in LMDB format from the [LSUN project page](https://www.yf.io/p/lsun). To convert the data to multi-resolution TFRecords, run:
+`WHICH_DATASET` specifies either `cifar10` or `cifar100` (defaults to `cifar10`). `NUM_GPUS` specifies the number of GPUs to use; we recommend using 4 or 8 GPUs to replicate our results. The training typically takes around 2 days. Set `--DiffAugment=""` to run the baseline model.
 
-```.bash
-python dataset_tool.py create_lsun_wide ~/datasets/car ~/lsun/car_lmdb --width=512 --height=384
-python dataset_tool.py create_lsun ~/datasets/cat ~/lsun/cat_lmdb --resolution=256
-python dataset_tool.py create_lsun ~/datasets/church ~/lsun/church_outdoor_train_lmdb --resolution=256
-python dataset_tool.py create_lsun ~/datasets/horse ~/lsun/horse_lmdb --resolution=256
-```
-
-**Custom**. Create custom datasets by placing all training images under a single directory. The images must be square-shaped and they must all have the same power-of-two dimensions. To convert the images to multi-resolution TFRecords, run:
+To run the CIFAR experiments with partial data:
 
-```.bash
-python dataset_tool.py create_from_images ~/datasets/my-custom-dataset ~/my-custom-images
-python dataset_tool.py display ~/datasets/my-custom-dataset
+```bash
+python run_cifar.py --dataset=WHICH_DATASET --num-samples=NUM_SAMPLES --num-gpus=NUM_GPUS --DiffAugment=color,translation,cutout
 ```
 
-## Projecting images to latent space
+`WHICH_DATASET` specifies either `cifar10` or `cifar100` (defaults to `cifar10`). `NUM_SAMPLES` specifies the number of training samples to use, e.g., `5000` for 10% data or `10000` for 20% data. `NUM_GPUS` specifies the number of GPUs to use; we recommend using 4 or 8 GPUs to replicate our results. Set `--DiffAugment=""` to run the baseline model.
 
-To find the matching latent vectors for a set of images, run:
+### Pre-Trained Models and Evaluation
 
-```.bash
-# Project generated images
-python run_projector.py project-generated-images --network=gdrive:networks/stylegan2-car-config-f.pkl \
-  --seeds=0,1,5
+To evaluate a model on CIFAR-10 or CIFAR-100, run the following command:
 
-# Project real images
-python run_projector.py project-real-images --network=gdrive:networks/stylegan2-car-config-f.pkl \
-  --dataset=car --data-dir=~/datasets
+```bash
+python run_cifar.py --dataset=WHICH_DATASET --resume=WHICH_MODEL --eval
 ```
 
-## Training networks
-
-To reproduce the training runs for config F in Tables 1 and 3, run:
-
-```.bash
-python run_training.py --num-gpus=8 --data-dir=~/datasets --config=config-f \
-  --dataset=ffhq --mirror-augment=true
-python run_training.py --num-gpus=8 --data-dir=~/datasets --config=config-f \
-  --dataset=car --total-kimg=57000
-python run_training.py --num-gpus=8 --data-dir=~/datasets --config=config-f \
-  --dataset=cat --total-kimg=88000
-python run_training.py --num-gpus=8 --data-dir=~/datasets --config=config-f \
-  --dataset=church --total-kimg 88000 --gamma=100
-python run_training.py --num-gpus=8 --data-dir=~/datasets --config=config-f \
-  --dataset=horse --total-kimg 100000 --gamma=100
-```
+Here, `WHICH_DATASET` specifies either `cifar10` or `cifar100` (defaults to `cifar10`); `WHICH_MODEL` specifies the path of a checkpoint, or a pre-trained model in the following list, which will be automatically downloaded:
 
-For other configurations, see `python run_training.py --help`.
+| Model name | Dataset | is10k | fid10k |
+| --- | --- | --- | --- |
+| `mit-han-lab:stylegan2-cifar10.pkl` | `cifar10` | 9.18 | 11.07 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar10.pkl` | `cifar10` | **9.40** | **9.89** |
+| `mit-han-lab:stylegan2-cifar10-0.2.pkl` | `cifar10` (20% data) | 8.28 | 23.08 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar10-0.2.pkl` | `cifar10` (20% data) | **9.21** | **12.15** |
+| `mit-han-lab:stylegan2-cifar10-0.1.pkl` | `cifar10` (10% data) | 7.33 | 36.02 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar10-0.1.pkl` | `cifar10` (10% data) | **8.84** | **14.50** |
+| `mit-han-lab:stylegan2-cifar100.pkl` | `cifar100` | 9.51 | 16.54 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar100.pkl` | `cifar100` | **10.04** | **15.22** |
+| `mit-han-lab:stylegan2-cifar100-0.2.pkl` | `cifar100` (20% data) | 7.86 | 32.30 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar100-0.2.pkl` | `cifar100` (20% data) | **9.82** | **16.65** |
+| `mit-han-lab:stylegan2-cifar100-0.1.pkl` | `cifar100` (10% data) | 7.01 | 45.87 |
+| `mit-han-lab:DiffAugment-stylegan2-cifar100-0.1.pkl` | `cifar100` (10% data) | **9.06** | **20.75** |
 
-We have verified that the results match the paper when training with 1, 2, 4, or 8 GPUs. Note that training FFHQ at 1024&times;1024 resolution requires GPU(s) with at least 16 GB of memory. The following table lists typical training times using NVIDIA DGX-1 with 8 Tesla V100 GPUs:
+The evaluation results of the pre-trained models should be close to these numbers. Specify `--num-repeats=REPEATS` to compute means and standard deviations over multiple evaluation runs. A standard deviation of less than 1% relatively is expected.
 
-| Configuration | Resolution      | Total kimg | 1 GPU   | 2 GPUs  | 4 GPUs  | 8 GPUs | GPU mem |
-| :------------ | :-------------: | :--------: | :-----: | :-----: | :-----: | :----: | :-----: |
-| `config-f`    | 1024&times;1024 | 25000      | 69d 23h | 36d 4h  | 18d 14h | 9d 18h | 13.3 GB |
-| `config-f`    | 1024&times;1024 | 10000      | 27d 23h | 14d 11h | 7d 10h  | 3d 22h | 13.3 GB |
-| `config-e`    | 1024&times;1024 | 25000      | 35d 11h | 18d 15h | 9d 15h  | 5d 6h  | 8.6 GB  |
-| `config-e`    | 1024&times;1024 | 10000      | 14d 4h  | 7d 11h  | 3d 20h  | 2d 3h  | 8.6 GB  |
-| `config-f`    | 256&times;256   | 25000      | 32d 13h | 16d 23h | 8d 21h  | 4d 18h | 6.4 GB  |
-| `config-f`    | 256&times;256   | 10000      | 13d 0h  | 6d 19h  | 3d 13h  | 1d 22h | 6.4 GB  |
+## FFHQ and LSUN
 
-Training curves for FFHQ config F (StyleGAN2) compared to original StyleGAN using 8 GPUs:
+The NVIDIA's FFHQ dataset can be downloaded [here](https://drive.google.com/drive/folders/1M24jfI-Ylb-k2EGhELSnxssWi9wGUokg). If you want to run at 256x256 resolution for example, only `ffhq-r08.tfrecords` needs to be downloaded. The LSUN datasets (in LMDB format) can be downloaded [here](https://www.yf.io/p/lsun). Pass the folder containing the `.tfrecords` or `.mdb` file to `PATH_TO_THE_TFRECORDS_OR_LMDB_FOLDER` below:
 
-![Training curves](./docs/stylegan2-training-curves.png)
+```bash
+python run_ffhq.py --dataset=PATH_TO_THE_TFRECORDS_OR_LMDB_FOLDER --num-samples=NUM_SAMPLES --num-gpus=NUM_GPUS --resolution=256 --DiffAugment=color,translation,cutout
+```
+
+If there are multiple `.tfrecords` files in the folder, the one with the highest resolution will be used.
+
+### Pre-Trained Models and Evaluation
 
-After training, the resulting networks can be used the same way as the official pre-trained networks:
+Run the following command to evaluate a model on the FFHQ/LSUN dataset:
 
-```.bash
-# Generate 1000 random images without truncation
-python run_generator.py generate-images --seeds=0-999 --truncation-psi=1.0 \
-  --network=results/00006-stylegan2-ffhq-8gpu-config-f/networks-final.pkl
+```bash
+python run_ffhq.py --dataset=PATH_TO_THE_TFRECORDS_OR_LMDB_FOLDER --resume=WHICH_MODEL --num-gpus=NUM_GPUS --eval
 ```
 
-## Evaluation metrics
-
-To reproduce the numbers for config F in Tables 1 and 3, run:
-
-```.bash
-python run_metrics.py --data-dir=~/datasets --network=gdrive:networks/stylegan2-ffhq-config-f.pkl \
-  --metrics=fid50k,ppl_wend --dataset=ffhq --mirror-augment=true
-python run_metrics.py --data-dir=~/datasets --network=gdrive:networks/stylegan2-car-config-f.pkl \
-  --metrics=fid50k,ppl2_wend --dataset=car
-python run_metrics.py --data-dir=~/datasets --network=gdrive:networks/stylegan2-cat-config-f.pkl \
-  --metrics=fid50k,ppl2_wend --dataset=cat
-python run_metrics.py --data-dir=~/datasets --network=gdrive:networks/stylegan2-church-config-f.pkl \
-  --metrics=fid50k,ppl2_wend --dataset=church
-python run_metrics.py --data-dir=~/datasets --network=gdrive:networks/stylegan2-horse-config-f.pkl \
-  --metrics=fid50k,ppl2_wend --dataset=horse
+Here, `PATH_TO_THE_TFRECORDS_OR_LMDB_FOLDER` specifies the folder containing the `.tfrecords` or `.mdb` file. `WHICH_MODEL` specifies the path of a checkpoint, or a pre-trained model in the list below, which will be automatically downloaded. The pre-trained models are run at 256x256 resolution using 8 GPUs. We apply the strongest *Color + Translation + Cutout* DiffAugment to all the baselines, which significantly gains the performance when training with partial data:
+
+| Model name                                                  | Dataset               | fid50k-train |
+| ----------------------------------------------------------- | --------------------- | ----------- |
+| `mit-han-lab:stylegan2-ffhq.pkl`                | FFHQ (full, 70k samples) | **3.81** |
+| `mit-han-lab:DiffAugment-stylegan2-ffhq.pkl`    | FFHQ (full, 70k samples) | 4.24 |
+| `mit-han-lab:stylegan2-ffhq-30k.pkl`            | FFHQ (30k samples)  | 6.16 |
+| `mit-han-lab:DiffAugment-stylegan2-ffhq-30k.pkl` | FFHQ (30k samples)  | **5.05** |
+| `mit-han-lab:stylegan2-ffhq-10k.pkl`            | FFHQ (10k samples)  | 14.75 |
+| `mit-han-lab:DiffAugment-stylegan2-ffhq-10k.pkl` | FFHQ (10k samples)  | **7.86** |
+| `mit-han-lab:stylegan2-ffhq-5k.pkl`             | FFHQ (5k samples)   | 26.60 |
+| `mit-han-lab:DiffAugment-stylegan2-ffhq-5k.pkl` | FFHQ (5k samples)   | **10.45** |
+| `mit-han-lab:stylegan2-ffhq-1k.pkl`             | FFHQ (1k samples)   | 62.16 |
+| `mit-han-lab:DiffAugment-stylegan2-ffhq-1k.pkl` | FFHQ (1k samples)   | **25.66** |
+| `mit-han-lab:stylegan2-lsun-cat-30k.pkl`            | LSUN-Cat (30k samples)  | 10.12 |
+| `mit-han-lab:DiffAugment-stylegan2-lsun-cat-30k.pkl` | LSUN-Cat (30k samples)  | **9.68** |
+| `mit-han-lab:stylegan2-lsun-cat-10k.pkl`            | LSUN-Cat (10k samples)  | 17.93 |
+| `mit-han-lab:DiffAugment-stylegan2-lsun-cat-10k.pkl` | LSUN-Cat (10k samples)  | **12.07** |
+| `mit-han-lab:stylegan2-lsun-cat-5k.pkl`             | LSUN-Cat (5k samples)   | 34.69 |
+| `mit-han-lab:DiffAugment-stylegan2-lsun-cat-5k.pkl` | LSUN-Cat (5k samples)   | **16.11** |
+| `mit-han-lab:stylegan2-lsun-cat-1k.pkl`             | LSUN-Cat (1k samples)   | 182.85 |
+| `mit-han-lab:DiffAugment-stylegan2-lsun-cat-1k.pkl` | LSUN-Cat (1k samples)   | **42.26** |
+
+## Low-Shot Generation
+
+<img src="../imgs/low-shot-interp.jpg" width="1000px"/>
+
+To run the low-shot generation experiments on the 100-shot datasets:
+
+```bash
+python run_low_shot.py --dataset=WHICH_DATASET --num-gpus=NUM_GPUS --DiffAugment=color,translation,cutout
 ```
 
-For other configurations, see the [StyleGAN2 Google Drive folder](https://drive.google.com/open?id=1QHc-yF5C3DChRwSdZKcx1w6K8JvSxQi7).
+or the following command to run on the AnimalFace datasets (with a longer training length):
 
-Note that the metrics are evaluated using a different random seed each time, so the results will vary between runs. In the paper, we reported the average result of running each metric 10 times. The following table lists the available metrics along with their expected runtimes and random variation:
+```bash
+python run_low_shot.py --dataset=WHICH_DATASET --num-gpus=NUM_GPUS --DiffAugment=color,translation,cutout --total-kimg=500
+```
 
-| Metric      | FFHQ config F  | 1 GPU  | 2 GPUs  | 4 GPUs | Description |
-| :---------- | :------------: | :----: | :-----: | :----: | :---------- |
-| `fid50k`    | 2.84 &pm; 0.03 | 22 min | 14 min  | 10 min | [Fr&eacute;chet Inception Distance](https://arxiv.org/abs/1706.08500)
-| `is50k`     | 5.13 &pm; 0.02 | 23 min | 14 min  | 8 min  | [Inception Score](https://arxiv.org/abs/1606.03498)
-| `ppl_zfull` | 348.0 &pm; 3.8 | 41 min | 22 min  | 14 min | [Perceptual Path Length](https://arxiv.org/abs/1812.04948) in Z, full paths
-| `ppl_wfull` | 126.9 &pm; 0.2 | 42 min | 22 min  | 13 min | [Perceptual Path Length](https://arxiv.org/abs/1812.04948) in W, full paths
-| `ppl_zend`  | 348.6 &pm; 3.0 | 41 min | 22 min  | 14 min | [Perceptual Path Length](https://arxiv.org/abs/1812.04948) in Z, path endpoints
-| `ppl_wend`  | 129.4 &pm; 0.8 | 40 min | 23 min  | 13 min | [Perceptual Path Length](https://arxiv.org/abs/1812.04948) in W, path endpoints
-| `ppl2_wend` | 145.0 &pm; 0.5 | 41 min | 23 min  | 14 min | [Perceptual Path Length](https://arxiv.org/abs/1812.04948) without center crop
-| `ls`        | 154.2 / 4.27   | 10 hrs | 6 hrs   | 4 hrs  | [Linear Separability](https://arxiv.org/abs/1812.04948)
-| `pr50k3`    | 0.689 / 0.492  | 26 min | 17 min  | 12 min | [Precision and Recall](https://arxiv.org/abs/1904.06991)
+`WHICH_DATASET` specifies `100-shot-obama`, `100-shot-grumpy_cat`, `100-shot-panda`, `100-shot-bridge_of_sighs`, `100-shot-medici_fountain`, `100-shot-temple_of_heaven`, `100-shot-wuzhen`, `AnimalFace-cat`, or `AnimalFace-dog`, which will be automatically downloaded, or the path of a folder containing your own training images. `NUM_GPUS` specifies the number of GPUs to use; we recommend using 4 or 8 GPUs to replicate our results. The training typically takes several hours. Set `--DiffAugment=""` to run the baseline model. Specify `--resolution=RESOLUTION` to run at a different resolution from the default `256`. You may also fine-tune from an FFHQ pre-trained model listed above, e.g., by specifying `--resume=mit-han-lab:DiffAugment-stylegan2-ffhq.pkl --fmap-base=8192`.
 
-Note that some of the metrics cache dataset-specific data on the disk, and they will take somewhat longer when run for the first time.
+### Preparing Your Own Datasets
 
-## License
+Our method can generate good results using a small number of samples, e.g., 100 images. You may create a new dataset at such scale easily, but note that the generated results may be sensitive to the quality of the training samples. You may wish to crop the raw images and discard some bad training samples. After putting all images into a single folder, pass it to `WHICH_DATASET` in `run_low_shot.py`, the images will be resized to the specified resolution if necessary, and then enjoy the outputs! Note that,
 
-Copyright &copy; 2019, NVIDIA Corporation. All rights reserved.
+- The training length (defaults to 300k images) may be increased for larger datasets, but there may be overfitting issues if the training is too long.
+- The cached files will be stored in the same folder with the training images. If the training images in your folder is *changed* after some run, please manually clean the cached files, `*.tfrecords` and `*.pkl`, from your image folder before rerun.
 
-This work is made available under the Nvidia Source Code License-NC. To view a copy of this license, visit https://nvlabs.github.io/stylegan2/license.html
+### Pre-Trained Models and Evaluation
 
-## Citation
+To evaluate a model on a low-shot generation dataset, run the following command:
 
+```bash
+python run_low_shot.py --dataset=WHICH_DATASET --resume=WHICH_MODEL --eval
 ```
-@inproceedings{Karras2019stylegan2,
-  title     = {Analyzing and Improving the Image Quality of {StyleGAN}},
-  author    = {Tero Karras and Samuli Laine and Miika Aittala and Janne Hellsten and Jaakko Lehtinen and Timo Aila},
-  booktitle = {Proc. CVPR},
-  year      = {2020}
-}
-```
-
-## Acknowledgements
 
-We thank Ming-Yu Liu for an early review, Timo Viitanen for his help with code release, and Tero Kuosmanen for compute infrastructure.
+Here, `WHICH_DATASET` specifies the folder containing the training images, or one of our pre-defined datasets, including `100-shot-obama`, `100-shot-grumpy_cat`, `100-shot-panda`, `100-shot-bridge_of_sighs`, `100-shot-medici_fountain`, `100-shot-temple_of_heaven`, `100-shot-wuzhen`, `AnimalFace-cat`, and `AnimalFace-dog`, which will be automatically downloaded. `WHICH_MODEL` specifies the path of a checkpoint, or a pre-trained model in the following list, which will be automatically downloaded:
+| Model name | Dataset | fid5k-train |
+| --- | --- | --- |
+| `mit-han-lab:stylegan2-100-shot-obama.pkl` | `100-shot-obama` | 80.20 |
+| `mit-han-lab:DiffAugment-stylegan2-100-shot-obama.pkl` | `100-shot-obama` | **46.87** |
+| `mit-han-lab:stylegan2-100-shot-grumpy_cat.pkl` | `100-shot-grumpy_cat` | 48.90 |
+| `mit-han-lab:DiffAugment-stylegan2-100-shot-grumpy_cat.pkl` | `100-shot-grumpy_cat` | **27.08** |
+| `mit-han-lab:stylegan2-100-shot-panda.pkl` | `100-shot-panda` | 34.27 |
+| `mit-han-lab:DiffAugment-stylegan2-100-shot-panda.pkl` | `100-shot-panda` | **12.06** |
+| `mit-han-lab:stylegan2-AnimalFace-cat.pkl` | `AnimalFace-cat` | 71.71 |
+| `mit-han-lab:DiffAugment-stylegan2-AnimalFace-cat.pkl` | `AnimalFace-cat` | **42.44** |
+| `mit-han-lab:stylegan2-AnimalFace-dog.pkl` | `AnimalFace-dog` | 130.19 |
+| `mit-han-lab:DiffAugment-stylegan2-AnimalFace-dog.pkl` | `AnimalFace-dog` | **58.85** |
diff --git a/dataset_tool.py b/dataset_tool.py
deleted file mode 100755
index d8c4dc2..0000000
--- a/dataset_tool.py
+++ /dev/null
@@ -1,644 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""Tool for creating multi-resolution TFRecords datasets."""
-
-# pylint: disable=too-many-lines
-import os
-import sys
-import glob
-import argparse
-import threading
-import six.moves.queue as Queue # pylint: disable=import-error
-import traceback
-import numpy as np
-import tensorflow as tf
-import PIL.Image
-import dnnlib.tflib as tflib
-
-from training import dataset
-
-#----------------------------------------------------------------------------
-
-def error(msg):
-    print('Error: ' + msg)
-    exit(1)
-
-#----------------------------------------------------------------------------
-
-class TFRecordExporter:
-    def __init__(self, tfrecord_dir, expected_images, print_progress=True, progress_interval=10):
-        self.tfrecord_dir       = tfrecord_dir
-        self.tfr_prefix         = os.path.join(self.tfrecord_dir, os.path.basename(self.tfrecord_dir))
-        self.expected_images    = expected_images
-        self.cur_images         = 0
-        self.shape              = None
-        self.resolution_log2    = None
-        self.tfr_writers        = []
-        self.print_progress     = print_progress
-        self.progress_interval  = progress_interval
-
-        if self.print_progress:
-            print('Creating dataset "%s"' % tfrecord_dir)
-        if not os.path.isdir(self.tfrecord_dir):
-            os.makedirs(self.tfrecord_dir)
-        assert os.path.isdir(self.tfrecord_dir)
-
-    def close(self):
-        if self.print_progress:
-            print('%-40s\r' % 'Flushing data...', end='', flush=True)
-        for tfr_writer in self.tfr_writers:
-            tfr_writer.close()
-        self.tfr_writers = []
-        if self.print_progress:
-            print('%-40s\r' % '', end='', flush=True)
-            print('Added %d images.' % self.cur_images)
-
-    def choose_shuffled_order(self): # Note: Images and labels must be added in shuffled order.
-        order = np.arange(self.expected_images)
-        np.random.RandomState(123).shuffle(order)
-        return order
-
-    def add_image(self, img):
-        if self.print_progress and self.cur_images % self.progress_interval == 0:
-            print('%d / %d\r' % (self.cur_images, self.expected_images), end='', flush=True)
-        if self.shape is None:
-            self.shape = img.shape
-            self.resolution_log2 = int(np.log2(self.shape[1]))
-            assert self.shape[0] in [1, 3]
-            assert self.shape[1] == self.shape[2]
-            assert self.shape[1] == 2**self.resolution_log2
-            tfr_opt = tf.python_io.TFRecordOptions(tf.python_io.TFRecordCompressionType.NONE)
-            for lod in range(self.resolution_log2 - 1):
-                tfr_file = self.tfr_prefix + '-r%02d.tfrecords' % (self.resolution_log2 - lod)
-                self.tfr_writers.append(tf.python_io.TFRecordWriter(tfr_file, tfr_opt))
-        assert img.shape == self.shape
-        for lod, tfr_writer in enumerate(self.tfr_writers):
-            if lod:
-                img = img.astype(np.float32)
-                img = (img[:, 0::2, 0::2] + img[:, 0::2, 1::2] + img[:, 1::2, 0::2] + img[:, 1::2, 1::2]) * 0.25
-            quant = np.rint(img).clip(0, 255).astype(np.uint8)
-            ex = tf.train.Example(features=tf.train.Features(feature={
-                'shape': tf.train.Feature(int64_list=tf.train.Int64List(value=quant.shape)),
-                'data': tf.train.Feature(bytes_list=tf.train.BytesList(value=[quant.tostring()]))}))
-            tfr_writer.write(ex.SerializeToString())
-        self.cur_images += 1
-
-    def add_labels(self, labels):
-        if self.print_progress:
-            print('%-40s\r' % 'Saving labels...', end='', flush=True)
-        assert labels.shape[0] == self.cur_images
-        with open(self.tfr_prefix + '-rxx.labels', 'wb') as f:
-            np.save(f, labels.astype(np.float32))
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, *args):
-        self.close()
-
-#----------------------------------------------------------------------------
-
-class ExceptionInfo(object):
-    def __init__(self):
-        self.value = sys.exc_info()[1]
-        self.traceback = traceback.format_exc()
-
-#----------------------------------------------------------------------------
-
-class WorkerThread(threading.Thread):
-    def __init__(self, task_queue):
-        threading.Thread.__init__(self)
-        self.task_queue = task_queue
-
-    def run(self):
-        while True:
-            func, args, result_queue = self.task_queue.get()
-            if func is None:
-                break
-            try:
-                result = func(*args)
-            except:
-                result = ExceptionInfo()
-            result_queue.put((result, args))
-
-#----------------------------------------------------------------------------
-
-class ThreadPool(object):
-    def __init__(self, num_threads):
-        assert num_threads >= 1
-        self.task_queue = Queue.Queue()
-        self.result_queues = dict()
-        self.num_threads = num_threads
-        for _idx in range(self.num_threads):
-            thread = WorkerThread(self.task_queue)
-            thread.daemon = True
-            thread.start()
-
-    def add_task(self, func, args=()):
-        assert hasattr(func, '__call__') # must be a function
-        if func not in self.result_queues:
-            self.result_queues[func] = Queue.Queue()
-        self.task_queue.put((func, args, self.result_queues[func]))
-
-    def get_result(self, func): # returns (result, args)
-        result, args = self.result_queues[func].get()
-        if isinstance(result, ExceptionInfo):
-            print('\n\nWorker thread caught an exception:\n' + result.traceback)
-            raise result.value
-        return result, args
-
-    def finish(self):
-        for _idx in range(self.num_threads):
-            self.task_queue.put((None, (), None))
-
-    def __enter__(self): # for 'with' statement
-        return self
-
-    def __exit__(self, *excinfo):
-        self.finish()
-
-    def process_items_concurrently(self, item_iterator, process_func=lambda x: x, pre_func=lambda x: x, post_func=lambda x: x, max_items_in_flight=None):
-        if max_items_in_flight is None: max_items_in_flight = self.num_threads * 4
-        assert max_items_in_flight >= 1
-        results = []
-        retire_idx = [0]
-
-        def task_func(prepared, _idx):
-            return process_func(prepared)
-
-        def retire_result():
-            processed, (_prepared, idx) = self.get_result(task_func)
-            results[idx] = processed
-            while retire_idx[0] < len(results) and results[retire_idx[0]] is not None:
-                yield post_func(results[retire_idx[0]])
-                results[retire_idx[0]] = None
-                retire_idx[0] += 1
-
-        for idx, item in enumerate(item_iterator):
-            prepared = pre_func(item)
-            results.append(None)
-            self.add_task(func=task_func, args=(prepared, idx))
-            while retire_idx[0] < idx - max_items_in_flight + 2:
-                for res in retire_result(): yield res
-        while retire_idx[0] < len(results):
-            for res in retire_result(): yield res
-
-#----------------------------------------------------------------------------
-
-def display(tfrecord_dir):
-    print('Loading dataset "%s"' % tfrecord_dir)
-    tflib.init_tf({'gpu_options.allow_growth': True})
-    dset = dataset.TFRecordDataset(tfrecord_dir, max_label_size='full', repeat=False, shuffle_mb=0)
-    tflib.init_uninitialized_vars()
-    import cv2  # pip install opencv-python
-
-    idx = 0
-    while True:
-        try:
-            images, labels = dset.get_minibatch_np(1)
-        except tf.errors.OutOfRangeError:
-            break
-        if idx == 0:
-            print('Displaying images')
-            cv2.namedWindow('dataset_tool')
-            print('Press SPACE or ENTER to advance, ESC to exit')
-        print('\nidx = %-8d\nlabel = %s' % (idx, labels[0].tolist()))
-        cv2.imshow('dataset_tool', images[0].transpose(1, 2, 0)[:, :, ::-1]) # CHW => HWC, RGB => BGR
-        idx += 1
-        if cv2.waitKey() == 27:
-            break
-    print('\nDisplayed %d images.' % idx)
-
-#----------------------------------------------------------------------------
-
-def extract(tfrecord_dir, output_dir):
-    print('Loading dataset "%s"' % tfrecord_dir)
-    tflib.init_tf({'gpu_options.allow_growth': True})
-    dset = dataset.TFRecordDataset(tfrecord_dir, max_label_size=0, repeat=False, shuffle_mb=0)
-    tflib.init_uninitialized_vars()
-
-    print('Extracting images to "%s"' % output_dir)
-    if not os.path.isdir(output_dir):
-        os.makedirs(output_dir)
-    idx = 0
-    while True:
-        if idx % 10 == 0:
-            print('%d\r' % idx, end='', flush=True)
-        try:
-            images, _labels = dset.get_minibatch_np(1)
-        except tf.errors.OutOfRangeError:
-            break
-        if images.shape[1] == 1:
-            img = PIL.Image.fromarray(images[0][0], 'L')
-        else:
-            img = PIL.Image.fromarray(images[0].transpose(1, 2, 0), 'RGB')
-        img.save(os.path.join(output_dir, 'img%08d.png' % idx))
-        idx += 1
-    print('Extracted %d images.' % idx)
-
-#----------------------------------------------------------------------------
-
-def compare(tfrecord_dir_a, tfrecord_dir_b, ignore_labels):
-    max_label_size = 0 if ignore_labels else 'full'
-    print('Loading dataset "%s"' % tfrecord_dir_a)
-    tflib.init_tf({'gpu_options.allow_growth': True})
-    dset_a = dataset.TFRecordDataset(tfrecord_dir_a, max_label_size=max_label_size, repeat=False, shuffle_mb=0)
-    print('Loading dataset "%s"' % tfrecord_dir_b)
-    dset_b = dataset.TFRecordDataset(tfrecord_dir_b, max_label_size=max_label_size, repeat=False, shuffle_mb=0)
-    tflib.init_uninitialized_vars()
-
-    print('Comparing datasets')
-    idx = 0
-    identical_images = 0
-    identical_labels = 0
-    while True:
-        if idx % 100 == 0:
-            print('%d\r' % idx, end='', flush=True)
-        try:
-            images_a, labels_a = dset_a.get_minibatch_np(1)
-        except tf.errors.OutOfRangeError:
-            images_a, labels_a = None, None
-        try:
-            images_b, labels_b = dset_b.get_minibatch_np(1)
-        except tf.errors.OutOfRangeError:
-            images_b, labels_b = None, None
-        if images_a is None or images_b is None:
-            if images_a is not None or images_b is not None:
-                print('Datasets contain different number of images')
-            break
-        if images_a.shape == images_b.shape and np.all(images_a == images_b):
-            identical_images += 1
-        else:
-            print('Image %d is different' % idx)
-        if labels_a.shape == labels_b.shape and np.all(labels_a == labels_b):
-            identical_labels += 1
-        else:
-            print('Label %d is different' % idx)
-        idx += 1
-    print('Identical images: %d / %d' % (identical_images, idx))
-    if not ignore_labels:
-        print('Identical labels: %d / %d' % (identical_labels, idx))
-
-#----------------------------------------------------------------------------
-
-def create_mnist(tfrecord_dir, mnist_dir):
-    print('Loading MNIST from "%s"' % mnist_dir)
-    import gzip
-    with gzip.open(os.path.join(mnist_dir, 'train-images-idx3-ubyte.gz'), 'rb') as file:
-        images = np.frombuffer(file.read(), np.uint8, offset=16)
-    with gzip.open(os.path.join(mnist_dir, 'train-labels-idx1-ubyte.gz'), 'rb') as file:
-        labels = np.frombuffer(file.read(), np.uint8, offset=8)
-    images = images.reshape(-1, 1, 28, 28)
-    images = np.pad(images, [(0,0), (0,0), (2,2), (2,2)], 'constant', constant_values=0)
-    assert images.shape == (60000, 1, 32, 32) and images.dtype == np.uint8
-    assert labels.shape == (60000,) and labels.dtype == np.uint8
-    assert np.min(images) == 0 and np.max(images) == 255
-    assert np.min(labels) == 0 and np.max(labels) == 9
-    onehot = np.zeros((labels.size, np.max(labels) + 1), dtype=np.float32)
-    onehot[np.arange(labels.size), labels] = 1.0
-
-    with TFRecordExporter(tfrecord_dir, images.shape[0]) as tfr:
-        order = tfr.choose_shuffled_order()
-        for idx in range(order.size):
-            tfr.add_image(images[order[idx]])
-        tfr.add_labels(onehot[order])
-
-#----------------------------------------------------------------------------
-
-def create_mnistrgb(tfrecord_dir, mnist_dir, num_images=1000000, random_seed=123):
-    print('Loading MNIST from "%s"' % mnist_dir)
-    import gzip
-    with gzip.open(os.path.join(mnist_dir, 'train-images-idx3-ubyte.gz'), 'rb') as file:
-        images = np.frombuffer(file.read(), np.uint8, offset=16)
-    images = images.reshape(-1, 28, 28)
-    images = np.pad(images, [(0,0), (2,2), (2,2)], 'constant', constant_values=0)
-    assert images.shape == (60000, 32, 32) and images.dtype == np.uint8
-    assert np.min(images) == 0 and np.max(images) == 255
-
-    with TFRecordExporter(tfrecord_dir, num_images) as tfr:
-        rnd = np.random.RandomState(random_seed)
-        for _idx in range(num_images):
-            tfr.add_image(images[rnd.randint(images.shape[0], size=3)])
-
-#----------------------------------------------------------------------------
-
-def create_cifar10(tfrecord_dir, cifar10_dir):
-    print('Loading CIFAR-10 from "%s"' % cifar10_dir)
-    import pickle
-    images = []
-    labels = []
-    for batch in range(1, 6):
-        with open(os.path.join(cifar10_dir, 'data_batch_%d' % batch), 'rb') as file:
-            data = pickle.load(file, encoding='latin1')
-        images.append(data['data'].reshape(-1, 3, 32, 32))
-        labels.append(data['labels'])
-    images = np.concatenate(images)
-    labels = np.concatenate(labels)
-    assert images.shape == (50000, 3, 32, 32) and images.dtype == np.uint8
-    assert labels.shape == (50000,) and labels.dtype == np.int32
-    assert np.min(images) == 0 and np.max(images) == 255
-    assert np.min(labels) == 0 and np.max(labels) == 9
-    onehot = np.zeros((labels.size, np.max(labels) + 1), dtype=np.float32)
-    onehot[np.arange(labels.size), labels] = 1.0
-
-    with TFRecordExporter(tfrecord_dir, images.shape[0]) as tfr:
-        order = tfr.choose_shuffled_order()
-        for idx in range(order.size):
-            tfr.add_image(images[order[idx]])
-        tfr.add_labels(onehot[order])
-
-#----------------------------------------------------------------------------
-
-def create_cifar100(tfrecord_dir, cifar100_dir):
-    print('Loading CIFAR-100 from "%s"' % cifar100_dir)
-    import pickle
-    with open(os.path.join(cifar100_dir, 'train'), 'rb') as file:
-        data = pickle.load(file, encoding='latin1')
-    images = data['data'].reshape(-1, 3, 32, 32)
-    labels = np.array(data['fine_labels'])
-    assert images.shape == (50000, 3, 32, 32) and images.dtype == np.uint8
-    assert labels.shape == (50000,) and labels.dtype == np.int32
-    assert np.min(images) == 0 and np.max(images) == 255
-    assert np.min(labels) == 0 and np.max(labels) == 99
-    onehot = np.zeros((labels.size, np.max(labels) + 1), dtype=np.float32)
-    onehot[np.arange(labels.size), labels] = 1.0
-
-    with TFRecordExporter(tfrecord_dir, images.shape[0]) as tfr:
-        order = tfr.choose_shuffled_order()
-        for idx in range(order.size):
-            tfr.add_image(images[order[idx]])
-        tfr.add_labels(onehot[order])
-
-#----------------------------------------------------------------------------
-
-def create_svhn(tfrecord_dir, svhn_dir):
-    print('Loading SVHN from "%s"' % svhn_dir)
-    import pickle
-    images = []
-    labels = []
-    for batch in range(1, 4):
-        with open(os.path.join(svhn_dir, 'train_%d.pkl' % batch), 'rb') as file:
-            data = pickle.load(file, encoding='latin1')
-        images.append(data[0])
-        labels.append(data[1])
-    images = np.concatenate(images)
-    labels = np.concatenate(labels)
-    assert images.shape == (73257, 3, 32, 32) and images.dtype == np.uint8
-    assert labels.shape == (73257,) and labels.dtype == np.uint8
-    assert np.min(images) == 0 and np.max(images) == 255
-    assert np.min(labels) == 0 and np.max(labels) == 9
-    onehot = np.zeros((labels.size, np.max(labels) + 1), dtype=np.float32)
-    onehot[np.arange(labels.size), labels] = 1.0
-
-    with TFRecordExporter(tfrecord_dir, images.shape[0]) as tfr:
-        order = tfr.choose_shuffled_order()
-        for idx in range(order.size):
-            tfr.add_image(images[order[idx]])
-        tfr.add_labels(onehot[order])
-
-#----------------------------------------------------------------------------
-
-def create_lsun(tfrecord_dir, lmdb_dir, resolution=256, max_images=None):
-    print('Loading LSUN dataset from "%s"' % lmdb_dir)
-    import lmdb # pip install lmdb # pylint: disable=import-error
-    import cv2 # pip install opencv-python
-    import io
-    with lmdb.open(lmdb_dir, readonly=True).begin(write=False) as txn:
-        total_images = txn.stat()['entries'] # pylint: disable=no-value-for-parameter
-        if max_images is None:
-            max_images = total_images
-        with TFRecordExporter(tfrecord_dir, max_images) as tfr:
-            for _idx, (_key, value) in enumerate(txn.cursor()):
-                try:
-                    try:
-                        img = cv2.imdecode(np.fromstring(value, dtype=np.uint8), 1)
-                        if img is None:
-                            raise IOError('cv2.imdecode failed')
-                        img = img[:, :, ::-1] # BGR => RGB
-                    except IOError:
-                        img = np.asarray(PIL.Image.open(io.BytesIO(value)))
-                    crop = np.min(img.shape[:2])
-                    img = img[(img.shape[0] - crop) // 2 : (img.shape[0] + crop) // 2, (img.shape[1] - crop) // 2 : (img.shape[1] + crop) // 2]
-                    img = PIL.Image.fromarray(img, 'RGB')
-                    img = img.resize((resolution, resolution), PIL.Image.ANTIALIAS)
-                    img = np.asarray(img)
-                    img = img.transpose([2, 0, 1]) # HWC => CHW
-                    tfr.add_image(img)
-                except:
-                    print(sys.exc_info()[1])
-                if tfr.cur_images == max_images:
-                    break
-
-#----------------------------------------------------------------------------
-
-def create_lsun_wide(tfrecord_dir, lmdb_dir, width=512, height=384, max_images=None):
-    assert width == 2 ** int(np.round(np.log2(width)))
-    assert height <= width
-    print('Loading LSUN dataset from "%s"' % lmdb_dir)
-    import lmdb # pip install lmdb # pylint: disable=import-error
-    import cv2 # pip install opencv-python
-    import io
-    with lmdb.open(lmdb_dir, readonly=True).begin(write=False) as txn:
-        total_images = txn.stat()['entries'] # pylint: disable=no-value-for-parameter
-        if max_images is None:
-            max_images = total_images
-        with TFRecordExporter(tfrecord_dir, max_images, print_progress=False) as tfr:
-            for idx, (_key, value) in enumerate(txn.cursor()):
-                try:
-                    try:
-                        img = cv2.imdecode(np.fromstring(value, dtype=np.uint8), 1)
-                        if img is None:
-                            raise IOError('cv2.imdecode failed')
-                        img = img[:, :, ::-1] # BGR => RGB
-                    except IOError:
-                        img = np.asarray(PIL.Image.open(io.BytesIO(value)))
-
-                    ch = int(np.round(width * img.shape[0] / img.shape[1]))
-                    if img.shape[1] < width or ch < height:
-                        continue
-
-                    img = img[(img.shape[0] - ch) // 2 : (img.shape[0] + ch) // 2]
-                    img = PIL.Image.fromarray(img, 'RGB')
-                    img = img.resize((width, height), PIL.Image.ANTIALIAS)
-                    img = np.asarray(img)
-                    img = img.transpose([2, 0, 1]) # HWC => CHW
-
-                    canvas = np.zeros([3, width, width], dtype=np.uint8)
-                    canvas[:, (width - height) // 2 : (width + height) // 2] = img
-                    tfr.add_image(canvas)
-                    print('\r%d / %d => %d ' % (idx + 1, total_images, tfr.cur_images), end='')
-
-                except:
-                    print(sys.exc_info()[1])
-                if tfr.cur_images == max_images:
-                    break
-    print()
-
-#----------------------------------------------------------------------------
-
-def create_celeba(tfrecord_dir, celeba_dir, cx=89, cy=121):
-    print('Loading CelebA from "%s"' % celeba_dir)
-    glob_pattern = os.path.join(celeba_dir, 'img_align_celeba_png', '*.png')
-    image_filenames = sorted(glob.glob(glob_pattern))
-    expected_images = 202599
-    if len(image_filenames) != expected_images:
-        error('Expected to find %d images' % expected_images)
-
-    with TFRecordExporter(tfrecord_dir, len(image_filenames)) as tfr:
-        order = tfr.choose_shuffled_order()
-        for idx in range(order.size):
-            img = np.asarray(PIL.Image.open(image_filenames[order[idx]]))
-            assert img.shape == (218, 178, 3)
-            img = img[cy - 64 : cy + 64, cx - 64 : cx + 64]
-            img = img.transpose(2, 0, 1) # HWC => CHW
-            tfr.add_image(img)
-
-#----------------------------------------------------------------------------
-
-def create_from_images(tfrecord_dir, image_dir, shuffle):
-    print('Loading images from "%s"' % image_dir)
-    image_filenames = sorted(glob.glob(os.path.join(image_dir, '*')))
-    if len(image_filenames) == 0:
-        error('No input images found')
-
-    img = np.asarray(PIL.Image.open(image_filenames[0]))
-    resolution = img.shape[0]
-    channels = img.shape[2] if img.ndim == 3 else 1
-    if img.shape[1] != resolution:
-        error('Input images must have the same width and height')
-    if resolution != 2 ** int(np.floor(np.log2(resolution))):
-        error('Input image resolution must be a power-of-two')
-    if channels not in [1, 3]:
-        error('Input images must be stored as RGB or grayscale')
-
-    with TFRecordExporter(tfrecord_dir, len(image_filenames)) as tfr:
-        order = tfr.choose_shuffled_order() if shuffle else np.arange(len(image_filenames))
-        for idx in range(order.size):
-            img = np.asarray(PIL.Image.open(image_filenames[order[idx]]))
-            if channels == 1:
-                img = img[np.newaxis, :, :] # HW => CHW
-            else:
-                img = img.transpose([2, 0, 1]) # HWC => CHW
-            tfr.add_image(img)
-
-#----------------------------------------------------------------------------
-
-def create_from_hdf5(tfrecord_dir, hdf5_filename, shuffle):
-    print('Loading HDF5 archive from "%s"' % hdf5_filename)
-    import h5py # conda install h5py
-    with h5py.File(hdf5_filename, 'r') as hdf5_file:
-        hdf5_data = max([value for key, value in hdf5_file.items() if key.startswith('data')], key=lambda lod: lod.shape[3])
-        with TFRecordExporter(tfrecord_dir, hdf5_data.shape[0]) as tfr:
-            order = tfr.choose_shuffled_order() if shuffle else np.arange(hdf5_data.shape[0])
-            for idx in range(order.size):
-                tfr.add_image(hdf5_data[order[idx]])
-            npy_filename = os.path.splitext(hdf5_filename)[0] + '-labels.npy'
-            if os.path.isfile(npy_filename):
-                tfr.add_labels(np.load(npy_filename)[order])
-
-#----------------------------------------------------------------------------
-
-def execute_cmdline(argv):
-    prog = argv[0]
-    parser = argparse.ArgumentParser(
-        prog        = prog,
-        description = 'Tool for creating multi-resolution TFRecords datasets for StyleGAN and ProGAN.',
-        epilog      = 'Type "%s <command> -h" for more information.' % prog)
-
-    subparsers = parser.add_subparsers(dest='command')
-    subparsers.required = True
-    def add_command(cmd, desc, example=None):
-        epilog = 'Example: %s %s' % (prog, example) if example is not None else None
-        return subparsers.add_parser(cmd, description=desc, help=desc, epilog=epilog)
-
-    p = add_command(    'display',          'Display images in dataset.',
-                                            'display datasets/mnist')
-    p.add_argument(     'tfrecord_dir',     help='Directory containing dataset')
-
-    p = add_command(    'extract',          'Extract images from dataset.',
-                                            'extract datasets/mnist mnist-images')
-    p.add_argument(     'tfrecord_dir',     help='Directory containing dataset')
-    p.add_argument(     'output_dir',       help='Directory to extract the images into')
-
-    p = add_command(    'compare',          'Compare two datasets.',
-                                            'compare datasets/mydataset datasets/mnist')
-    p.add_argument(     'tfrecord_dir_a',   help='Directory containing first dataset')
-    p.add_argument(     'tfrecord_dir_b',   help='Directory containing second dataset')
-    p.add_argument(     '--ignore_labels',  help='Ignore labels (default: 0)', type=int, default=0)
-
-    p = add_command(    'create_mnist',     'Create dataset for MNIST.',
-                                            'create_mnist datasets/mnist ~/downloads/mnist')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'mnist_dir',        help='Directory containing MNIST')
-
-    p = add_command(    'create_mnistrgb',  'Create dataset for MNIST-RGB.',
-                                            'create_mnistrgb datasets/mnistrgb ~/downloads/mnist')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'mnist_dir',        help='Directory containing MNIST')
-    p.add_argument(     '--num_images',     help='Number of composite images to create (default: 1000000)', type=int, default=1000000)
-    p.add_argument(     '--random_seed',    help='Random seed (default: 123)', type=int, default=123)
-
-    p = add_command(    'create_cifar10',   'Create dataset for CIFAR-10.',
-                                            'create_cifar10 datasets/cifar10 ~/downloads/cifar10')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'cifar10_dir',      help='Directory containing CIFAR-10')
-
-    p = add_command(    'create_cifar100',  'Create dataset for CIFAR-100.',
-                                            'create_cifar100 datasets/cifar100 ~/downloads/cifar100')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'cifar100_dir',     help='Directory containing CIFAR-100')
-
-    p = add_command(    'create_svhn',      'Create dataset for SVHN.',
-                                            'create_svhn datasets/svhn ~/downloads/svhn')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'svhn_dir',         help='Directory containing SVHN')
-
-    p = add_command(    'create_lsun',      'Create dataset for single LSUN category.',
-                                            'create_lsun datasets/lsun-car-100k ~/downloads/lsun/car_lmdb --resolution 256 --max_images 100000')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'lmdb_dir',         help='Directory containing LMDB database')
-    p.add_argument(     '--resolution',     help='Output resolution (default: 256)', type=int, default=256)
-    p.add_argument(     '--max_images',     help='Maximum number of images (default: none)', type=int, default=None)
-
-    p = add_command(    'create_lsun_wide', 'Create LSUN dataset with non-square aspect ratio.',
-                                            'create_lsun_wide datasets/lsun-car-512x384 ~/downloads/lsun/car_lmdb --width 512 --height 384')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'lmdb_dir',         help='Directory containing LMDB database')
-    p.add_argument(     '--width',          help='Output width (default: 512)', type=int, default=512)
-    p.add_argument(     '--height',         help='Output height (default: 384)', type=int, default=384)
-    p.add_argument(     '--max_images',     help='Maximum number of images (default: none)', type=int, default=None)
-
-    p = add_command(    'create_celeba',    'Create dataset for CelebA.',
-                                            'create_celeba datasets/celeba ~/downloads/celeba')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'celeba_dir',       help='Directory containing CelebA')
-    p.add_argument(     '--cx',             help='Center X coordinate (default: 89)', type=int, default=89)
-    p.add_argument(     '--cy',             help='Center Y coordinate (default: 121)', type=int, default=121)
-
-    p = add_command(    'create_from_images', 'Create dataset from a directory full of images.',
-                                            'create_from_images datasets/mydataset myimagedir')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'image_dir',        help='Directory containing the images')
-    p.add_argument(     '--shuffle',        help='Randomize image order (default: 1)', type=int, default=1)
-
-    p = add_command(    'create_from_hdf5', 'Create dataset from legacy HDF5 archive.',
-                                            'create_from_hdf5 datasets/celebahq ~/downloads/celeba-hq-1024x1024.h5')
-    p.add_argument(     'tfrecord_dir',     help='New dataset directory to be created')
-    p.add_argument(     'hdf5_filename',    help='HDF5 archive containing the images')
-    p.add_argument(     '--shuffle',        help='Randomize image order (default: 1)', type=int, default=1)
-
-    args = parser.parse_args(argv[1:] if len(argv) > 1 else ['-h'])
-    func = globals()[args.command]
-    del args.command
-    func(**vars(args))
-
-#----------------------------------------------------------------------------
-
-if __name__ == "__main__":
-    execute_cmdline(sys.argv)
-
-#----------------------------------------------------------------------------
diff --git a/dnnlib/tflib/custom_ops.py b/dnnlib/tflib/custom_ops.py
index e6c3e52..481eb72 100755
--- a/dnnlib/tflib/custom_ops.py
+++ b/dnnlib/tflib/custom_ops.py
@@ -61,7 +61,8 @@ def _run_cmd(cmd):
         raise RuntimeError('NVCC returned an error. See below for full command line and output log:\n\n%s\n\n%s' % (cmd, output))
 
 def _prepare_nvcc_cli(opts):
-    cmd = 'nvcc ' + opts.strip()
+    nvcc_path = 'nvcc'
+    cmd = nvcc_path + ' ' + opts.strip()
     cmd += ' --disable-warnings'
     cmd += ' --include-path "%s"' % tf.sysconfig.get_include()
     cmd += ' --include-path "%s"' % os.path.join(tf.sysconfig.get_include(), 'external', 'protobuf_archive', 'src')
diff --git a/dnnlib/tflib/network.py b/dnnlib/tflib/network.py
index 409babb..a4e131a 100755
--- a/dnnlib/tflib/network.py
+++ b/dnnlib/tflib/network.py
@@ -413,7 +413,7 @@ class Network:
                             in_gpu = in_kwargs.pop("func")(*in_gpu, **in_kwargs)
                             in_gpu = [in_gpu] if tfutil.is_tf_expression(in_gpu) else list(in_gpu)
 
-                        assert len(in_gpu) == self.num_inputs
+                        # assert len(in_gpu) == self.num_inputs
                         out_gpu = net_gpu.get_output_for(*in_gpu, return_as_list=True, **dynamic_kwargs)
 
                         if output_transform is not None:
@@ -421,7 +421,7 @@ class Network:
                             out_gpu = out_kwargs.pop("func")(*out_gpu, **out_kwargs)
                             out_gpu = [out_gpu] if tfutil.is_tf_expression(out_gpu) else list(out_gpu)
 
-                        assert len(out_gpu) == self.num_outputs
+                        # assert len(out_gpu) == self.num_outputs
                         out_split.append(out_gpu)
 
                 with tf.device("/cpu:0"):
diff --git a/dnnlib/tflib/optimizer.py b/dnnlib/tflib/optimizer.py
index 9389b5a..9a1b1b8 100755
--- a/dnnlib/tflib/optimizer.py
+++ b/dnnlib/tflib/optimizer.py
@@ -6,7 +6,6 @@
 
 """Helper wrapper for a Tensorflow optimizer."""
 
-import platform
 import numpy as np
 import tensorflow as tf
 
@@ -19,9 +18,12 @@ from .. import util
 
 from .tfutil import TfExpression, TfExpressionEx
 
-_collective_ops_warning_printed = False
-_collective_ops_group_key       = 831766147
-_collective_ops_instance_key    = 436340067
+try:
+    # TensorFlow 1.13
+    from tensorflow.python.ops import nccl_ops
+except:
+    # Older TensorFlow versions
+    import tensorflow.contrib.nccl as nccl_ops
 
 class Optimizer:
     """A Wrapper for tf.train.Optimizer.
@@ -191,12 +193,12 @@ class Optimizer:
         # Sum gradients across devices.
         if len(self._devices) > 1:
             with tfutil.absolute_name_scope(self.scope + "/Broadcast"), tf.device(None):
-                if platform.system() == "Windows":    # Windows => NCCL ops are not available.
-                    self._broadcast_fallback()
-                elif tf.VERSION.startswith("1.15."):  # TF 1.15 => NCCL ops are broken: https://github.com/tensorflow/tensorflow/issues/41539
-                    self._broadcast_fallback()
-                else:                                 # Otherwise => NCCL ops are safe to use.
-                    self._broadcast_nccl()
+                for all_vars in zip(*[device.grad_clean.keys() for device in self._devices.values()]):
+                    if len(all_vars) > 0 and all(dim > 0 for dim in all_vars[0].shape.as_list()): # NCCL does not support zero-sized tensors.
+                        all_grads = [device.grad_clean[var] for device, var in zip(self._devices.values(), all_vars)]
+                        all_grads = nccl_ops.all_sum(all_grads)
+                        for device, var, grad in zip(self._devices.values(), all_vars, all_grads):
+                            device.grad_clean[var] = grad
 
         # Apply updates separately on each device.
         for device_idx, device in enumerate(self._devices.values()):
@@ -245,7 +247,7 @@ class Optimizer:
 
                 # Last device => report statistics.
                 if device_idx == len(self._devices) - 1:
-                    all_ops.append(autosummary.autosummary(self.id + "/learning_rate", tf.convert_to_tensor(self.learning_rate)))
+                    all_ops.append(autosummary.autosummary(self.id + "/learning_rate", self.learning_rate))
                     all_ops.append(autosummary.autosummary(self.id + "/overflow_frequency", tf.where(all_ok, 0, 1), condition=acc_ok))
                     if self.use_loss_scaling:
                         all_ops.append(autosummary.autosummary(self.id + "/loss_scaling_log2", device.loss_scaling_var))
@@ -284,42 +286,6 @@ class Optimizer:
             return value
         return value * tfutil.exp2(-self.get_loss_scaling_var(value.device)) # pylint: disable=invalid-unary-operand-type
 
-    def _broadcast_nccl(self):
-        """Sum gradients across devices using NCCL ops (fast path)."""
-        from tensorflow.python.ops import nccl_ops # pylint: disable=no-name-in-module
-        for all_vars in zip(*[device.grad_clean.keys() for device in self._devices.values()]):
-            if any(x.shape.num_elements() > 0 for x in all_vars):
-                all_grads = [device.grad_clean[var] for device, var in zip(self._devices.values(), all_vars)]
-                all_grads = nccl_ops.all_sum(all_grads)
-                for device, var, grad in zip(self._devices.values(), all_vars, all_grads):
-                    device.grad_clean[var] = grad
-
-    def _broadcast_fallback(self):
-        """Sum gradients across devices using TensorFlow collective ops (slow fallback path)."""
-        from tensorflow.python.ops import collective_ops # pylint: disable=no-name-in-module
-        global _collective_ops_warning_printed, _collective_ops_group_key, _collective_ops_instance_key
-        if all(x.shape.num_elements() == 0 for device in self._devices.values() for x in device.grad_clean.values()):
-            return
-        if not _collective_ops_warning_printed:
-            print("------------------------------------------------------------------------")
-            print("WARNING: Using slow fallback implementation for inter-GPU communication.")
-            print("Please use TensorFlow 1.14 on Linux for optimal training performance.")
-            print("------------------------------------------------------------------------")
-            _collective_ops_warning_printed = True
-        for device in self._devices.values():
-            with tf.device(device.name):
-                combo = [tf.reshape(x, [x.shape.num_elements()]) for x in device.grad_clean.values()]
-                combo = tf.concat(combo, axis=0)
-                combo = collective_ops.all_reduce(combo, merge_op='Add', final_op='Id',
-                    group_size=len(self._devices), group_key=_collective_ops_group_key,
-                    instance_key=_collective_ops_instance_key)
-                cur_ofs = 0
-                for var, grad_old in device.grad_clean.items():
-                    grad_new = tf.reshape(combo[cur_ofs : cur_ofs + grad_old.shape.num_elements()], grad_old.shape)
-                    cur_ofs += grad_old.shape.num_elements()
-                    device.grad_clean[var] = grad_new
-        _collective_ops_instance_key += 1
-
 
 class SimpleAdam:
     """Simplified version of tf.train.AdamOptimizer that behaves identically when used with dnnlib.tflib.Optimizer."""
diff --git a/dnnlib/util.py b/dnnlib/util.py
index 73c98d7..f973d38 100755
--- a/dnnlib/util.py
+++ b/dnnlib/util.py
@@ -343,7 +343,7 @@ def is_url(obj: Any, allow_file_urls: bool = False) -> bool:
     return True
 
 
-def open_url(url: str, cache_dir: str = None, num_attempts: int = 10, verbose: bool = True) -> Any:
+def open_url(url: str, cache_dir: str = None, num_attempts: int = 10, verbose: bool = True, return_path: bool = False) -> Any:
     """Download the given URL and return a binary-mode file object to access the data."""
     assert is_url(url, allow_file_urls=True)
     assert num_attempts >= 1
@@ -357,7 +357,10 @@ def open_url(url: str, cache_dir: str = None, num_attempts: int = 10, verbose: b
     if cache_dir is not None:
         cache_files = glob.glob(os.path.join(cache_dir, url_md5 + "_*"))
         if len(cache_files) == 1:
-            return open(cache_files[0], "rb")
+            if return_path:
+                return cache_files[0]
+            else:
+                return open(cache_files[0], "rb")
 
     # Download.
     url_name = None
@@ -405,6 +408,8 @@ def open_url(url: str, cache_dir: str = None, num_attempts: int = 10, verbose: b
         with open(temp_file, "wb") as f:
             f.write(url_data)
         os.replace(temp_file, cache_file) # atomic
+        if return_path:
+            return cache_file
 
     # Return data as file object.
     return io.BytesIO(url_data)
diff --git a/generate_gif.py b/generate_gif.py
new file mode 100644
index 0000000..1c79b9b
--- /dev/null
+++ b/generate_gif.py
@@ -0,0 +1,63 @@
+import argparse
+import os
+import numpy as np
+from PIL import Image
+
+import dnnlib
+from dnnlib import tflib
+
+from training import misc
+
+
+def run(resume, output, num_rows, num_cols, resolution, num_phases, transition_frames, static_frames, seed):
+    tflib.init_tf({'rnd.np_random_seed': seed})
+    _, _, Gs = misc.load_pkl(resume)
+    output_seq = []
+    batch_size = num_rows * num_cols
+    latent_size = Gs.input_shape[1]
+    latents = [np.random.randn(batch_size, latent_size) for _ in range(num_phases)]
+    
+    Gs_kwargs = dnnlib.EasyDict()
+    Gs_kwargs.output_transform = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=True)
+    Gs_kwargs.randomize_noise = False
+
+    def to_image_grid(outputs):
+        outputs = np.reshape(outputs, [num_rows, num_cols, *outputs.shape[1:]])
+        outputs = np.concatenate(outputs, axis=1)
+        outputs = np.concatenate(outputs, axis=1)
+        return Image.fromarray(outputs).resize((resolution * num_cols, resolution * num_rows), Image.ANTIALIAS)
+    
+    for i in range(num_phases):
+        dlatents0 = Gs.components.mapping.run(latents[i - 1], None)
+        dlatents1 = Gs.components.mapping.run(latents[i], None)
+        for j in range(transition_frames):
+            dlatents = (dlatents0 * (transition_frames - j) + dlatents1 * j) / transition_frames
+            output_seq.append(to_image_grid(Gs.components.synthesis.run(dlatents, **Gs_kwargs)))
+        output_seq.extend([to_image_grid(Gs.components.synthesis.run(dlatents1, **Gs_kwargs))] * static_frames)
+    if not output.endswith('.gif'):
+        output += '.gif'
+    output_seq[0].save(output, save_all=True, append_images=output_seq[1:], optimize=False, duration=50, loop=0)
+
+
+def main():
+    parser = argparse.ArgumentParser(
+        description='Generate GIF.',
+        formatter_class=argparse.RawDescriptionHelpFormatter
+    )
+    parser.add_argument('-r', '--resume', help='Resume checkpoint path', required=True)
+    parser.add_argument('-o', '--output', help='Output file name', required=True)
+    parser.add_argument('--num-rows', help='Number of rows', default=2, type=int)
+    parser.add_argument('--num-cols', help='Number of columns', default=3, type=int)
+    parser.add_argument('--resolution', help='Resolution of the output images', default=128, type=int)
+    parser.add_argument('--num-phases', help='Number of phases', default=5, type=int)
+    parser.add_argument('--transition-frames', help='Number of transition frames per phase', default=20, type=int)
+    parser.add_argument('--static-frames', help='Number of static frames per phase', default=5, type=int)
+    parser.add_argument('--seed', help='Random seed', default=1000, type=int)
+
+    args = parser.parse_args()
+
+    run(**vars(args))
+
+
+if __name__ == "__main__":
+    main()
diff --git a/metrics/frechet_inception_distance.py b/metrics/frechet_inception_distance.py
index ccd85c1..6df8eae 100755
--- a/metrics/frechet_inception_distance.py
+++ b/metrics/frechet_inception_distance.py
@@ -18,28 +18,33 @@ from training import misc
 #----------------------------------------------------------------------------
 
 class FID(metric_base.MetricBase):
-    def __init__(self, num_images, minibatch_per_gpu, **kwargs):
+    def __init__(self, num_images, minibatch_per_gpu, num_real_images=None, mirror_augment=False, num_repeats=1, **kwargs):
         super().__init__(**kwargs)
         self.num_images = num_images
+        self.num_real_images = num_real_images
+        self.num_repeats = num_repeats
+        self.mirror_augment = mirror_augment
         self.minibatch_per_gpu = minibatch_per_gpu
 
     def _evaluate(self, Gs, Gs_kwargs, num_gpus):
+        if self.num_images is None:
+            self.num_images = self.num_real_images
+        num_channels = Gs.output_shape[1]
         minibatch_size = num_gpus * self.minibatch_per_gpu
-        inception = misc.load_pkl('https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/inception_v3_features.pkl')
-        activations = np.empty([self.num_images, inception.output_shape[1]], dtype=np.float32)
+        inception = misc.load_pkl('http://d36zk2xti64re0.cloudfront.net/stylegan1/networks/metrics/inception_v3_features.pkl')
 
         # Calculate statistics for reals.
-        cache_file = self._get_cache_file_for_reals(num_images=self.num_images)
+        cache_file = self._get_cache_file_for_reals(prefix='fid', num_images=self.num_real_images, mirror_augment=self.mirror_augment)
         os.makedirs(os.path.dirname(cache_file), exist_ok=True)
         if os.path.isfile(cache_file):
             mu_real, sigma_real = misc.load_pkl(cache_file)
         else:
-            for idx, images in enumerate(self._iterate_reals(minibatch_size=minibatch_size)):
-                begin = idx * minibatch_size
-                end = min(begin + minibatch_size, self.num_images)
-                activations[begin:end] = inception.run(images[:end-begin], num_gpus=num_gpus, assume_frozen=True)
-                if end == self.num_images:
-                    break
+            activations = []
+            for idx, images in enumerate(self._iterate_reals(minibatch_size=minibatch_size, mirror_augment=self.mirror_augment, num_samples=self.num_real_images)):
+                if num_channels == 1:
+                    images = np.repeat(images, 3, axis=1)
+                activations.append(inception.run(images, num_gpus=num_gpus if images.shape[0] % num_gpus == 0 else 1, assume_frozen=True))
+            activations = np.concatenate(activations, axis=0)
             mu_real = np.mean(activations, axis=0)
             sigma_real = np.cov(activations, rowvar=False)
             misc.save_pkl((mu_real, sigma_real), cache_file)
@@ -53,21 +58,29 @@ class FID(metric_base.MetricBase):
                 latents = tf.random_normal([self.minibatch_per_gpu] + Gs_clone.input_shape[1:])
                 labels = self._get_random_labels_tf(self.minibatch_per_gpu)
                 images = Gs_clone.get_output_for(latents, labels, **Gs_kwargs)
+                if num_channels == 1:
+                    images = tf.repeat(images, 3, axis=1)
                 images = tflib.convert_images_to_uint8(images)
                 result_expr.append(inception_clone.get_output_for(images))
 
-        # Calculate statistics for fakes.
-        for begin in range(0, self.num_images, minibatch_size):
-            self._report_progress(begin, self.num_images)
-            end = min(begin + minibatch_size, self.num_images)
-            activations[begin:end] = np.concatenate(tflib.run(result_expr), axis=0)[:end-begin]
-        mu_fake = np.mean(activations, axis=0)
-        sigma_fake = np.cov(activations, rowvar=False)
+        activations = np.empty([self.num_images, inception.output_shape[1]], dtype=np.float32)
+        results = []
+        for _ in range(self.num_repeats):
+            # Calculate statistics for fakes.
+            for begin in range(0, self.num_images, minibatch_size):
+                self._report_progress(begin, self.num_images)
+                end = min(begin + minibatch_size, self.num_images)
+                activations[begin:end] = np.concatenate(tflib.run(result_expr), axis=0)[:end-begin]
+            mu_fake = np.mean(activations, axis=0)
+            sigma_fake = np.cov(activations, rowvar=False)
 
-        # Calculate FID.
-        m = np.square(mu_fake - mu_real).sum()
-        s, _ = scipy.linalg.sqrtm(np.dot(sigma_fake, sigma_real), disp=False) # pylint: disable=no-member
-        dist = m + np.trace(sigma_fake + sigma_real - 2*s)
-        self._report_result(np.real(dist))
+            # Calculate FID.
+            m = np.square(mu_fake - mu_real).sum()
+            s, _ = scipy.linalg.sqrtm(np.dot(sigma_fake, sigma_real), disp=False) # pylint: disable=no-member
+            dist = m + np.trace(sigma_fake + sigma_real - 2*s)
+            results.append(np.real(dist))
+        self._report_result(np.mean(results))
+        if self.num_repeats > 1:
+            self._report_result(np.std(results), suffix='-std')
 
 #----------------------------------------------------------------------------
diff --git a/metrics/inception_score.py b/metrics/inception_score.py
index b63b8af..a9b1aa6 100755
--- a/metrics/inception_score.py
+++ b/metrics/inception_score.py
@@ -16,16 +16,19 @@ from training import misc
 #----------------------------------------------------------------------------
 
 class IS(metric_base.MetricBase):
-    def __init__(self, num_images, num_splits, minibatch_per_gpu, **kwargs):
+    def __init__(self, num_images, num_splits, minibatch_per_gpu, num_repeats=1, **kwargs):
         super().__init__(**kwargs)
         self.num_images = num_images
         self.num_splits = num_splits
+        self.num_repeats = num_repeats
         self.minibatch_per_gpu = minibatch_per_gpu
 
     def _evaluate(self, Gs, Gs_kwargs, num_gpus):
+        if self.num_images is None:
+            self.num_images = self._get_dataset_obj().num_samples
+        num_channels = Gs.output_shape[1]
         minibatch_size = num_gpus * self.minibatch_per_gpu
-        inception = misc.load_pkl('https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/inception_v3_softmax.pkl')
-        activations = np.empty([self.num_images, inception.output_shape[1]], dtype=np.float32)
+        inception = misc.load_pkl('http://d36zk2xti64re0.cloudfront.net/stylegan1/networks/metrics/inception_v3_softmax.pkl')
 
         # Construct TensorFlow graph.
         result_expr = []
@@ -36,23 +39,30 @@ class IS(metric_base.MetricBase):
                 latents = tf.random_normal([self.minibatch_per_gpu] + Gs_clone.input_shape[1:])
                 labels = self._get_random_labels_tf(self.minibatch_per_gpu)
                 images = Gs_clone.get_output_for(latents, labels, **Gs_kwargs)
+                if num_channels == 1:
+                    images = tf.repeat(images, 3, axis=1)
                 images = tflib.convert_images_to_uint8(images)
                 result_expr.append(inception_clone.get_output_for(images))
 
-        # Calculate activations for fakes.
-        for begin in range(0, self.num_images, minibatch_size):
-            self._report_progress(begin, self.num_images)
-            end = min(begin + minibatch_size, self.num_images)
-            activations[begin:end] = np.concatenate(tflib.run(result_expr), axis=0)[:end-begin]
-
-        # Calculate IS.
-        scores = []
-        for i in range(self.num_splits):
-            part = activations[i * self.num_images // self.num_splits : (i + 1) * self.num_images // self.num_splits]
-            kl = part * (np.log(part) - np.log(np.expand_dims(np.mean(part, 0), 0)))
-            kl = np.mean(np.sum(kl, 1))
-            scores.append(np.exp(kl))
-        self._report_result(np.mean(scores), suffix='_mean')
-        self._report_result(np.std(scores), suffix='_std')
+        activations = np.empty([self.num_images, inception.output_shape[1]], dtype=np.float32)
+        results = []
+        for _ in range(self.num_repeats):
+            # Calculate statistics for fakes.
+            for begin in range(0, self.num_images, minibatch_size):
+                self._report_progress(begin, self.num_images)
+                end = min(begin + minibatch_size, self.num_images)
+                activations[begin:end] = np.concatenate(tflib.run(result_expr), axis=0)[:end-begin]
+
+            # Calculate IS.
+            scores = []
+            for i in range(self.num_splits):
+                part = activations[i * self.num_images // self.num_splits : (i + 1) * self.num_images // self.num_splits]
+                kl = part * (np.log(part) - np.log(np.expand_dims(np.mean(part, 0), 0)))
+                kl = np.mean(np.sum(kl, 1))
+                scores.append(np.exp(kl))
+            results.append(np.mean(scores))
+        self._report_result(np.mean(results))
+        if self.num_repeats > 1:
+            self._report_result(np.std(results), suffix='-std')
 
 #----------------------------------------------------------------------------
diff --git a/metrics/linear_separability.py b/metrics/linear_separability.py
deleted file mode 100755
index 276bd02..0000000
--- a/metrics/linear_separability.py
+++ /dev/null
@@ -1,178 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""Linear Separability (LS)."""
-
-from collections import defaultdict
-import numpy as np
-import sklearn.svm
-import tensorflow as tf
-import dnnlib.tflib as tflib
-
-from metrics import metric_base
-from training import misc
-
-#----------------------------------------------------------------------------
-
-classifier_urls = [
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-00-male.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-01-smiling.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-02-attractive.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-03-wavy-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-04-young.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-05-5-o-clock-shadow.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-06-arched-eyebrows.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-07-bags-under-eyes.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-08-bald.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-09-bangs.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-10-big-lips.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-11-big-nose.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-12-black-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-13-blond-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-14-blurry.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-15-brown-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-16-bushy-eyebrows.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-17-chubby.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-18-double-chin.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-19-eyeglasses.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-20-goatee.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-21-gray-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-22-heavy-makeup.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-23-high-cheekbones.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-24-mouth-slightly-open.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-25-mustache.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-26-narrow-eyes.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-27-no-beard.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-28-oval-face.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-29-pale-skin.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-30-pointy-nose.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-31-receding-hairline.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-32-rosy-cheeks.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-33-sideburns.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-34-straight-hair.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-35-wearing-earrings.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-36-wearing-hat.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-37-wearing-lipstick.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-38-wearing-necklace.pkl',
-    'https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/celebahq-classifier-39-wearing-necktie.pkl',
-]
-
-#----------------------------------------------------------------------------
-
-def prob_normalize(p):
-    p = np.asarray(p).astype(np.float32)
-    assert len(p.shape) == 2
-    return p / np.sum(p)
-
-def mutual_information(p):
-    p = prob_normalize(p)
-    px = np.sum(p, axis=1)
-    py = np.sum(p, axis=0)
-    result = 0.0
-    for x in range(p.shape[0]):
-        p_x = px[x]
-        for y in range(p.shape[1]):
-            p_xy = p[x][y]
-            p_y = py[y]
-            if p_xy > 0.0:
-                result += p_xy * np.log2(p_xy / (p_x * p_y)) # get bits as output
-    return result
-
-def entropy(p):
-    p = prob_normalize(p)
-    result = 0.0
-    for x in range(p.shape[0]):
-        for y in range(p.shape[1]):
-            p_xy = p[x][y]
-            if p_xy > 0.0:
-                result -= p_xy * np.log2(p_xy)
-    return result
-
-def conditional_entropy(p):
-    # H(Y|X) where X corresponds to axis 0, Y to axis 1
-    # i.e., How many bits of additional information are needed to where we are on axis 1 if we know where we are on axis 0?
-    p = prob_normalize(p)
-    y = np.sum(p, axis=0, keepdims=True) # marginalize to calculate H(Y)
-    return max(0.0, entropy(y) - mutual_information(p)) # can slip just below 0 due to FP inaccuracies, clean those up.
-
-#----------------------------------------------------------------------------
-
-class LS(metric_base.MetricBase):
-    def __init__(self, num_samples, num_keep, attrib_indices, minibatch_per_gpu, **kwargs):
-        assert num_keep <= num_samples
-        super().__init__(**kwargs)
-        self.num_samples = num_samples
-        self.num_keep = num_keep
-        self.attrib_indices = attrib_indices
-        self.minibatch_per_gpu = minibatch_per_gpu
-
-    def _evaluate(self, Gs, Gs_kwargs, num_gpus):
-        minibatch_size = num_gpus * self.minibatch_per_gpu
-
-        # Construct TensorFlow graph for each GPU.
-        result_expr = []
-        for gpu_idx in range(num_gpus):
-            with tf.device('/gpu:%d' % gpu_idx):
-                Gs_clone = Gs.clone()
-
-                # Generate images.
-                latents = tf.random_normal([self.minibatch_per_gpu] + Gs_clone.input_shape[1:])
-                labels = self._get_random_labels_tf(self.minibatch_per_gpu)
-                dlatents = Gs_clone.components.mapping.get_output_for(latents, labels, **Gs_kwargs)
-                images = Gs_clone.get_output_for(latents, None, **Gs_kwargs)
-
-                # Downsample to 256x256. The attribute classifiers were built for 256x256.
-                if images.shape[2] > 256:
-                    factor = images.shape[2] // 256
-                    images = tf.reshape(images, [-1, images.shape[1], images.shape[2] // factor, factor, images.shape[3] // factor, factor])
-                    images = tf.reduce_mean(images, axis=[3, 5])
-
-                # Run classifier for each attribute.
-                result_dict = dict(latents=latents, dlatents=dlatents[:,-1])
-                for attrib_idx in self.attrib_indices:
-                    classifier = misc.load_pkl(classifier_urls[attrib_idx])
-                    logits = classifier.get_output_for(images, None)
-                    predictions = tf.nn.softmax(tf.concat([logits, -logits], axis=1))
-                    result_dict[attrib_idx] = predictions
-                result_expr.append(result_dict)
-
-        # Sampling loop.
-        results = []
-        for begin in range(0, self.num_samples, minibatch_size):
-            self._report_progress(begin, self.num_samples)
-            results += tflib.run(result_expr)
-        results = {key: np.concatenate([value[key] for value in results], axis=0) for key in results[0].keys()}
-
-        # Calculate conditional entropy for each attribute.
-        conditional_entropies = defaultdict(list)
-        for attrib_idx in self.attrib_indices:
-            # Prune the least confident samples.
-            pruned_indices = list(range(self.num_samples))
-            pruned_indices = sorted(pruned_indices, key=lambda i: -np.max(results[attrib_idx][i]))
-            pruned_indices = pruned_indices[:self.num_keep]
-
-            # Fit SVM to the remaining samples.
-            svm_targets = np.argmax(results[attrib_idx][pruned_indices], axis=1)
-            for space in ['latents', 'dlatents']:
-                svm_inputs = results[space][pruned_indices]
-                try:
-                    svm = sklearn.svm.LinearSVC()
-                    svm.fit(svm_inputs, svm_targets)
-                    svm.score(svm_inputs, svm_targets)
-                    svm_outputs = svm.predict(svm_inputs)
-                except:
-                    svm_outputs = svm_targets # assume perfect prediction
-
-                # Calculate conditional entropy.
-                p = [[np.mean([case == (row, col) for case in zip(svm_outputs, svm_targets)]) for col in (0, 1)] for row in (0, 1)]
-                conditional_entropies[space].append(conditional_entropy(p))
-
-        # Calculate separability scores.
-        scores = {key: 2**np.sum(values) for key, values in conditional_entropies.items()}
-        self._report_result(scores['latents'], suffix='_z')
-        self._report_result(scores['dlatents'], suffix='_w')
-
-#----------------------------------------------------------------------------
diff --git a/metrics/metric_base.py b/metrics/metric_base.py
index cbd0276..fe6b5e9 100755
--- a/metrics/metric_base.py
+++ b/metrics/metric_base.py
@@ -21,8 +21,10 @@ from training import dataset
 # Base class for metrics.
 
 class MetricBase:
-    def __init__(self, name):
+    def __init__(self, name, split='test', cache_dir='.stylegan2-cache'):
         self.name = name
+        self.split = split
+        self._cache_dir = cache_dir
         self._dataset_obj = None
         self._progress_lo = None
         self._progress_hi = None
@@ -41,8 +43,6 @@ class MetricBase:
         self._network_pkl = network_pkl
         self._data_dir = data_dir
         self._dataset_args = dataset_args
-        self._dataset_obj = None
-        self._mirror_augment = mirror_augment
         self._eval_time = 0
         self._results = []
 
@@ -50,7 +50,7 @@ class MetricBase:
             run_config = misc.parse_config_for_previous_run(run_dir)
             self._dataset_args = dict(run_config['dataset'])
             self._dataset_args['shuffle_mb'] = 0
-            self._mirror_augment = run_config['train'].get('mirror_augment', False)
+            self._dataset_args['num_samples'] = None
 
     def configure_progress_reports(self, plo, phi, pmax, psec=15):
         self._progress_lo = plo
@@ -58,12 +58,18 @@ class MetricBase:
         self._progress_max = pmax
         self._progress_sec = psec
 
-    def run(self, network_pkl, run_dir=None, data_dir=None, dataset_args=None, mirror_augment=None, num_gpus=1, tf_config=None, log_results=True, Gs_kwargs=dict(is_validation=True)):
+    def run(self, network_pkl, run_dir=None, data_dir=None, dataset_args=None, mirror_augment=None, num_gpus=1, disable_ema=False, tf_config=None, log_results=True, Gs_kwargs=dict(is_validation=True)):
         self._reset(network_pkl=network_pkl, run_dir=run_dir, data_dir=data_dir, dataset_args=dataset_args, mirror_augment=mirror_augment)
         time_begin = time.time()
         with tf.Graph().as_default(), tflib.create_session(tf_config).as_default(): # pylint: disable=not-context-manager
+            self._get_dataset_obj()
             self._report_progress(0, 1)
-            _G, _D, Gs = misc.load_pkl(self._network_pkl)
+            resume_networks = misc.load_pkl(self._network_pkl)
+            _G, _D, Gs = resume_networks
+            if disable_ema:
+                Gs = _G
+            parent_dir = os.path.dirname(self._network_pkl)
+            
             self._evaluate(Gs, Gs_kwargs=Gs_kwargs, num_gpus=num_gpus)
             self._report_progress(1, 1)
         self._eval_time = time.time() - time_begin # pylint: disable=attribute-defined-outside-init
@@ -107,34 +113,45 @@ class MetricBase:
         val = self._progress_lo + (pcur / pmax) * (self._progress_hi - self._progress_lo)
         dnnlib.RunContext.get().update(status_str, int(val), self._progress_max)
 
-    def _get_cache_file_for_reals(self, extension='pkl', **kwargs):
-        all_args = dnnlib.EasyDict(metric_name=self.name, mirror_augment=self._mirror_augment)
-        all_args.update(self._dataset_args)
-        all_args.update(kwargs)
-        md5 = hashlib.md5(repr(sorted(all_args.items())).encode('utf-8'))
-        dataset_name = self._dataset_args.get('tfrecord_dir', None) or self._dataset_args.get('h5_file', None)
-        dataset_name = os.path.splitext(os.path.basename(dataset_name))[0]
-        return os.path.join('.stylegan2-cache', '%s-%s-%s.%s' % (md5.hexdigest(), self.name, dataset_name, extension))
+    def _get_cache_file_for_reals(self, prefix, num_images, extension='pkl', mirror_augment=False):
+        dataset_name = self._get_dataset_obj().name
+        return os.path.join(self._cache_dir, '{}-{}-{}{}{}.{}'.format(
+            prefix,
+            dataset_name,
+            self.split,
+            '-{}'.format(num_images) if num_images else '',
+            '-flip' if mirror_augment else '',
+            extension,
+        ))
 
     def _get_dataset_obj(self):
         if self._dataset_obj is None:
-            self._dataset_obj = dataset.load_dataset(data_dir=self._data_dir, **self._dataset_args)
+            self._dataset_obj = dataset.load_dataset(data_dir=self._data_dir, split=self.split, repeat=False, **self._dataset_args)
         return self._dataset_obj
 
-    def _iterate_reals(self, minibatch_size):
+    def _iterate_reals(self, minibatch_size, return_label=False, num_samples=None, mirror_augment=False):
         dataset_obj = self._get_dataset_obj()
+        begin = 0
         while True:
-            images, _labels = dataset_obj.get_minibatch_np(minibatch_size)
-            if self._mirror_augment:
+            end = begin + minibatch_size
+            if num_samples:
+                end = min(end, num_samples)
+            try:
+                images, labels = dataset_obj.get_minibatch_np(end - begin)
+            except tf.errors.OutOfRangeError:
+                if num_samples is None:
+                    break
+                else:
+                    raise
+            if mirror_augment:
                 images = misc.apply_mirror_augment(images)
-            yield images
-
-    def _iterate_fakes(self, Gs, minibatch_size, num_gpus):
-        while True:
-            latents = np.random.randn(minibatch_size, *Gs.input_shape[1:])
-            fmt = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=True)
-            images = Gs.run(latents, None, output_transform=fmt, is_validation=True, num_gpus=num_gpus, assume_frozen=True)
-            yield images
+            if return_label:
+                yield (images, labels)
+            else:
+                yield images
+            if num_samples and end == num_samples:
+                break
+            begin = end
 
     def _get_random_labels_tf(self, minibatch_size):
         return self._get_dataset_obj().get_random_labels_tf(minibatch_size)
@@ -143,8 +160,8 @@ class MetricBase:
 # Group of multiple metrics.
 
 class MetricGroup:
-    def __init__(self, metric_kwarg_list):
-        self.metrics = [dnnlib.util.call_func_by_name(**kwargs) for kwargs in metric_kwarg_list]
+    def __init__(self, metric_kwarg_list, **kwargs):
+        self.metrics = [dnnlib.util.call_func_by_name(**metric_kwargs, **kwargs) for metric_kwargs in metric_kwarg_list]
 
     def run(self, *args, **kwargs):
         for metric in self.metrics:
diff --git a/metrics/metric_defaults.py b/metrics/metric_defaults.py
index 4371db8..ea6e230 100755
--- a/metrics/metric_defaults.py
+++ b/metrics/metric_defaults.py
@@ -11,15 +11,10 @@ from dnnlib import EasyDict
 #----------------------------------------------------------------------------
 
 metric_defaults = EasyDict([(args.name, args) for args in [
-    EasyDict(name='fid50k',    func_name='metrics.frechet_inception_distance.FID', num_images=50000, minibatch_per_gpu=8),
-    EasyDict(name='is50k',     func_name='metrics.inception_score.IS',             num_images=50000, num_splits=10, minibatch_per_gpu=8),
-    EasyDict(name='ppl_zfull', func_name='metrics.perceptual_path_length.PPL',     num_samples=50000, epsilon=1e-4, space='z', sampling='full', crop=True, minibatch_per_gpu=4, Gs_overrides=dict(dtype='float32', mapping_dtype='float32')),
-    EasyDict(name='ppl_wfull', func_name='metrics.perceptual_path_length.PPL',     num_samples=50000, epsilon=1e-4, space='w', sampling='full', crop=True, minibatch_per_gpu=4, Gs_overrides=dict(dtype='float32', mapping_dtype='float32')),
-    EasyDict(name='ppl_zend',  func_name='metrics.perceptual_path_length.PPL',     num_samples=50000, epsilon=1e-4, space='z', sampling='end', crop=True, minibatch_per_gpu=4, Gs_overrides=dict(dtype='float32', mapping_dtype='float32')),
-    EasyDict(name='ppl_wend',  func_name='metrics.perceptual_path_length.PPL',     num_samples=50000, epsilon=1e-4, space='w', sampling='end', crop=True, minibatch_per_gpu=4, Gs_overrides=dict(dtype='float32', mapping_dtype='float32')),
-    EasyDict(name='ppl2_wend', func_name='metrics.perceptual_path_length.PPL',     num_samples=50000, epsilon=1e-4, space='w', sampling='end', crop=False, minibatch_per_gpu=4, Gs_overrides=dict(dtype='float32', mapping_dtype='float32')),
-    EasyDict(name='ls',        func_name='metrics.linear_separability.LS',         num_samples=200000, num_keep=100000, attrib_indices=range(40), minibatch_per_gpu=4),
-    EasyDict(name='pr50k3',    func_name='metrics.precision_recall.PR',            num_images=50000, nhood_size=3, minibatch_per_gpu=8, row_batch_size=10000, col_batch_size=10000),
+    EasyDict(name='fid10k',       func_name='metrics.frechet_inception_distance.FID', num_images=10000, minibatch_per_gpu=8),
+    EasyDict(name='fid5k-train',  func_name='metrics.frechet_inception_distance.FID', num_images=5000,  split='train', minibatch_per_gpu=8),
+    EasyDict(name='fid50k-train', func_name='metrics.frechet_inception_distance.FID', num_images=50000, split='train', minibatch_per_gpu=8),
+    EasyDict(name='is10k',        func_name='metrics.inception_score.IS',             num_images=10000, num_splits=10, minibatch_per_gpu=8),
 ]])
 
 #----------------------------------------------------------------------------
diff --git a/metrics/perceptual_path_length.py b/metrics/perceptual_path_length.py
deleted file mode 100755
index 6a72c6b..0000000
--- a/metrics/perceptual_path_length.py
+++ /dev/null
@@ -1,116 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""Perceptual Path Length (PPL)."""
-
-import numpy as np
-import tensorflow as tf
-import dnnlib.tflib as tflib
-
-from metrics import metric_base
-from training import misc
-
-#----------------------------------------------------------------------------
-
-# Normalize batch of vectors.
-def normalize(v):
-    return v / tf.sqrt(tf.reduce_sum(tf.square(v), axis=-1, keepdims=True))
-
-# Spherical interpolation of a batch of vectors.
-def slerp(a, b, t):
-    a = normalize(a)
-    b = normalize(b)
-    d = tf.reduce_sum(a * b, axis=-1, keepdims=True)
-    p = t * tf.math.acos(d)
-    c = normalize(b - d * a)
-    d = a * tf.math.cos(p) + c * tf.math.sin(p)
-    return normalize(d)
-
-#----------------------------------------------------------------------------
-
-class PPL(metric_base.MetricBase):
-    def __init__(self, num_samples, epsilon, space, sampling, crop, minibatch_per_gpu, Gs_overrides, **kwargs):
-        assert space in ['z', 'w']
-        assert sampling in ['full', 'end']
-        super().__init__(**kwargs)
-        self.num_samples = num_samples
-        self.epsilon = epsilon
-        self.space = space
-        self.sampling = sampling
-        self.crop = crop
-        self.minibatch_per_gpu = minibatch_per_gpu
-        self.Gs_overrides = Gs_overrides
-
-    def _evaluate(self, Gs, Gs_kwargs, num_gpus):
-        Gs_kwargs = dict(Gs_kwargs)
-        Gs_kwargs.update(self.Gs_overrides)
-        minibatch_size = num_gpus * self.minibatch_per_gpu
-
-        # Construct TensorFlow graph.
-        distance_expr = []
-        for gpu_idx in range(num_gpus):
-            with tf.device('/gpu:%d' % gpu_idx):
-                Gs_clone = Gs.clone()
-                noise_vars = [var for name, var in Gs_clone.components.synthesis.vars.items() if name.startswith('noise')]
-
-                # Generate random latents and interpolation t-values.
-                lat_t01 = tf.random_normal([self.minibatch_per_gpu * 2] + Gs_clone.input_shape[1:])
-                lerp_t = tf.random_uniform([self.minibatch_per_gpu], 0.0, 1.0 if self.sampling == 'full' else 0.0)
-                labels = tf.reshape(tf.tile(self._get_random_labels_tf(self.minibatch_per_gpu), [1, 2]), [self.minibatch_per_gpu * 2, -1])
-
-                # Interpolate in W or Z.
-                if self.space == 'w':
-                    dlat_t01 = Gs_clone.components.mapping.get_output_for(lat_t01, labels, **Gs_kwargs)
-                    dlat_t01 = tf.cast(dlat_t01, tf.float32)
-                    dlat_t0, dlat_t1 = dlat_t01[0::2], dlat_t01[1::2]
-                    dlat_e0 = tflib.lerp(dlat_t0, dlat_t1, lerp_t[:, np.newaxis, np.newaxis])
-                    dlat_e1 = tflib.lerp(dlat_t0, dlat_t1, lerp_t[:, np.newaxis, np.newaxis] + self.epsilon)
-                    dlat_e01 = tf.reshape(tf.stack([dlat_e0, dlat_e1], axis=1), dlat_t01.shape)
-                else: # space == 'z'
-                    lat_t0, lat_t1 = lat_t01[0::2], lat_t01[1::2]
-                    lat_e0 = slerp(lat_t0, lat_t1, lerp_t[:, np.newaxis])
-                    lat_e1 = slerp(lat_t0, lat_t1, lerp_t[:, np.newaxis] + self.epsilon)
-                    lat_e01 = tf.reshape(tf.stack([lat_e0, lat_e1], axis=1), lat_t01.shape)
-                    dlat_e01 = Gs_clone.components.mapping.get_output_for(lat_e01, labels, **Gs_kwargs)
-
-                # Synthesize images.
-                with tf.control_dependencies([var.initializer for var in noise_vars]): # use same noise inputs for the entire minibatch
-                    images = Gs_clone.components.synthesis.get_output_for(dlat_e01, randomize_noise=False, **Gs_kwargs)
-                    images = tf.cast(images, tf.float32)
-
-                # Crop only the face region.
-                if self.crop:
-                    c = int(images.shape[2] // 8)
-                    images = images[:, :, c*3 : c*7, c*2 : c*6]
-
-                # Downsample image to 256x256 if it's larger than that. VGG was built for 224x224 images.
-                factor = images.shape[2] // 256
-                if factor > 1:
-                    images = tf.reshape(images, [-1, images.shape[1], images.shape[2] // factor, factor, images.shape[3] // factor, factor])
-                    images = tf.reduce_mean(images, axis=[3,5])
-
-                # Scale dynamic range from [-1,1] to [0,255] for VGG.
-                images = (images + 1) * (255 / 2)
-
-                # Evaluate perceptual distance.
-                img_e0, img_e1 = images[0::2], images[1::2]
-                distance_measure = misc.load_pkl('https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/vgg16_zhang_perceptual.pkl')
-                distance_expr.append(distance_measure.get_output_for(img_e0, img_e1) * (1 / self.epsilon**2))
-
-        # Sampling loop.
-        all_distances = []
-        for begin in range(0, self.num_samples, minibatch_size):
-            self._report_progress(begin, self.num_samples)
-            all_distances += tflib.run(distance_expr)
-        all_distances = np.concatenate(all_distances, axis=0)
-
-        # Reject outliers.
-        lo = np.percentile(all_distances, 1, interpolation='lower')
-        hi = np.percentile(all_distances, 99, interpolation='higher')
-        filtered_distances = np.extract(np.logical_and(lo <= all_distances, all_distances <= hi), all_distances)
-        self._report_result(np.mean(filtered_distances))
-
-#----------------------------------------------------------------------------
diff --git a/metrics/precision_recall.py b/metrics/precision_recall.py
deleted file mode 100755
index 688edcb..0000000
--- a/metrics/precision_recall.py
+++ /dev/null
@@ -1,224 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""Precision/Recall (PR)."""
-
-import os
-import numpy as np
-import tensorflow as tf
-import dnnlib
-import dnnlib.tflib as tflib
-
-from metrics import metric_base
-from training import misc
-
-#----------------------------------------------------------------------------
-
-def batch_pairwise_distances(U, V):
-    """ Compute pairwise distances between two batches of feature vectors."""
-    with tf.variable_scope('pairwise_dist_block'):
-        # Squared norms of each row in U and V.
-        norm_u = tf.reduce_sum(tf.square(U), 1)
-        norm_v = tf.reduce_sum(tf.square(V), 1)
-
-        # norm_u as a row and norm_v as a column vectors.
-        norm_u = tf.reshape(norm_u, [-1, 1])
-        norm_v = tf.reshape(norm_v, [1, -1])
-
-        # Pairwise squared Euclidean distances.
-        D = tf.maximum(norm_u - 2*tf.matmul(U, V, False, True) + norm_v, 0.0)
-
-    return D
-
-#----------------------------------------------------------------------------
-
-class DistanceBlock():
-    """Distance block."""
-    def __init__(self, num_features, num_gpus):
-        self.num_features = num_features
-        self.num_gpus = num_gpus
-
-        # Initialize TF graph to calculate pairwise distances.
-        with tf.device('/cpu:0'):
-            self._features_batch1 = tf.placeholder(tf.float16, shape=[None, self.num_features])
-            self._features_batch2 = tf.placeholder(tf.float16, shape=[None, self.num_features])
-            features_split2 = tf.split(self._features_batch2, self.num_gpus, axis=0)
-            distances_split = []
-            for gpu_idx in range(self.num_gpus):
-                with tf.device('/gpu:%d' % gpu_idx):
-                    distances_split.append(batch_pairwise_distances(self._features_batch1, features_split2[gpu_idx]))
-            self._distance_block = tf.concat(distances_split, axis=1)
-
-    def pairwise_distances(self, U, V):
-        """Evaluate pairwise distances between two batches of feature vectors."""
-        return self._distance_block.eval(feed_dict={self._features_batch1: U, self._features_batch2: V})
-
-#----------------------------------------------------------------------------
-
-class ManifoldEstimator():
-    """Finds an estimate for the manifold of given feature vectors."""
-    def __init__(self, distance_block, features, row_batch_size, col_batch_size, nhood_sizes, clamp_to_percentile=None):
-        """Find an estimate of the manifold of given feature vectors."""
-        num_images = features.shape[0]
-        self.nhood_sizes = nhood_sizes
-        self.num_nhoods = len(nhood_sizes)
-        self.row_batch_size = row_batch_size
-        self.col_batch_size = col_batch_size
-        self._ref_features = features
-        self._distance_block = distance_block
-
-        # Estimate manifold of features by calculating distances to kth nearest neighbor of each sample.
-        self.D = np.zeros([num_images, self.num_nhoods], dtype=np.float16)
-        distance_batch = np.zeros([row_batch_size, num_images], dtype=np.float16)
-        seq = np.arange(max(self.nhood_sizes) + 1, dtype=np.int32)
-
-        for begin1 in range(0, num_images, row_batch_size):
-            end1 = min(begin1 + row_batch_size, num_images)
-            row_batch = features[begin1:end1]
-
-            for begin2 in range(0, num_images, col_batch_size):
-                end2 = min(begin2 + col_batch_size, num_images)
-                col_batch = features[begin2:end2]
-
-                # Compute distances between batches.
-                distance_batch[0:end1-begin1, begin2:end2] = self._distance_block.pairwise_distances(row_batch, col_batch)
-
-            # Find the kth nearest neighbor from the current batch.
-            self.D[begin1:end1, :] = np.partition(distance_batch[0:end1-begin1, :], seq, axis=1)[:, self.nhood_sizes]
-
-        if clamp_to_percentile is not None:
-            max_distances = np.percentile(self.D, clamp_to_percentile, axis=0)
-            self.D[self.D > max_distances] = 0  #max_distances  # 0
-
-    def evaluate(self, eval_features, return_realism=False, return_neighbors=False):
-        """Evaluate if new feature vectors are in the estimated manifold."""
-        num_eval_images = eval_features.shape[0]
-        num_ref_images = self.D.shape[0]
-        distance_batch = np.zeros([self.row_batch_size, num_ref_images], dtype=np.float16)
-        batch_predictions = np.zeros([num_eval_images, self.num_nhoods], dtype=np.int32)
-        #max_realism_score = np.zeros([num_eval_images,], dtype=np.float32)
-        realism_score = np.zeros([num_eval_images,], dtype=np.float32)
-        nearest_indices = np.zeros([num_eval_images,], dtype=np.int32)
-
-        for begin1 in range(0, num_eval_images, self.row_batch_size):
-            end1 = min(begin1 + self.row_batch_size, num_eval_images)
-            feature_batch = eval_features[begin1:end1]
-
-            for begin2 in range(0, num_ref_images, self.col_batch_size):
-                end2 = min(begin2 + self.col_batch_size, num_ref_images)
-                ref_batch = self._ref_features[begin2:end2]
-
-                distance_batch[0:end1-begin1, begin2:end2] = self._distance_block.pairwise_distances(feature_batch, ref_batch)
-
-            # From the minibatch of new feature vectors, determine if they are in the estimated manifold.
-            # If a feature vector is inside a hypersphere of some reference sample, then the new sample lies on the estimated manifold.
-            # The radii of the hyperspheres are determined from distances of neighborhood size k.
-            samples_in_manifold = distance_batch[0:end1-begin1, :, None] <= self.D
-            batch_predictions[begin1:end1] = np.any(samples_in_manifold, axis=1).astype(np.int32)
-
-            #max_realism_score[begin1:end1] = np.max(self.D[:, 0] / (distance_batch[0:end1-begin1, :] + 1e-18), axis=1)
-            #nearest_indices[begin1:end1] = np.argmax(self.D[:, 0] / (distance_batch[0:end1-begin1, :] + 1e-18), axis=1)
-            nearest_indices[begin1:end1] = np.argmin(distance_batch[0:end1-begin1, :], axis=1)
-            realism_score[begin1:end1] = self.D[nearest_indices[begin1:end1], 0] / np.min(distance_batch[0:end1-begin1, :], axis=1)
-
-        if return_realism and return_neighbors:
-            return batch_predictions, realism_score, nearest_indices
-        elif return_realism:
-            return batch_predictions, realism_score
-        elif return_neighbors:
-            return batch_predictions, nearest_indices
-
-        return batch_predictions
-
-#----------------------------------------------------------------------------
-
-def knn_precision_recall_features(ref_features, eval_features, feature_net, nhood_sizes,
-                                  row_batch_size, col_batch_size, num_gpus):
-    """Calculates k-NN precision and recall for two sets of feature vectors."""
-    state = dnnlib.EasyDict()
-    #num_images = ref_features.shape[0]
-    num_features = feature_net.output_shape[1]
-    state.ref_features = ref_features
-    state.eval_features = eval_features
-
-    # Initialize DistanceBlock and ManifoldEstimators.
-    distance_block = DistanceBlock(num_features, num_gpus)
-    state.ref_manifold = ManifoldEstimator(distance_block, state.ref_features, row_batch_size, col_batch_size, nhood_sizes)
-    state.eval_manifold = ManifoldEstimator(distance_block, state.eval_features, row_batch_size, col_batch_size, nhood_sizes)
-
-    # Evaluate precision and recall using k-nearest neighbors.
-    #print('Evaluating k-NN precision and recall with %i samples...' % num_images)
-    #start = time.time()
-
-    # Precision: How many points from eval_features are in ref_features manifold.
-    state.precision, state.realism_scores, state.nearest_neighbors = state.ref_manifold.evaluate(state.eval_features, return_realism=True, return_neighbors=True)
-    state.knn_precision = state.precision.mean(axis=0)
-
-    # Recall: How many points from ref_features are in eval_features manifold.
-    state.recall = state.eval_manifold.evaluate(state.ref_features)
-    state.knn_recall = state.recall.mean(axis=0)
-
-    #elapsed_time = time.time() - start
-    #print('Done evaluation in: %gs' % elapsed_time)
-
-    return state
-
-#----------------------------------------------------------------------------
-
-class PR(metric_base.MetricBase):
-    def __init__(self, num_images, nhood_size, minibatch_per_gpu, row_batch_size, col_batch_size, **kwargs):
-        super().__init__(**kwargs)
-        self.num_images = num_images
-        self.nhood_size = nhood_size
-        self.minibatch_per_gpu = minibatch_per_gpu
-        self.row_batch_size = row_batch_size
-        self.col_batch_size = col_batch_size
-
-    def _evaluate(self, Gs, Gs_kwargs, num_gpus):
-        minibatch_size = num_gpus * self.minibatch_per_gpu
-        feature_net = misc.load_pkl('https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/vgg16.pkl')
-
-        # Calculate features for reals.
-        cache_file = self._get_cache_file_for_reals(num_images=self.num_images)
-        os.makedirs(os.path.dirname(cache_file), exist_ok=True)
-        if os.path.isfile(cache_file):
-            ref_features = misc.load_pkl(cache_file)
-        else:
-            ref_features = np.empty([self.num_images, feature_net.output_shape[1]], dtype=np.float32)
-            for idx, images in enumerate(self._iterate_reals(minibatch_size=minibatch_size)):
-                begin = idx * minibatch_size
-                end = min(begin + minibatch_size, self.num_images)
-                ref_features[begin:end] = feature_net.run(images[:end-begin], num_gpus=num_gpus, assume_frozen=True)
-                if end == self.num_images:
-                    break
-            misc.save_pkl(ref_features, cache_file)
-
-        # Construct TensorFlow graph.
-        result_expr = []
-        for gpu_idx in range(num_gpus):
-            with tf.device('/gpu:%d' % gpu_idx):
-                Gs_clone = Gs.clone()
-                feature_net_clone = feature_net.clone()
-                latents = tf.random_normal([self.minibatch_per_gpu] + Gs_clone.input_shape[1:])
-                labels = self._get_random_labels_tf(self.minibatch_per_gpu)
-                images = Gs_clone.get_output_for(latents, labels, **Gs_kwargs)
-                images = tflib.convert_images_to_uint8(images)
-                result_expr.append(feature_net_clone.get_output_for(images))
-
-        # Calculate features for fakes.
-        eval_features = np.empty([self.num_images, feature_net.output_shape[1]], dtype=np.float32)
-        for begin in range(0, self.num_images, minibatch_size):
-            self._report_progress(begin, self.num_images)
-            end = min(begin + minibatch_size, self.num_images)
-            eval_features[begin:end] = np.concatenate(tflib.run(result_expr), axis=0)[:end-begin]
-
-        # Calculate precision and recall.
-        state = knn_precision_recall_features(ref_features=ref_features, eval_features=eval_features, feature_net=feature_net,
-            nhood_sizes=[self.nhood_size], row_batch_size=self.row_batch_size, col_batch_size=self.row_batch_size, num_gpus=num_gpus)
-        self._report_result(state.knn_precision[0], suffix='_precision')
-        self._report_result(state.knn_recall[0], suffix='_recall')
-
-#----------------------------------------------------------------------------
diff --git a/pretrained_networks.py b/pretrained_networks.py
deleted file mode 100755
index 58c1c63..0000000
--- a/pretrained_networks.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""List of pre-trained StyleGAN2 networks located on Google Drive."""
-
-import pickle
-import dnnlib
-import dnnlib.tflib as tflib
-
-#----------------------------------------------------------------------------
-# StyleGAN2 Google Drive root: https://drive.google.com/open?id=1QHc-yF5C3DChRwSdZKcx1w6K8JvSxQi7
-
-gdrive_urls = {
-    'gdrive:networks/stylegan2-car-config-a.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-a.pkl',
-    'gdrive:networks/stylegan2-car-config-b.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-b.pkl',
-    'gdrive:networks/stylegan2-car-config-c.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-c.pkl',
-    'gdrive:networks/stylegan2-car-config-d.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-d.pkl',
-    'gdrive:networks/stylegan2-car-config-e.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-e.pkl',
-    'gdrive:networks/stylegan2-car-config-f.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-car-config-f.pkl',
-    'gdrive:networks/stylegan2-cat-config-a.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-cat-config-a.pkl',
-    'gdrive:networks/stylegan2-cat-config-f.pkl':                           'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-cat-config-f.pkl',
-    'gdrive:networks/stylegan2-church-config-a.pkl':                        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-church-config-a.pkl',
-    'gdrive:networks/stylegan2-church-config-f.pkl':                        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-church-config-f.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-a.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-a.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-b.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-b.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-c.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-c.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-d.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-d.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-e.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-e.pkl',
-    'gdrive:networks/stylegan2-ffhq-config-f.pkl':                          'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-ffhq-config-f.pkl',
-    'gdrive:networks/stylegan2-horse-config-a.pkl':                         'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-horse-config-a.pkl',
-    'gdrive:networks/stylegan2-horse-config-f.pkl':                         'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/stylegan2-horse-config-f.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gorig-Dorig.pkl':        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gorig-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gorig-Dresnet.pkl':      'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gorig-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gorig-Dskip.pkl':        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gorig-Dskip.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gresnet-Dorig.pkl':      'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gresnet-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gresnet-Dresnet.pkl':    'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gresnet-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gresnet-Dskip.pkl':      'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gresnet-Dskip.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gskip-Dorig.pkl':        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gskip-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gskip-Dresnet.pkl':      'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gskip-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-car-config-e-Gskip-Dskip.pkl':        'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-car-config-e-Gskip-Dskip.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gorig-Dorig.pkl':       'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gorig-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gorig-Dresnet.pkl':     'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gorig-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gorig-Dskip.pkl':       'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gorig-Dskip.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gresnet-Dorig.pkl':     'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gresnet-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gresnet-Dresnet.pkl':   'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gresnet-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gresnet-Dskip.pkl':     'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gresnet-Dskip.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gskip-Dorig.pkl':       'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gskip-Dorig.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gskip-Dresnet.pkl':     'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gskip-Dresnet.pkl',
-    'gdrive:networks/table2/stylegan2-ffhq-config-e-Gskip-Dskip.pkl':       'https://nvlabs-fi-cdn.nvidia.com/stylegan2/networks/table2/stylegan2-ffhq-config-e-Gskip-Dskip.pkl',
-}
-
-#----------------------------------------------------------------------------
-
-def get_path_or_url(path_or_gdrive_path):
-    return gdrive_urls.get(path_or_gdrive_path, path_or_gdrive_path)
-
-#----------------------------------------------------------------------------
-
-_cached_networks = dict()
-
-def load_networks(path_or_gdrive_path):
-    path_or_url = get_path_or_url(path_or_gdrive_path)
-    if path_or_url in _cached_networks:
-        return _cached_networks[path_or_url]
-
-    if dnnlib.util.is_url(path_or_url):
-        stream = dnnlib.util.open_url(path_or_url, cache_dir='.stylegan2-cache')
-    else:
-        stream = open(path_or_url, 'rb')
-
-    tflib.init_tf()
-    with stream:
-        G, D, Gs = pickle.load(stream, encoding='latin1')
-    _cached_networks[path_or_url] = G, D, Gs
-    return G, D, Gs
-
-#----------------------------------------------------------------------------
diff --git a/projector.py b/projector.py
deleted file mode 100755
index 34f2d42..0000000
--- a/projector.py
+++ /dev/null
@@ -1,206 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-import numpy as np
-import tensorflow as tf
-import dnnlib
-import dnnlib.tflib as tflib
-
-from training import misc
-
-#----------------------------------------------------------------------------
-
-class Projector:
-    def __init__(self):
-        self.num_steps                  = 1000
-        self.dlatent_avg_samples        = 10000
-        self.initial_learning_rate      = 0.1
-        self.initial_noise_factor       = 0.05
-        self.lr_rampdown_length         = 0.25
-        self.lr_rampup_length           = 0.05
-        self.noise_ramp_length          = 0.75
-        self.regularize_noise_weight    = 1e5
-        self.verbose                    = False
-        self.clone_net                  = True
-
-        self._Gs                    = None
-        self._minibatch_size        = None
-        self._dlatent_avg           = None
-        self._dlatent_std           = None
-        self._noise_vars            = None
-        self._noise_init_op         = None
-        self._noise_normalize_op    = None
-        self._dlatents_var          = None
-        self._noise_in              = None
-        self._dlatents_expr         = None
-        self._images_expr           = None
-        self._target_images_var     = None
-        self._lpips                 = None
-        self._dist                  = None
-        self._loss                  = None
-        self._reg_sizes             = None
-        self._lrate_in              = None
-        self._opt                   = None
-        self._opt_step              = None
-        self._cur_step              = None
-
-    def _info(self, *args):
-        if self.verbose:
-            print('Projector:', *args)
-
-    def set_network(self, Gs, minibatch_size=1):
-        assert minibatch_size == 1
-        self._Gs = Gs
-        self._minibatch_size = minibatch_size
-        if self._Gs is None:
-            return
-        if self.clone_net:
-            self._Gs = self._Gs.clone()
-
-        # Find dlatent stats.
-        self._info('Finding W midpoint and stddev using %d samples...' % self.dlatent_avg_samples)
-        latent_samples = np.random.RandomState(123).randn(self.dlatent_avg_samples, *self._Gs.input_shapes[0][1:])
-        dlatent_samples = self._Gs.components.mapping.run(latent_samples, None)[:, :1, :] # [N, 1, 512]
-        self._dlatent_avg = np.mean(dlatent_samples, axis=0, keepdims=True) # [1, 1, 512]
-        self._dlatent_std = (np.sum((dlatent_samples - self._dlatent_avg) ** 2) / self.dlatent_avg_samples) ** 0.5
-        self._info('std = %g' % self._dlatent_std)
-
-        # Find noise inputs.
-        self._info('Setting up noise inputs...')
-        self._noise_vars = []
-        noise_init_ops = []
-        noise_normalize_ops = []
-        while True:
-            n = 'G_synthesis/noise%d' % len(self._noise_vars)
-            if not n in self._Gs.vars:
-                break
-            v = self._Gs.vars[n]
-            self._noise_vars.append(v)
-            noise_init_ops.append(tf.assign(v, tf.random_normal(tf.shape(v), dtype=tf.float32)))
-            noise_mean = tf.reduce_mean(v)
-            noise_std = tf.reduce_mean((v - noise_mean)**2)**0.5
-            noise_normalize_ops.append(tf.assign(v, (v - noise_mean) / noise_std))
-            self._info(n, v)
-        self._noise_init_op = tf.group(*noise_init_ops)
-        self._noise_normalize_op = tf.group(*noise_normalize_ops)
-
-        # Image output graph.
-        self._info('Building image output graph...')
-        self._dlatents_var = tf.Variable(tf.zeros([self._minibatch_size] + list(self._dlatent_avg.shape[1:])), name='dlatents_var')
-        self._noise_in = tf.placeholder(tf.float32, [], name='noise_in')
-        dlatents_noise = tf.random.normal(shape=self._dlatents_var.shape) * self._noise_in
-        self._dlatents_expr = tf.tile(self._dlatents_var + dlatents_noise, [1, self._Gs.components.synthesis.input_shape[1], 1])
-        self._images_expr = self._Gs.components.synthesis.get_output_for(self._dlatents_expr, randomize_noise=False)
-
-        # Downsample image to 256x256 if it's larger than that. VGG was built for 224x224 images.
-        proc_images_expr = (self._images_expr + 1) * (255 / 2)
-        sh = proc_images_expr.shape.as_list()
-        if sh[2] > 256:
-            factor = sh[2] // 256
-            proc_images_expr = tf.reduce_mean(tf.reshape(proc_images_expr, [-1, sh[1], sh[2] // factor, factor, sh[2] // factor, factor]), axis=[3,5])
-
-        # Loss graph.
-        self._info('Building loss graph...')
-        self._target_images_var = tf.Variable(tf.zeros(proc_images_expr.shape), name='target_images_var')
-        if self._lpips is None:
-            self._lpips = misc.load_pkl('https://nvlabs-fi-cdn.nvidia.com/stylegan/networks/metrics/vgg16_zhang_perceptual.pkl')
-        self._dist = self._lpips.get_output_for(proc_images_expr, self._target_images_var)
-        self._loss = tf.reduce_sum(self._dist)
-
-        # Noise regularization graph.
-        self._info('Building noise regularization graph...')
-        reg_loss = 0.0
-        for v in self._noise_vars:
-            sz = v.shape[2]
-            while True:
-                reg_loss += tf.reduce_mean(v * tf.roll(v, shift=1, axis=3))**2 + tf.reduce_mean(v * tf.roll(v, shift=1, axis=2))**2
-                if sz <= 8:
-                    break # Small enough already
-                v = tf.reshape(v, [1, 1, sz//2, 2, sz//2, 2]) # Downscale
-                v = tf.reduce_mean(v, axis=[3, 5])
-                sz = sz // 2
-        self._loss += reg_loss * self.regularize_noise_weight
-
-        # Optimizer.
-        self._info('Setting up optimizer...')
-        self._lrate_in = tf.placeholder(tf.float32, [], name='lrate_in')
-        self._opt = dnnlib.tflib.Optimizer(learning_rate=self._lrate_in)
-        self._opt.register_gradients(self._loss, [self._dlatents_var] + self._noise_vars)
-        self._opt_step = self._opt.apply_updates()
-
-    def run(self, target_images):
-        # Run to completion.
-        self.start(target_images)
-        while self._cur_step < self.num_steps:
-            self.step()
-
-        # Collect results.
-        pres = dnnlib.EasyDict()
-        pres.dlatents = self.get_dlatents()
-        pres.noises = self.get_noises()
-        pres.images = self.get_images()
-        return pres
-
-    def start(self, target_images):
-        assert self._Gs is not None
-
-        # Prepare target images.
-        self._info('Preparing target images...')
-        target_images = np.asarray(target_images, dtype='float32')
-        target_images = (target_images + 1) * (255 / 2)
-        sh = target_images.shape
-        assert sh[0] == self._minibatch_size
-        if sh[2] > self._target_images_var.shape[2]:
-            factor = sh[2] // self._target_images_var.shape[2]
-            target_images = np.reshape(target_images, [-1, sh[1], sh[2] // factor, factor, sh[3] // factor, factor]).mean((3, 5))
-
-        # Initialize optimization state.
-        self._info('Initializing optimization state...')
-        tflib.set_vars({self._target_images_var: target_images, self._dlatents_var: np.tile(self._dlatent_avg, [self._minibatch_size, 1, 1])})
-        tflib.run(self._noise_init_op)
-        self._opt.reset_optimizer_state()
-        self._cur_step = 0
-
-    def step(self):
-        assert self._cur_step is not None
-        if self._cur_step >= self.num_steps:
-            return
-        if self._cur_step == 0:
-            self._info('Running...')
-
-        # Hyperparameters.
-        t = self._cur_step / self.num_steps
-        noise_strength = self._dlatent_std * self.initial_noise_factor * max(0.0, 1.0 - t / self.noise_ramp_length) ** 2
-        lr_ramp = min(1.0, (1.0 - t) / self.lr_rampdown_length)
-        lr_ramp = 0.5 - 0.5 * np.cos(lr_ramp * np.pi)
-        lr_ramp = lr_ramp * min(1.0, t / self.lr_rampup_length)
-        learning_rate = self.initial_learning_rate * lr_ramp
-
-        # Train.
-        feed_dict = {self._noise_in: noise_strength, self._lrate_in: learning_rate}
-        _, dist_value, loss_value = tflib.run([self._opt_step, self._dist, self._loss], feed_dict)
-        tflib.run(self._noise_normalize_op)
-
-        # Print status.
-        self._cur_step += 1
-        if self._cur_step == self.num_steps or self._cur_step % 10 == 0:
-            self._info('%-8d%-12g%-12g' % (self._cur_step, dist_value, loss_value))
-        if self._cur_step == self.num_steps:
-            self._info('Done.')
-
-    def get_cur_step(self):
-        return self._cur_step
-
-    def get_dlatents(self):
-        return tflib.run(self._dlatents_expr, {self._noise_in: 0})
-
-    def get_noises(self):
-        return tflib.run(self._noise_vars)
-
-    def get_images(self):
-        return tflib.run(self._images_expr, {self._noise_in: 0})
-
-#----------------------------------------------------------------------------
diff --git a/run_cifar.py b/run_cifar.py
new file mode 100644
index 0000000..d89d34f
--- /dev/null
+++ b/run_cifar.py
@@ -0,0 +1,168 @@
+# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
+#
+# This work is made available under the Nvidia Source Code License-NC.
+# To view a copy of this license, visit
+# https://nvlabs.github.io/stylegan2/license.html
+
+import argparse
+import copy
+import os
+import sys
+
+import dnnlib
+from dnnlib import tflib
+from dnnlib import EasyDict
+
+from metrics import metric_base
+from metrics.metric_defaults import metric_defaults
+from training import misc
+
+# ----------------------------------------------------------------------------
+
+
+def run(dataset, resolution, result_dir, DiffAugment, num_gpus, batch_size, total_kimg, ema_kimg, num_samples, gamma, fmap_base, fmap_max, latent_size, mirror_augment, impl, metrics, resume, resume_kimg, num_repeats, eval):
+    train = EasyDict(run_func_name='training.training_loop.training_loop')  # Options for training loop.
+    G = EasyDict(func_name='training.networks_stylegan2.G_main')       # Options for generator network.
+    D = EasyDict(func_name='training.networks_stylegan2.D_stylegan2')  # Options for discriminator network.
+    G_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for generator optimizer.
+    D_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for discriminator optimizer.
+    loss_args = EasyDict(func_name='training.loss.ns_r1_DiffAugment')          # Options for loss.
+    sched = EasyDict()                                                     # Options for TrainingSchedule.
+    grid = EasyDict(size='4k', layout='random')                           # Options for setup_snapshot_image_grid().
+    sc = dnnlib.SubmitConfig()                                          # Options for dnnlib.submit_run().
+    tf_config = {'rnd.np_random_seed': 1000}                                   # Options for tflib.init_tf().
+
+    train.total_kimg = total_kimg
+    train.mirror_augment = mirror_augment
+    metrics = [metric_defaults[x] for x in metrics]
+    metric_args = EasyDict(num_repeats=num_repeats)
+
+    desc = 'DiffAugment-stylegan2' if DiffAugment else 'stylegan2'
+    dataset_args = EasyDict(tfrecord_dir=dataset, resolution=resolution)
+    desc += '-' + os.path.basename(dataset)
+    if resolution is not None:
+        desc += '-{}'.format(resolution)
+
+    if num_samples is not None:
+        dataset_args.num_samples = num_samples
+        desc += '-{}samples'.format(num_samples)
+
+    if batch_size is not None:
+        desc += '-batch{}'.format(batch_size)
+    else:
+        batch_size = 32
+    assert batch_size % num_gpus == 0
+    sc.num_gpus = num_gpus
+    desc += '-%dgpu' % num_gpus
+    sched.minibatch_size_base = batch_size
+    sched.minibatch_gpu_base = batch_size // num_gpus
+
+    G.impl = D.impl = impl
+    if fmap_base is not None:
+        G.fmap_base = D.fmap_base = fmap_base
+        desc += '-fmap{}'.format(fmap_base)
+    if fmap_max is not None:
+        G.fmap_max = D.fmap_max = fmap_max
+        desc += '-fmax{}'.format(fmap_max)
+    if latent_size is not None:
+        G.latent_size = G.mapping_fmaps = G.dlatent_size = latent_size
+        desc += '-latent{}'.format(latent_size)
+
+    if gamma is not None:
+        loss_args.gamma = gamma
+        desc += '-gamma{}'.format(gamma)
+    if DiffAugment:
+        loss_args.policy = DiffAugment
+        desc += '-' + DiffAugment.replace(',', '-')
+
+    sc.submit_target = dnnlib.SubmitTarget.LOCAL
+    sc.local.do_not_copy_source_files = True
+    kwargs = EasyDict(train)
+    kwargs.update(G_args=G, D_args=D, G_opt_args=G_opt, D_opt_args=D_opt, loss_args=loss_args)
+    kwargs.update(dataset_args=dataset_args, sched_args=sched, grid_args=grid, metric_arg_list=metrics, tf_config=tf_config)
+    kwargs.update(resume_pkl=resume, resume_kimg=resume_kimg, resume_with_new_nets=True)
+    kwargs.update(metric_args=metric_args)
+    if ema_kimg is not None:
+        kwargs.update(G_ema_kimg=ema_kimg)
+    kwargs.submit_config = copy.deepcopy(sc)
+    kwargs.submit_config.run_dir_root = result_dir
+    kwargs.submit_config.run_desc = desc
+    dnnlib.submit_run(**kwargs)
+
+# ----------------------------------------------------------------------------
+
+
+def run_eval(dataset, resolution, num_gpus, metrics, resume, num_repeats, **kwargs):
+    print('Evaluating metrics "%s" for "%s"...' % (','.join(metrics), resume))
+    tflib.init_tf()
+    dataset_args = dnnlib.EasyDict(tfrecord_dir=dataset, shuffle_mb=0)
+    metric_group = metric_base.MetricGroup([metric_defaults[metric] for metric in metrics], num_repeats=num_repeats)
+    metric_group.run(resume, dataset_args=dataset_args, num_gpus=num_gpus)
+
+# ----------------------------------------------------------------------------
+
+
+def _str_to_bool(v):
+    if isinstance(v, bool):
+        return v
+    if v.lower() in ('yes', 'true', 't', 'y', '1'):
+        return True
+    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
+        return False
+    else:
+        raise argparse.ArgumentTypeError('Boolean value expected.')
+
+
+def _parse_comma_sep(s):
+    if s is None or s.lower() == 'none' or s == '':
+        return []
+    return s.split(',')
+
+# ----------------------------------------------------------------------------
+
+
+def main():
+    parser = argparse.ArgumentParser(
+        description='Train StyleGAN2 + DiffAugment.',
+        formatter_class=argparse.RawDescriptionHelpFormatter
+    )
+    parser.add_argument('--dataset', help='Training dataset', default='cifar10')
+    parser.add_argument('--resolution', help='Specifies resolution', default=None, type=int)
+    parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
+    parser.add_argument('--DiffAugment', help='Comma-separated list of DiffAugment policy', default='color,cutout')
+    parser.add_argument('--num-gpus', help='Number of GPUs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--batch-size', help='Batch size', default=None, type=int, metavar='N')
+    parser.add_argument('--total-kimg', help='Training length in thousands of images (default: %(default)s)', metavar='KIMG', default=25000, type=int)
+    parser.add_argument('--ema-kimg', help='Half-life of exponential moving average in thousands of images', metavar='KIMG', default=1000, type=int)
+    parser.add_argument('--num-samples', help='Number of samples', default=None, type=int)
+    parser.add_argument('--gamma', help='R1 regularization weight', default=0.1, type=float)
+    parser.add_argument('--fmap-base', help='Number of feature maps', default=2048, type=int)
+    parser.add_argument('--fmap-max', help='Maximum number of feature maps', default=None, type=int)
+    parser.add_argument('--latent-size', help='Latent size', default=None, type=int)
+    parser.add_argument('--mirror-augment', help='Mirror augment (default: %(default)s)', default=True, metavar='BOOL', type=_str_to_bool)
+    parser.add_argument('--impl', help='Custom op implementation (default: %(default)s)', default='cuda')
+    parser.add_argument('--metrics', help='Comma-separated list of metrics or "none" (default: %(default)s)', default='fid10k,is10k', type=_parse_comma_sep)
+    parser.add_argument('--resume', help='Resume checkpoint path', default=None)
+    parser.add_argument('--resume-kimg', help='Resume training length', default=0, type=int)
+    parser.add_argument('--num-repeats', help='Repeats of evaluation runs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--eval', help='Evalulate mode?', action='store_true')
+
+    args = parser.parse_args()
+
+    for metric in args.metrics:
+        if metric not in metric_defaults:
+            print('Error: unknown metric \'%s\'' % metric)
+            sys.exit(1)
+
+    if args.eval:
+        run_eval(**vars(args))
+    else:
+        run(**vars(args))
+
+# ----------------------------------------------------------------------------
+
+
+if __name__ == "__main__":
+    main()
+
+# ----------------------------------------------------------------------------
diff --git a/run_ffhq.py b/run_ffhq.py
new file mode 100644
index 0000000..572e725
--- /dev/null
+++ b/run_ffhq.py
@@ -0,0 +1,173 @@
+# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
+#
+# This work is made available under the Nvidia Source Code License-NC.
+# To view a copy of this license, visit
+# https://nvlabs.github.io/stylegan2/license.html
+
+import argparse
+import copy
+import os
+import sys
+
+import dnnlib
+from dnnlib import tflib
+from dnnlib import EasyDict
+
+from metrics import metric_base
+from metrics.metric_defaults import metric_defaults
+from training import dataset_tool
+from training import misc
+
+# ----------------------------------------------------------------------------
+
+
+def run(dataset, resolution, result_dir, DiffAugment, num_gpus, batch_size, total_kimg, ema_kimg, num_samples, gamma, fmap_base, fmap_max, latent_size, mirror_augment, impl, metrics, resume, resume_kimg, num_repeats, eval):
+    train = EasyDict(run_func_name='training.training_loop.training_loop')  # Options for training loop.
+    G = EasyDict(func_name='training.networks_stylegan2.G_main')       # Options for generator network.
+    D = EasyDict(func_name='training.networks_stylegan2.D_stylegan2')  # Options for discriminator network.
+    G_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for generator optimizer.
+    D_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for discriminator optimizer.
+    loss_args = EasyDict(func_name='training.loss.ns_r1_DiffAugment')          # Options for loss.
+    sched = EasyDict()                                                     # Options for TrainingSchedule.
+    grid = EasyDict(size='4k', layout='random')                           # Options for setup_snapshot_image_grid().
+    sc = dnnlib.SubmitConfig()                                          # Options for dnnlib.submit_run().
+    tf_config = {'rnd.np_random_seed': 1000}                                   # Options for tflib.init_tf().
+
+    # preprocess dataset into tfrecords if necessary
+    dataset = dataset_tool.create_dataset(dataset, resolution)
+
+    train.total_kimg = total_kimg
+    train.mirror_augment = mirror_augment
+    metrics = [metric_defaults[x] for x in metrics]
+    metric_args = EasyDict(cache_dir=dataset, num_repeats=num_repeats)
+
+    desc = 'DiffAugment-stylegan2' if DiffAugment else 'stylegan2'
+    dataset_args = EasyDict(tfrecord_dir=dataset, resolution=resolution, from_tfrecords=True)
+    desc += '-' + os.path.basename(dataset)
+    if resolution is not None:
+        desc += '-{}'.format(resolution)
+
+    if num_samples is not None:
+        dataset_args.num_samples = num_samples
+        desc += '-{}samples'.format(num_samples)
+
+    if batch_size is not None:
+        desc += '-batch{}'.format(batch_size)
+    else:
+        batch_size = 32
+    assert batch_size % num_gpus == 0
+    sc.num_gpus = num_gpus
+    desc += '-%dgpu' % num_gpus
+    sched.minibatch_size_base = batch_size
+    sched.minibatch_gpu_base = batch_size // num_gpus
+
+    G.impl = D.impl = impl
+    if fmap_base is not None:
+        G.fmap_base = D.fmap_base = fmap_base
+        desc += '-fmap{}'.format(fmap_base)
+    if fmap_max is not None:
+        G.fmap_max = D.fmap_max = fmap_max
+        desc += '-fmax{}'.format(fmap_max)
+    if latent_size is not None:
+        G.latent_size = G.mapping_fmaps = G.dlatent_size = latent_size
+        desc += '-latent{}'.format(latent_size)
+
+    if gamma is not None:
+        loss_args.gamma = gamma
+        desc += '-gamma{}'.format(gamma)
+    if DiffAugment:
+        loss_args.policy = DiffAugment
+        desc += '-' + DiffAugment.replace(',', '-')
+
+    sc.submit_target = dnnlib.SubmitTarget.LOCAL
+    sc.local.do_not_copy_source_files = True
+    kwargs = EasyDict(train)
+    kwargs.update(G_args=G, D_args=D, G_opt_args=G_opt, D_opt_args=D_opt, loss_args=loss_args)
+    kwargs.update(dataset_args=dataset_args, sched_args=sched, grid_args=grid, metric_arg_list=metrics, tf_config=tf_config)
+    kwargs.update(resume_pkl=resume, resume_kimg=resume_kimg, resume_with_new_nets=True)
+    kwargs.update(metric_args=metric_args)
+    if ema_kimg is not None:
+        kwargs.update(G_ema_kimg=ema_kimg)
+    kwargs.submit_config = copy.deepcopy(sc)
+    kwargs.submit_config.run_dir_root = result_dir
+    kwargs.submit_config.run_desc = desc
+    dnnlib.submit_run(**kwargs)
+
+# ----------------------------------------------------------------------------
+
+
+def run_eval(dataset, resolution, num_gpus, metrics, resume, num_repeats, **kwargs):
+    dataset = dataset_tool.create_dataset(dataset, resolution)
+    print('Evaluating metrics "%s" for "%s"...' % (','.join(metrics), resume))
+    tflib.init_tf()
+    dataset_args = dnnlib.EasyDict(tfrecord_dir=dataset, shuffle_mb=0, from_tfrecords=True)
+    metric_group = metric_base.MetricGroup([metric_defaults[metric] for metric in metrics], num_repeats=num_repeats)
+    metric_group.run(resume, dataset_args=dataset_args, num_gpus=num_gpus)
+
+# ----------------------------------------------------------------------------
+
+
+def _str_to_bool(v):
+    if isinstance(v, bool):
+        return v
+    if v.lower() in ('yes', 'true', 't', 'y', '1'):
+        return True
+    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
+        return False
+    else:
+        raise argparse.ArgumentTypeError('Boolean value expected.')
+
+
+def _parse_comma_sep(s):
+    if s is None or s.lower() == 'none' or s == '':
+        return []
+    return s.split(',')
+
+# ----------------------------------------------------------------------------
+
+
+def main():
+    parser = argparse.ArgumentParser(
+        description='Train StyleGAN2 + DiffAugment.',
+        formatter_class=argparse.RawDescriptionHelpFormatter
+    )
+    parser.add_argument('--dataset', help='Training dataset directory', required=True)
+    parser.add_argument('--resolution', help='Specifies resolution', default=None, type=int)
+    parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
+    parser.add_argument('--DiffAugment', help='Comma-separated list of DiffAugment policy', default='color,translation,cutout')
+    parser.add_argument('--num-gpus', help='Number of GPUs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--batch-size', help='Batch size', default=None, type=int, metavar='N')
+    parser.add_argument('--total-kimg', help='Training length in thousands of images (default: %(default)s)', metavar='KIMG', default=25000, type=int)
+    parser.add_argument('--ema-kimg', help='Half-life of exponential moving average in thousands of images', metavar='KIMG', default=None, type=int)
+    parser.add_argument('--num-samples', help='Number of samples', default=None, type=int)
+    parser.add_argument('--gamma', help='R1 regularization weight', default=1, type=float)
+    parser.add_argument('--fmap-base', help='Number of feature maps', default=8192, type=int)
+    parser.add_argument('--fmap-max', help='Maximum number of feature maps', default=None, type=int)
+    parser.add_argument('--latent-size', help='Latent size', default=None, type=int)
+    parser.add_argument('--mirror-augment', help='Mirror augment (default: %(default)s)', default=True, metavar='BOOL', type=_str_to_bool)
+    parser.add_argument('--impl', help='Custom op implementation (default: %(default)s)', default='cuda')
+    parser.add_argument('--metrics', help='Comma-separated list of metrics or "none" (default: %(default)s)', default='fid50k-train', type=_parse_comma_sep)
+    parser.add_argument('--resume', help='Resume checkpoint path', default=None)
+    parser.add_argument('--resume-kimg', help='Resume training length', default=0, type=int)
+    parser.add_argument('--num-repeats', help='Repeats of evaluation runs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--eval', help='Evalulate mode?', action='store_true')
+
+    args = parser.parse_args()
+
+    for metric in args.metrics:
+        if metric not in metric_defaults:
+            print('Error: unknown metric \'%s\'' % metric)
+            sys.exit(1)
+
+    if args.eval:
+        run_eval(**vars(args))
+    else:
+        run(**vars(args))
+
+# ----------------------------------------------------------------------------
+
+
+if __name__ == "__main__":
+    main()
+
+# ----------------------------------------------------------------------------
diff --git a/run_generator.py b/run_generator.py
deleted file mode 100755
index 339796c..0000000
--- a/run_generator.py
+++ /dev/null
@@ -1,170 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-import argparse
-import numpy as np
-import PIL.Image
-import dnnlib
-import dnnlib.tflib as tflib
-import re
-import sys
-
-import pretrained_networks
-
-#----------------------------------------------------------------------------
-
-def generate_images(network_pkl, seeds, truncation_psi):
-    print('Loading networks from "%s"...' % network_pkl)
-    _G, _D, Gs = pretrained_networks.load_networks(network_pkl)
-    noise_vars = [var for name, var in Gs.components.synthesis.vars.items() if name.startswith('noise')]
-
-    Gs_kwargs = dnnlib.EasyDict()
-    Gs_kwargs.output_transform = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=True)
-    Gs_kwargs.randomize_noise = False
-    if truncation_psi is not None:
-        Gs_kwargs.truncation_psi = truncation_psi
-
-    for seed_idx, seed in enumerate(seeds):
-        print('Generating image for seed %d (%d/%d) ...' % (seed, seed_idx, len(seeds)))
-        rnd = np.random.RandomState(seed)
-        z = rnd.randn(1, *Gs.input_shape[1:]) # [minibatch, component]
-        tflib.set_vars({var: rnd.randn(*var.shape.as_list()) for var in noise_vars}) # [height, width]
-        images = Gs.run(z, None, **Gs_kwargs) # [minibatch, height, width, channel]
-        PIL.Image.fromarray(images[0], 'RGB').save(dnnlib.make_run_dir_path('seed%04d.png' % seed))
-
-#----------------------------------------------------------------------------
-
-def style_mixing_example(network_pkl, row_seeds, col_seeds, truncation_psi, col_styles, minibatch_size=4):
-    print('Loading networks from "%s"...' % network_pkl)
-    _G, _D, Gs = pretrained_networks.load_networks(network_pkl)
-    w_avg = Gs.get_var('dlatent_avg') # [component]
-
-    Gs_syn_kwargs = dnnlib.EasyDict()
-    Gs_syn_kwargs.output_transform = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=True)
-    Gs_syn_kwargs.randomize_noise = False
-    Gs_syn_kwargs.minibatch_size = minibatch_size
-
-    print('Generating W vectors...')
-    all_seeds = list(set(row_seeds + col_seeds))
-    all_z = np.stack([np.random.RandomState(seed).randn(*Gs.input_shape[1:]) for seed in all_seeds]) # [minibatch, component]
-    all_w = Gs.components.mapping.run(all_z, None) # [minibatch, layer, component]
-    all_w = w_avg + (all_w - w_avg) * truncation_psi # [minibatch, layer, component]
-    w_dict = {seed: w for seed, w in zip(all_seeds, list(all_w))} # [layer, component]
-
-    print('Generating images...')
-    all_images = Gs.components.synthesis.run(all_w, **Gs_syn_kwargs) # [minibatch, height, width, channel]
-    image_dict = {(seed, seed): image for seed, image in zip(all_seeds, list(all_images))}
-
-    print('Generating style-mixed images...')
-    for row_seed in row_seeds:
-        for col_seed in col_seeds:
-            w = w_dict[row_seed].copy()
-            w[col_styles] = w_dict[col_seed][col_styles]
-            image = Gs.components.synthesis.run(w[np.newaxis], **Gs_syn_kwargs)[0]
-            image_dict[(row_seed, col_seed)] = image
-
-    print('Saving images...')
-    for (row_seed, col_seed), image in image_dict.items():
-        PIL.Image.fromarray(image, 'RGB').save(dnnlib.make_run_dir_path('%d-%d.png' % (row_seed, col_seed)))
-
-    print('Saving image grid...')
-    _N, _C, H, W = Gs.output_shape
-    canvas = PIL.Image.new('RGB', (W * (len(col_seeds) + 1), H * (len(row_seeds) + 1)), 'black')
-    for row_idx, row_seed in enumerate([None] + row_seeds):
-        for col_idx, col_seed in enumerate([None] + col_seeds):
-            if row_seed is None and col_seed is None:
-                continue
-            key = (row_seed, col_seed)
-            if row_seed is None:
-                key = (col_seed, col_seed)
-            if col_seed is None:
-                key = (row_seed, row_seed)
-            canvas.paste(PIL.Image.fromarray(image_dict[key], 'RGB'), (W * col_idx, H * row_idx))
-    canvas.save(dnnlib.make_run_dir_path('grid.png'))
-
-#----------------------------------------------------------------------------
-
-def _parse_num_range(s):
-    '''Accept either a comma separated list of numbers 'a,b,c' or a range 'a-c' and return as a list of ints.'''
-
-    range_re = re.compile(r'^(\d+)-(\d+)$')
-    m = range_re.match(s)
-    if m:
-        return list(range(int(m.group(1)), int(m.group(2))+1))
-    vals = s.split(',')
-    return [int(x) for x in vals]
-
-#----------------------------------------------------------------------------
-
-_examples = '''examples:
-
-  # Generate ffhq uncurated images (matches paper Figure 12)
-  python %(prog)s generate-images --network=gdrive:networks/stylegan2-ffhq-config-f.pkl --seeds=6600-6625 --truncation-psi=0.5
-
-  # Generate ffhq curated images (matches paper Figure 11)
-  python %(prog)s generate-images --network=gdrive:networks/stylegan2-ffhq-config-f.pkl --seeds=66,230,389,1518 --truncation-psi=1.0
-
-  # Generate uncurated car images (matches paper Figure 12)
-  python %(prog)s generate-images --network=gdrive:networks/stylegan2-car-config-f.pkl --seeds=6000-6025 --truncation-psi=0.5
-
-  # Generate style mixing example (matches style mixing video clip)
-  python %(prog)s style-mixing-example --network=gdrive:networks/stylegan2-ffhq-config-f.pkl --row-seeds=85,100,75,458,1500 --col-seeds=55,821,1789,293 --truncation-psi=1.0
-'''
-
-#----------------------------------------------------------------------------
-
-def main():
-    parser = argparse.ArgumentParser(
-        description='''StyleGAN2 generator.
-
-Run 'python %(prog)s <subcommand> --help' for subcommand help.''',
-        epilog=_examples,
-        formatter_class=argparse.RawDescriptionHelpFormatter
-    )
-
-    subparsers = parser.add_subparsers(help='Sub-commands', dest='command')
-
-    parser_generate_images = subparsers.add_parser('generate-images', help='Generate images')
-    parser_generate_images.add_argument('--network', help='Network pickle filename', dest='network_pkl', required=True)
-    parser_generate_images.add_argument('--seeds', type=_parse_num_range, help='List of random seeds', required=True)
-    parser_generate_images.add_argument('--truncation-psi', type=float, help='Truncation psi (default: %(default)s)', default=0.5)
-    parser_generate_images.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-
-    parser_style_mixing_example = subparsers.add_parser('style-mixing-example', help='Generate style mixing video')
-    parser_style_mixing_example.add_argument('--network', help='Network pickle filename', dest='network_pkl', required=True)
-    parser_style_mixing_example.add_argument('--row-seeds', type=_parse_num_range, help='Random seeds to use for image rows', required=True)
-    parser_style_mixing_example.add_argument('--col-seeds', type=_parse_num_range, help='Random seeds to use for image columns', required=True)
-    parser_style_mixing_example.add_argument('--col-styles', type=_parse_num_range, help='Style layer range (default: %(default)s)', default='0-6')
-    parser_style_mixing_example.add_argument('--truncation-psi', type=float, help='Truncation psi (default: %(default)s)', default=0.5)
-    parser_style_mixing_example.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-
-    args = parser.parse_args()
-    kwargs = vars(args)
-    subcmd = kwargs.pop('command')
-
-    if subcmd is None:
-        print ('Error: missing subcommand.  Re-run with --help for usage.')
-        sys.exit(1)
-
-    sc = dnnlib.SubmitConfig()
-    sc.num_gpus = 1
-    sc.submit_target = dnnlib.SubmitTarget.LOCAL
-    sc.local.do_not_copy_source_files = True
-    sc.run_dir_root = kwargs.pop('result_dir')
-    sc.run_desc = subcmd
-
-    func_name_map = {
-        'generate-images': 'run_generator.generate_images',
-        'style-mixing-example': 'run_generator.style_mixing_example'
-    }
-    dnnlib.submit_run(sc, func_name_map[subcmd], **kwargs)
-
-#----------------------------------------------------------------------------
-
-if __name__ == "__main__":
-    main()
-
-#----------------------------------------------------------------------------
diff --git a/run_low_shot.py b/run_low_shot.py
new file mode 100644
index 0000000..4d4d7ac
--- /dev/null
+++ b/run_low_shot.py
@@ -0,0 +1,173 @@
+# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
+#
+# This work is made available under the Nvidia Source Code License-NC.
+# To view a copy of this license, visit
+# https://nvlabs.github.io/stylegan2/license.html
+
+import argparse
+import copy
+import os
+import sys
+
+import dnnlib
+from dnnlib import tflib
+from dnnlib import EasyDict
+
+from metrics import metric_base
+from metrics.metric_defaults import metric_defaults
+from training import dataset_tool
+from training import misc
+
+# ----------------------------------------------------------------------------
+
+
+def run(dataset, resolution, result_dir, DiffAugment, num_gpus, batch_size, total_kimg, ema_kimg, num_samples, gamma, fmap_base, fmap_max, latent_size, mirror_augment, impl, metrics, resume, resume_kimg, num_repeats, eval):
+    train = EasyDict(run_func_name='training.training_loop.training_loop')  # Options for training loop.
+    G = EasyDict(func_name='training.networks_stylegan2.G_main')       # Options for generator network.
+    D = EasyDict(func_name='training.networks_stylegan2.D_stylegan2')  # Options for discriminator network.
+    G_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for generator optimizer.
+    D_opt = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for discriminator optimizer.
+    loss_args = EasyDict(func_name='training.loss.ns_DiffAugment_r1')          # Options for loss.
+    sched = EasyDict()                                                     # Options for TrainingSchedule.
+    grid = EasyDict(size='4k', layout='random')                           # Options for setup_snapshot_image_grid().
+    sc = dnnlib.SubmitConfig()                                          # Options for dnnlib.submit_run().
+    tf_config = {'rnd.np_random_seed': 1000}                                   # Options for tflib.init_tf().
+
+    # preprocess dataset into tfrecords
+    dataset = dataset_tool.create_dataset(dataset, resolution)
+
+    train.total_kimg = total_kimg
+    train.mirror_augment = mirror_augment
+    metrics = [metric_defaults[x] for x in metrics]
+    metric_args = EasyDict(cache_dir=dataset, num_repeats=num_repeats)
+
+    desc = 'DiffAugment-stylegan2' if DiffAugment else 'stylegan2'
+    dataset_args = EasyDict(tfrecord_dir=dataset, resolution=resolution, from_tfrecords=True)
+    desc += '-' + os.path.basename(dataset)
+    if resolution is not None:
+        desc += '-{}'.format(resolution)
+
+    if num_samples is not None:
+        dataset_args.num_samples = num_samples
+        desc += '-{}samples'.format(num_samples)
+
+    if batch_size is not None:
+        desc += '-batch{}'.format(batch_size)
+    else:
+        batch_size = 32
+    assert batch_size % num_gpus == 0
+    sc.num_gpus = num_gpus
+    desc += '-%dgpu' % num_gpus
+    sched.minibatch_size_base = batch_size
+    sched.minibatch_gpu_base = batch_size // num_gpus
+
+    G.impl = D.impl = impl
+    if fmap_base is not None:
+        G.fmap_base = D.fmap_base = fmap_base
+        desc += '-fmap{}'.format(fmap_base)
+    if fmap_max is not None:
+        G.fmap_max = D.fmap_max = fmap_max
+        desc += '-fmax{}'.format(fmap_max)
+    if latent_size is not None:
+        G.latent_size = G.mapping_fmaps = G.dlatent_size = latent_size
+        desc += '-latent{}'.format(latent_size)
+
+    if gamma is not None:
+        loss_args.gamma = gamma
+        desc += '-gamma{}'.format(gamma)
+    if DiffAugment:
+        loss_args.policy = DiffAugment
+        desc += '-' + DiffAugment.replace(',', '-')
+
+    sc.submit_target = dnnlib.SubmitTarget.LOCAL
+    sc.local.do_not_copy_source_files = True
+    kwargs = EasyDict(train)
+    kwargs.update(G_args=G, D_args=D, G_opt_args=G_opt, D_opt_args=D_opt, loss_args=loss_args)
+    kwargs.update(dataset_args=dataset_args, sched_args=sched, grid_args=grid, metric_arg_list=metrics, tf_config=tf_config)
+    kwargs.update(resume_pkl=resume, resume_kimg=resume_kimg, resume_with_new_nets=True)
+    kwargs.update(metric_args=metric_args)
+    if ema_kimg is not None:
+        kwargs.update(G_ema_kimg=ema_kimg)
+    kwargs.submit_config = copy.deepcopy(sc)
+    kwargs.submit_config.run_dir_root = result_dir
+    kwargs.submit_config.run_desc = desc
+    dnnlib.submit_run(**kwargs)
+
+# ----------------------------------------------------------------------------
+
+
+def run_eval(dataset, resolution, num_gpus, metrics, resume, num_repeats, **kwargs):
+    dataset = dataset_tool.create_dataset(dataset, resolution)
+    print('Evaluating metrics "%s" for "%s"...' % (','.join(metrics), resume))
+    tflib.init_tf()
+    dataset_args = dnnlib.EasyDict(tfrecord_dir=dataset, resolution=resolution, from_tfrecords=True)
+    metric_group = metric_base.MetricGroup([metric_defaults[metric] for metric in metrics], num_repeats=num_repeats)
+    metric_group.run(resume, dataset_args=dataset_args, num_gpus=num_gpus)
+
+# ----------------------------------------------------------------------------
+
+
+def _str_to_bool(v):
+    if isinstance(v, bool):
+        return v
+    if v.lower() in ('yes', 'true', 't', 'y', '1'):
+        return True
+    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
+        return False
+    else:
+        raise argparse.ArgumentTypeError('Boolean value expected.')
+
+
+def _parse_comma_sep(s):
+    if s is None or s.lower() == 'none' or s == '':
+        return []
+    return s.split(',')
+
+# ----------------------------------------------------------------------------
+
+
+def main():
+    parser = argparse.ArgumentParser(
+        description='Train StyleGAN2 + DiffAugment.',
+        formatter_class=argparse.RawDescriptionHelpFormatter
+    )
+    parser.add_argument('--dataset', help='Training dataset path', required=True)
+    parser.add_argument('--resolution', help='Specifies resolution', default=256, type=int)
+    parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
+    parser.add_argument('--DiffAugment', help='Comma-separated list of DiffAugment policy', default='color,translation,cutout')
+    parser.add_argument('--num-gpus', help='Number of GPUs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--batch-size', help='Batch size', default=16, type=int, metavar='N')
+    parser.add_argument('--total-kimg', help='Training length in thousands of images (default: %(default)s)', metavar='KIMG', default=300, type=int)
+    parser.add_argument('--ema-kimg', help='Half-life of exponential moving average in thousands of images', metavar='KIMG', default=None, type=int)
+    parser.add_argument('--num-samples', help='Number of samples', default=None, type=int)
+    parser.add_argument('--gamma', help='R1 regularization weight', default=None, type=float)
+    parser.add_argument('--fmap-base', help='Number of feature maps', default=None, type=int)
+    parser.add_argument('--fmap-max', help='Maximum number of feature maps', default=None, type=int)
+    parser.add_argument('--latent-size', help='Latent size', default=None, type=int)
+    parser.add_argument('--mirror-augment', help='Mirror augment (default: %(default)s)', default=True, metavar='BOOL', type=_str_to_bool)
+    parser.add_argument('--impl', help='Custom op implementation (default: %(default)s)', default='cuda')
+    parser.add_argument('--metrics', help='Comma-separated list of metrics or "none" (default: %(default)s)', default='fid5k-train', type=_parse_comma_sep)
+    parser.add_argument('--resume', help='Resume checkpoint path', default=None)
+    parser.add_argument('--resume-kimg', help='Resume training length', default=0, type=int)
+    parser.add_argument('--num-repeats', help='Repeats of evaluation runs (default: %(default)s)', default=1, type=int, metavar='N')
+    parser.add_argument('--eval', help='Evalulate mode?', action='store_true')
+
+    args = parser.parse_args()
+
+    for metric in args.metrics:
+        if metric not in metric_defaults:
+            print('Error: unknown metric \'%s\'' % metric)
+            sys.exit(1)
+
+    if args.eval:
+        run_eval(**vars(args))
+    else:
+        run(**vars(args))
+
+# ----------------------------------------------------------------------------
+
+
+if __name__ == "__main__":
+    main()
+
+# ----------------------------------------------------------------------------
diff --git a/run_metrics.py b/run_metrics.py
deleted file mode 100755
index 5043b10..0000000
--- a/run_metrics.py
+++ /dev/null
@@ -1,86 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-import argparse
-import os
-import sys
-
-import dnnlib
-import dnnlib.tflib as tflib
-
-import pretrained_networks
-from metrics import metric_base
-from metrics.metric_defaults import metric_defaults
-
-#----------------------------------------------------------------------------
-
-def run(network_pkl, metrics, dataset, data_dir, mirror_augment):
-    print('Evaluating metrics "%s" for "%s"...' % (','.join(metrics), network_pkl))
-    tflib.init_tf()
-    network_pkl = pretrained_networks.get_path_or_url(network_pkl)
-    dataset_args = dnnlib.EasyDict(tfrecord_dir=dataset, shuffle_mb=0)
-    num_gpus = dnnlib.submit_config.num_gpus
-    metric_group = metric_base.MetricGroup([metric_defaults[metric] for metric in metrics])
-    metric_group.run(network_pkl, data_dir=data_dir, dataset_args=dataset_args, mirror_augment=mirror_augment, num_gpus=num_gpus)
-
-#----------------------------------------------------------------------------
-
-def _str_to_bool(v):
-    if isinstance(v, bool):
-        return v
-    if v.lower() in ('yes', 'true', 't', 'y', '1'):
-        return True
-    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
-        return False
-    else:
-        raise argparse.ArgumentTypeError('Boolean value expected.')
-
-#----------------------------------------------------------------------------
-
-_examples = '''examples:
-
-  python %(prog)s --data-dir=~/datasets --network=gdrive:networks/stylegan2-ffhq-config-f.pkl --metrics=fid50k,ppl_wend --dataset=ffhq --mirror-augment=true
-
-valid metrics:
-
-  ''' + ', '.join(sorted([x for x in metric_defaults.keys()])) + '''
-'''
-
-def main():
-    parser = argparse.ArgumentParser(
-        description='Run StyleGAN2 metrics.',
-        epilog=_examples,
-        formatter_class=argparse.RawDescriptionHelpFormatter
-    )
-    parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-    parser.add_argument('--network', help='Network pickle filename', dest='network_pkl', required=True)
-    parser.add_argument('--metrics', help='Metrics to compute (default: %(default)s)', default='fid50k', type=lambda x: x.split(','))
-    parser.add_argument('--dataset', help='Training dataset', required=True)
-    parser.add_argument('--data-dir', help='Dataset root directory', required=True)
-    parser.add_argument('--mirror-augment', help='Mirror augment (default: %(default)s)', default=False, type=_str_to_bool, metavar='BOOL')
-    parser.add_argument('--num-gpus', help='Number of GPUs to use', type=int, default=1, metavar='N')
-
-    args = parser.parse_args()
-
-    if not os.path.exists(args.data_dir):
-        print ('Error: dataset root directory does not exist.')
-        sys.exit(1)
-
-    kwargs = vars(args)
-    sc = dnnlib.SubmitConfig()
-    sc.num_gpus = kwargs.pop('num_gpus')
-    sc.submit_target = dnnlib.SubmitTarget.LOCAL
-    sc.local.do_not_copy_source_files = True
-    sc.run_dir_root = kwargs.pop('result_dir')
-    sc.run_desc = 'run-metrics'
-    dnnlib.submit_run(sc, 'run_metrics.run', **kwargs)
-
-#----------------------------------------------------------------------------
-
-if __name__ == "__main__":
-    main()
-
-#----------------------------------------------------------------------------
diff --git a/run_projector.py b/run_projector.py
deleted file mode 100755
index 5fd89ed..0000000
--- a/run_projector.py
+++ /dev/null
@@ -1,148 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-import argparse
-import numpy as np
-import dnnlib
-import dnnlib.tflib as tflib
-import re
-import sys
-
-import projector
-import pretrained_networks
-from training import dataset
-from training import misc
-
-#----------------------------------------------------------------------------
-
-def project_image(proj, targets, png_prefix, num_snapshots):
-    snapshot_steps = set(proj.num_steps - np.linspace(0, proj.num_steps, num_snapshots, endpoint=False, dtype=int))
-    misc.save_image_grid(targets, png_prefix + 'target.png', drange=[-1,1])
-    proj.start(targets)
-    while proj.get_cur_step() < proj.num_steps:
-        print('\r%d / %d ... ' % (proj.get_cur_step(), proj.num_steps), end='', flush=True)
-        proj.step()
-        if proj.get_cur_step() in snapshot_steps:
-            misc.save_image_grid(proj.get_images(), png_prefix + 'step%04d.png' % proj.get_cur_step(), drange=[-1,1])
-    print('\r%-30s\r' % '', end='', flush=True)
-
-#----------------------------------------------------------------------------
-
-def project_generated_images(network_pkl, seeds, num_snapshots, truncation_psi):
-    print('Loading networks from "%s"...' % network_pkl)
-    _G, _D, Gs = pretrained_networks.load_networks(network_pkl)
-    proj = projector.Projector()
-    proj.set_network(Gs)
-    noise_vars = [var for name, var in Gs.components.synthesis.vars.items() if name.startswith('noise')]
-
-    Gs_kwargs = dnnlib.EasyDict()
-    Gs_kwargs.randomize_noise = False
-    Gs_kwargs.truncation_psi = truncation_psi
-
-    for seed_idx, seed in enumerate(seeds):
-        print('Projecting seed %d (%d/%d) ...' % (seed, seed_idx, len(seeds)))
-        rnd = np.random.RandomState(seed)
-        z = rnd.randn(1, *Gs.input_shape[1:])
-        tflib.set_vars({var: rnd.randn(*var.shape.as_list()) for var in noise_vars})
-        images = Gs.run(z, None, **Gs_kwargs)
-        project_image(proj, targets=images, png_prefix=dnnlib.make_run_dir_path('seed%04d-' % seed), num_snapshots=num_snapshots)
-
-#----------------------------------------------------------------------------
-
-def project_real_images(network_pkl, dataset_name, data_dir, num_images, num_snapshots):
-    print('Loading networks from "%s"...' % network_pkl)
-    _G, _D, Gs = pretrained_networks.load_networks(network_pkl)
-    proj = projector.Projector()
-    proj.set_network(Gs)
-
-    print('Loading images from "%s"...' % dataset_name)
-    dataset_obj = dataset.load_dataset(data_dir=data_dir, tfrecord_dir=dataset_name, max_label_size=0, repeat=False, shuffle_mb=0)
-    assert dataset_obj.shape == Gs.output_shape[1:]
-
-    for image_idx in range(num_images):
-        print('Projecting image %d/%d ...' % (image_idx, num_images))
-        images, _labels = dataset_obj.get_minibatch_np(1)
-        images = misc.adjust_dynamic_range(images, [0, 255], [-1, 1])
-        project_image(proj, targets=images, png_prefix=dnnlib.make_run_dir_path('image%04d-' % image_idx), num_snapshots=num_snapshots)
-
-#----------------------------------------------------------------------------
-
-def _parse_num_range(s):
-    '''Accept either a comma separated list of numbers 'a,b,c' or a range 'a-c' and return as a list of ints.'''
-
-    range_re = re.compile(r'^(\d+)-(\d+)$')
-    m = range_re.match(s)
-    if m:
-        return list(range(int(m.group(1)), int(m.group(2))+1))
-    vals = s.split(',')
-    return [int(x) for x in vals]
-
-#----------------------------------------------------------------------------
-
-_examples = '''examples:
-
-  # Project generated images
-  python %(prog)s project-generated-images --network=gdrive:networks/stylegan2-car-config-f.pkl --seeds=0,1,5
-
-  # Project real images
-  python %(prog)s project-real-images --network=gdrive:networks/stylegan2-car-config-f.pkl --dataset=car --data-dir=~/datasets
-
-'''
-
-#----------------------------------------------------------------------------
-
-def main():
-    parser = argparse.ArgumentParser(
-        description='''StyleGAN2 projector.
-
-Run 'python %(prog)s <subcommand> --help' for subcommand help.''',
-        epilog=_examples,
-        formatter_class=argparse.RawDescriptionHelpFormatter
-    )
-
-    subparsers = parser.add_subparsers(help='Sub-commands', dest='command')
-
-    project_generated_images_parser = subparsers.add_parser('project-generated-images', help='Project generated images')
-    project_generated_images_parser.add_argument('--network', help='Network pickle filename', dest='network_pkl', required=True)
-    project_generated_images_parser.add_argument('--seeds', type=_parse_num_range, help='List of random seeds', default=range(3))
-    project_generated_images_parser.add_argument('--num-snapshots', type=int, help='Number of snapshots (default: %(default)s)', default=5)
-    project_generated_images_parser.add_argument('--truncation-psi', type=float, help='Truncation psi (default: %(default)s)', default=1.0)
-    project_generated_images_parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-
-    project_real_images_parser = subparsers.add_parser('project-real-images', help='Project real images')
-    project_real_images_parser.add_argument('--network', help='Network pickle filename', dest='network_pkl', required=True)
-    project_real_images_parser.add_argument('--data-dir', help='Dataset root directory', required=True)
-    project_real_images_parser.add_argument('--dataset', help='Training dataset', dest='dataset_name', required=True)
-    project_real_images_parser.add_argument('--num-snapshots', type=int, help='Number of snapshots (default: %(default)s)', default=5)
-    project_real_images_parser.add_argument('--num-images', type=int, help='Number of images to project (default: %(default)s)', default=3)
-    project_real_images_parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-
-    args = parser.parse_args()
-    subcmd = args.command
-    if subcmd is None:
-        print ('Error: missing subcommand.  Re-run with --help for usage.')
-        sys.exit(1)
-
-    kwargs = vars(args)
-    sc = dnnlib.SubmitConfig()
-    sc.num_gpus = 1
-    sc.submit_target = dnnlib.SubmitTarget.LOCAL
-    sc.local.do_not_copy_source_files = True
-    sc.run_dir_root = kwargs.pop('result_dir')
-    sc.run_desc = kwargs.pop('command')
-
-    func_name_map = {
-        'project-generated-images': 'run_projector.project_generated_images',
-        'project-real-images': 'run_projector.project_real_images'
-    }
-    dnnlib.submit_run(sc, func_name_map[subcmd], **kwargs)
-
-#----------------------------------------------------------------------------
-
-if __name__ == "__main__":
-    main()
-
-#----------------------------------------------------------------------------
diff --git a/run_training.py b/run_training.py
deleted file mode 100755
index bc4c0a2..0000000
--- a/run_training.py
+++ /dev/null
@@ -1,195 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-import argparse
-import copy
-import os
-import sys
-
-import dnnlib
-from dnnlib import EasyDict
-
-from metrics.metric_defaults import metric_defaults
-
-#----------------------------------------------------------------------------
-
-_valid_configs = [
-    # Table 1
-    'config-a', # Baseline StyleGAN
-    'config-b', # + Weight demodulation
-    'config-c', # + Lazy regularization
-    'config-d', # + Path length regularization
-    'config-e', # + No growing, new G & D arch.
-    'config-f', # + Large networks (default)
-
-    # Table 2
-    'config-e-Gorig-Dorig',   'config-e-Gorig-Dresnet',   'config-e-Gorig-Dskip',
-    'config-e-Gresnet-Dorig', 'config-e-Gresnet-Dresnet', 'config-e-Gresnet-Dskip',
-    'config-e-Gskip-Dorig',   'config-e-Gskip-Dresnet',   'config-e-Gskip-Dskip',
-]
-
-#----------------------------------------------------------------------------
-
-def run(dataset, data_dir, result_dir, config_id, num_gpus, total_kimg, gamma, mirror_augment, metrics):
-    train     = EasyDict(run_func_name='training.training_loop.training_loop') # Options for training loop.
-    G         = EasyDict(func_name='training.networks_stylegan2.G_main')       # Options for generator network.
-    D         = EasyDict(func_name='training.networks_stylegan2.D_stylegan2')  # Options for discriminator network.
-    G_opt     = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for generator optimizer.
-    D_opt     = EasyDict(beta1=0.0, beta2=0.99, epsilon=1e-8)                  # Options for discriminator optimizer.
-    G_loss    = EasyDict(func_name='training.loss.G_logistic_ns_pathreg')      # Options for generator loss.
-    D_loss    = EasyDict(func_name='training.loss.D_logistic_r1')              # Options for discriminator loss.
-    sched     = EasyDict()                                                     # Options for TrainingSchedule.
-    grid      = EasyDict(size='8k', layout='random')                           # Options for setup_snapshot_image_grid().
-    sc        = dnnlib.SubmitConfig()                                          # Options for dnnlib.submit_run().
-    tf_config = {'rnd.np_random_seed': 1000}                                   # Options for tflib.init_tf().
-
-    train.data_dir = data_dir
-    train.total_kimg = total_kimg
-    train.mirror_augment = mirror_augment
-    train.image_snapshot_ticks = train.network_snapshot_ticks = 10
-    sched.G_lrate_base = sched.D_lrate_base = 0.002
-    sched.minibatch_size_base = 32
-    sched.minibatch_gpu_base = 4
-    D_loss.gamma = 10
-    metrics = [metric_defaults[x] for x in metrics]
-    desc = 'stylegan2'
-
-    desc += '-' + dataset
-    dataset_args = EasyDict(tfrecord_dir=dataset)
-
-    assert num_gpus in [1, 2, 4, 8]
-    sc.num_gpus = num_gpus
-    desc += '-%dgpu' % num_gpus
-
-    assert config_id in _valid_configs
-    desc += '-' + config_id
-
-    # Configs A-E: Shrink networks to match original StyleGAN.
-    if config_id != 'config-f':
-        G.fmap_base = D.fmap_base = 8 << 10
-
-    # Config E: Set gamma to 100 and override G & D architecture.
-    if config_id.startswith('config-e'):
-        D_loss.gamma = 100
-        if 'Gorig'   in config_id: G.architecture = 'orig'
-        if 'Gskip'   in config_id: G.architecture = 'skip' # (default)
-        if 'Gresnet' in config_id: G.architecture = 'resnet'
-        if 'Dorig'   in config_id: D.architecture = 'orig'
-        if 'Dskip'   in config_id: D.architecture = 'skip'
-        if 'Dresnet' in config_id: D.architecture = 'resnet' # (default)
-
-    # Configs A-D: Enable progressive growing and switch to networks that support it.
-    if config_id in ['config-a', 'config-b', 'config-c', 'config-d']:
-        sched.lod_initial_resolution = 8
-        sched.G_lrate_base = sched.D_lrate_base = 0.001
-        sched.G_lrate_dict = sched.D_lrate_dict = {128: 0.0015, 256: 0.002, 512: 0.003, 1024: 0.003}
-        sched.minibatch_size_base = 32 # (default)
-        sched.minibatch_size_dict = {8: 256, 16: 128, 32: 64, 64: 32}
-        sched.minibatch_gpu_base = 4 # (default)
-        sched.minibatch_gpu_dict = {8: 32, 16: 16, 32: 8, 64: 4}
-        G.synthesis_func = 'G_synthesis_stylegan_revised'
-        D.func_name = 'training.networks_stylegan2.D_stylegan'
-
-    # Configs A-C: Disable path length regularization.
-    if config_id in ['config-a', 'config-b', 'config-c']:
-        G_loss = EasyDict(func_name='training.loss.G_logistic_ns')
-
-    # Configs A-B: Disable lazy regularization.
-    if config_id in ['config-a', 'config-b']:
-        train.lazy_regularization = False
-
-    # Config A: Switch to original StyleGAN networks.
-    if config_id == 'config-a':
-        G = EasyDict(func_name='training.networks_stylegan.G_style')
-        D = EasyDict(func_name='training.networks_stylegan.D_basic')
-
-    if gamma is not None:
-        D_loss.gamma = gamma
-
-    sc.submit_target = dnnlib.SubmitTarget.LOCAL
-    sc.local.do_not_copy_source_files = True
-    kwargs = EasyDict(train)
-    kwargs.update(G_args=G, D_args=D, G_opt_args=G_opt, D_opt_args=D_opt, G_loss_args=G_loss, D_loss_args=D_loss)
-    kwargs.update(dataset_args=dataset_args, sched_args=sched, grid_args=grid, metric_arg_list=metrics, tf_config=tf_config)
-    kwargs.submit_config = copy.deepcopy(sc)
-    kwargs.submit_config.run_dir_root = result_dir
-    kwargs.submit_config.run_desc = desc
-    dnnlib.submit_run(**kwargs)
-
-#----------------------------------------------------------------------------
-
-def _str_to_bool(v):
-    if isinstance(v, bool):
-        return v
-    if v.lower() in ('yes', 'true', 't', 'y', '1'):
-        return True
-    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
-        return False
-    else:
-        raise argparse.ArgumentTypeError('Boolean value expected.')
-
-def _parse_comma_sep(s):
-    if s is None or s.lower() == 'none' or s == '':
-        return []
-    return s.split(',')
-
-#----------------------------------------------------------------------------
-
-_examples = '''examples:
-
-  # Train StyleGAN2 using the FFHQ dataset
-  python %(prog)s --num-gpus=8 --data-dir=~/datasets --config=config-f --dataset=ffhq --mirror-augment=true
-
-valid configs:
-
-  ''' + ', '.join(_valid_configs) + '''
-
-valid metrics:
-
-  ''' + ', '.join(sorted([x for x in metric_defaults.keys()])) + '''
-
-'''
-
-def main():
-    parser = argparse.ArgumentParser(
-        description='Train StyleGAN2.',
-        epilog=_examples,
-        formatter_class=argparse.RawDescriptionHelpFormatter
-    )
-    parser.add_argument('--result-dir', help='Root directory for run results (default: %(default)s)', default='results', metavar='DIR')
-    parser.add_argument('--data-dir', help='Dataset root directory', required=True)
-    parser.add_argument('--dataset', help='Training dataset', required=True)
-    parser.add_argument('--config', help='Training config (default: %(default)s)', default='config-f', required=True, dest='config_id', metavar='CONFIG')
-    parser.add_argument('--num-gpus', help='Number of GPUs (default: %(default)s)', default=1, type=int, metavar='N')
-    parser.add_argument('--total-kimg', help='Training length in thousands of images (default: %(default)s)', metavar='KIMG', default=25000, type=int)
-    parser.add_argument('--gamma', help='R1 regularization weight (default is config dependent)', default=None, type=float)
-    parser.add_argument('--mirror-augment', help='Mirror augment (default: %(default)s)', default=False, metavar='BOOL', type=_str_to_bool)
-    parser.add_argument('--metrics', help='Comma-separated list of metrics or "none" (default: %(default)s)', default='fid50k', type=_parse_comma_sep)
-
-    args = parser.parse_args()
-
-    if not os.path.exists(args.data_dir):
-        print ('Error: dataset root directory does not exist.')
-        sys.exit(1)
-
-    if args.config_id not in _valid_configs:
-        print ('Error: --config value must be one of: ', ', '.join(_valid_configs))
-        sys.exit(1)
-
-    for metric in args.metrics:
-        if metric not in metric_defaults:
-            print ('Error: unknown metric \'%s\'' % metric)
-            sys.exit(1)
-
-    run(**vars(args))
-
-#----------------------------------------------------------------------------
-
-if __name__ == "__main__":
-    main()
-
-#----------------------------------------------------------------------------
-
diff --git a/test_nvcc.cu b/test_nvcc.cu
deleted file mode 100755
index 8b48041..0000000
--- a/test_nvcc.cu
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-//
-// This work is made available under the Nvidia Source Code License-NC.
-// To view a copy of this license, visit
-// https://nvlabs.github.io/stylegan2/license.html
-
-#include <cstdio>
-
-void checkCudaError(cudaError_t err)
-{
-    if (err != cudaSuccess)
-    {
-        printf("%s: %s\n", cudaGetErrorName(err), cudaGetErrorString(err));
-        exit(1);
-    }
-}
-
-__global__ void cudaKernel(void)
-{
-    printf("GPU says hello.\n");
-}
-
-int main(void)
-{
-    printf("CPU says hello.\n");
-    checkCudaError(cudaLaunchKernel((void*)cudaKernel, 1, 1, NULL, 0, NULL));
-    checkCudaError(cudaDeviceSynchronize());
-    return 0;
-}
diff --git a/training/dataset.py b/training/dataset.py
index 2d10598..aa2b186 100755
--- a/training/dataset.py
+++ b/training/dataset.py
@@ -9,175 +9,232 @@
 import os
 import glob
 import numpy as np
+import functools
 import tensorflow as tf
+import tensorflow_datasets as tfds
 import dnnlib
 import dnnlib.tflib as tflib
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Dataset class that loads data from tfrecords files.
 
+
 class TFRecordDataset:
     def __init__(self,
-        tfrecord_dir,               # Directory containing a collection of tfrecords files.
-        resolution      = None,     # Dataset resolution, None = autodetect.
-        label_file      = None,     # Relative path of the labels file, None = autodetect.
-        max_label_size  = 0,        # 0 = no labels, 'full' = full labels, <int> = N first label components.
-        max_images      = None,     # Maximum number of images to use, None = use all images.
-        repeat          = True,     # Repeat dataset indefinitely?
-        shuffle_mb      = 4096,     # Shuffle data within specified window (megabytes), 0 = disable shuffling.
-        prefetch_mb     = 2048,     # Amount of data to prefetch (megabytes), 0 = disable prefetching.
-        buffer_mb       = 256,      # Read buffer size (megabytes).
-        num_threads     = 2):       # Number of concurrent threads.
-
-        self.tfrecord_dir       = tfrecord_dir
-        self.resolution         = None
-        self.resolution_log2    = None
-        self.shape              = []        # [channels, height, width]
-        self.dtype              = 'uint8'
-        self.dynamic_range      = [0, 255]
-        self.label_file         = label_file
-        self.label_size         = None      # components
-        self.label_dtype        = None
-        self._np_labels         = None
-        self._tf_minibatch_in   = None
-        self._tf_labels_var     = None
+                 tfrecord_dir,               # Directory containing a collection of tfrecords files.
+                 split='train',  # Dataset split, 'train' or 'test'
+                 from_tfrecords=False,    # Load from tfrecords or from tensorflow datasets
+                 tfds_data_dir=None,     # Directory from which tensorflow datasets load
+                 resolution=None,     # Dataset resolution, None = autodetect.
+                 label_file=None,     # Relative path of the labels file, None = autodetect.
+                 max_label_size=0,        # 0 = no labels, 'full' = full labels, <int> = N first label components.
+                 num_samples=None,     # Maximum number of images to use, None = use all images.
+                 num_val_images=None,     # Number of validation images split from the training set, None = use separate validation set.
+                 repeat=True,     # Repeat dataset indefinitely?
+                 shuffle_mb=4096,     # Shuffle data within specified window (megabytes), 0 = disable shuffling.
+                 prefetch_mb=2048,     # Amount of data to prefetch (megabytes), 0 = disable prefetching.
+                 buffer_mb=256,      # Read buffer size (megabytes).
+                 num_threads=2):       # Number of concurrent threads.
+
+        self.tfrecord_dir = tfrecord_dir
+        self.resolution = None
+        self.shape = []        # [channels, height, width]
+        self.dtype = 'uint8'
+        self.dynamic_range = [0, 255]
+        self.from_tfrecords = from_tfrecords
+        self.label_file = label_file
+        self.label_size = None      # components
+        self.label_dtype = None
+        self.num_samples = num_samples
+        self._np_labels = None
+        self._tf_minibatch_in = None
+        self._tf_labels_var = None
         self._tf_labels_dataset = None
-        self._tf_datasets       = dict()
-        self._tf_iterator       = None
-        self._tf_init_ops       = dict()
-        self._tf_minibatch_np   = None
-        self._cur_minibatch     = -1
-        self._cur_lod           = -1
+        self._tf_dataset = None
+        self._tf_iterator = None
+        self._tf_init_op = None
+        self._tf_minibatch_np = None
+        self._cur_minibatch = -1
 
         # List tfrecords files and inspect their shapes.
-        assert os.path.isdir(self.tfrecord_dir)
-        tfr_files = sorted(glob.glob(os.path.join(self.tfrecord_dir, '*.tfrecords')))
-        assert len(tfr_files) >= 1
-        tfr_shapes = []
-        for tfr_file in tfr_files:
-            tfr_opt = tf.python_io.TFRecordOptions(tf.python_io.TFRecordCompressionType.NONE)
-            for record in tf.python_io.tf_record_iterator(tfr_file, tfr_opt):
-                tfr_shapes.append(self.parse_tfrecord_np(record).shape)
-                break
-
-        # Autodetect label filename.
-        if self.label_file is None:
-            guess = sorted(glob.glob(os.path.join(self.tfrecord_dir, '*.labels')))
-            if len(guess):
-                self.label_file = guess[0]
-        elif not os.path.isfile(self.label_file):
-            guess = os.path.join(self.tfrecord_dir, self.label_file)
-            if os.path.isfile(guess):
-                self.label_file = guess
-
-        # Determine shape and resolution.
-        max_shape = max(tfr_shapes, key=np.prod)
-        self.resolution = resolution if resolution is not None else max_shape[1]
-        self.resolution_log2 = int(np.log2(self.resolution))
-        self.shape = [max_shape[0], self.resolution, self.resolution]
-        tfr_lods = [self.resolution_log2 - int(np.log2(shape[1])) for shape in tfr_shapes]
-        assert all(shape[0] == max_shape[0] for shape in tfr_shapes)
-        assert all(shape[1] == shape[2] for shape in tfr_shapes)
-        assert all(shape[1] == self.resolution // (2**lod) for shape, lod in zip(tfr_shapes, tfr_lods))
-        assert all(lod in tfr_lods for lod in range(self.resolution_log2 - 1))
-
-        # Load labels.
-        assert max_label_size == 'full' or max_label_size >= 0
-        self._np_labels = np.zeros([1<<30, 0], dtype=np.float32)
-        if self.label_file is not None and max_label_size != 0:
-            self._np_labels = np.load(self.label_file)
-            assert self._np_labels.ndim == 2
-        if max_label_size != 'full' and self._np_labels.shape[1] > max_label_size:
-            self._np_labels = self._np_labels[:, :max_label_size]
-        if max_images is not None and self._np_labels.shape[0] > max_images:
-            self._np_labels = self._np_labels[:max_images]
-        self.label_size = self._np_labels.shape[1]
-        self.label_dtype = self._np_labels.dtype.name
+        if self.from_tfrecords:
+            self.name = os.path.basename(self.tfrecord_dir)
+            if resolution is not None:
+                self.name += '-{}'.format(resolution)
+            data_dir = self.tfrecord_dir + '-val' if num_val_images is None and split == 'test' else self.tfrecord_dir
+            tfr_files = sorted(glob.glob(os.path.join(data_dir, '*.tfrecords')))
+            assert len(tfr_files) >= 1
+            tfr_shapes = []
+            for tfr_file in tfr_files:
+                tfr_opt = tf.python_io.TFRecordOptions(tf.python_io.TFRecordCompressionType.NONE)
+                for record in tf.python_io.tf_record_iterator(tfr_file, tfr_opt):
+                    tfr_shapes.append(self.parse_tfrecord_np(record).shape)
+                    break
+
+            # Autodetect label filename.
+            if self.label_file is None:
+                guess = sorted(glob.glob(os.path.join(data_dir, '*.labels')))
+                if len(guess):
+                    self.label_file = guess[0]
+            elif not os.path.isfile(self.label_file):
+                guess = os.path.join(data_dir, self.label_file)
+                if os.path.isfile(guess):
+                    self.label_file = guess
+
+            # Determine shape and resolution.
+            target_shape = max(tfr_shapes, key=np.prod)
+            if resolution is not None:
+                for tfr_shape, tfr_file in zip(tfr_shapes, tfr_files):
+                    if max(tfr_shape[1], tfr_shape[2]) == resolution:
+                        target_shape = tfr_shape
+            tfr_file = [tfr_file for tfr_shape, tfr_file in zip(tfr_shapes, tfr_files) if tfr_shape == target_shape][0]
+            tfr_shape = target_shape
+            assert tfr_shape[1] == tfr_shape[2]
+
+            dset = tf.data.TFRecordDataset(tfr_file, compression_type='', buffer_size=buffer_mb << 20)
+
+            self._np_labels = np.zeros([1 << 25], dtype=np.int32)
+            if self.label_file is not None and max_label_size != 0:
+                self._np_labels = np.load(self.label_file).astype(np.int32)
+                self.label_size = self._np_labels.max() + 1
+                assert self._np_labels.ndim == 1
+                assert np.unique(self._np_labels).shape[0] == self.label_size
+            else:
+                self.label_size = 0
+
+            if num_val_images is not None:
+                if split == 'test':
+                    dset = dset.take(num_val_images)
+                    self._np_labels = self._np_labels[:num_val_images]
+                else:
+                    dset = dset.skip(num_val_images)
+                    self._np_labels = self._np_labels[num_val_images:]
+            if self.num_samples is not None and self._np_labels.shape[0] > self.num_samples:
+                self._np_labels = self._np_labels[:self.num_samples]
+            self.num_samples = self._np_labels.shape[0]
+        else:
+            self.name = self.tfrecord_dir
+            dset, info = tfds.load(name=self.name, data_dir=tfds_data_dir, split=split, with_info=True)
+            if max_label_size != 0:
+                self.label_size = info.features['label'].num_classes
+            else:
+                self.label_size = 0
+            if self.num_samples is None:
+                self.num_samples = info.splits[split].num_examples
+            tfr_shape = [int(tf.compat.v1.data.get_output_shapes(dset)['image'][d]) for d in [2, 0, 1]]
+
+        self.resolution = max(tfr_shape[1], tfr_shape[2])
+        if resolution is not None and resolution != self.resolution:
+            self.resolution = resolution
+            resize = True
+        else:
+            resize = False
+        self.resolution_log2 = int(np.ceil(np.log2(self.resolution)))
+        self.shape = [tfr_shape[0], self.resolution, self.resolution]
 
         # Build TF expressions.
         with tf.name_scope('Dataset'), tf.device('/cpu:0'):
             self._tf_minibatch_in = tf.placeholder(tf.int64, name='minibatch_in', shape=[])
-            self._tf_labels_var = tflib.create_var_with_large_initial_value(self._np_labels, name='labels_var')
-            self._tf_labels_dataset = tf.data.Dataset.from_tensor_slices(self._tf_labels_var)
-            for tfr_file, tfr_shape, tfr_lod in zip(tfr_files, tfr_shapes, tfr_lods):
-                if tfr_lod < 0:
-                    continue
-                dset = tf.data.TFRecordDataset(tfr_file, compression_type='', buffer_size=buffer_mb<<20)
-                if max_images is not None:
-                    dset = dset.take(max_images)
-                dset = dset.map(self.parse_tfrecord_tf, num_parallel_calls=num_threads)
+            if num_samples is not None:
+                dset = dset.take(self.num_samples)
+            if self.from_tfrecords:
+                dset = dset.map(functools.partial(self.parse_tfrecord_tf, resize=resize), num_parallel_calls=num_threads)
+                self._tf_labels_var = tflib.create_var_with_large_initial_value(self._np_labels, name='labels_var')
+                self._tf_labels_dataset = tf.data.Dataset.from_tensor_slices(self._tf_labels_var)
                 dset = tf.data.Dataset.zip((dset, self._tf_labels_dataset))
-                bytes_per_item = np.prod(tfr_shape) * np.dtype(self.dtype).itemsize
-                if shuffle_mb > 0:
-                    dset = dset.shuffle(((shuffle_mb << 20) - 1) // bytes_per_item + 1)
-                if repeat:
-                    dset = dset.repeat()
-                if prefetch_mb > 0:
-                    dset = dset.prefetch(((prefetch_mb << 20) - 1) // bytes_per_item + 1)
-                dset = dset.batch(self._tf_minibatch_in)
-                self._tf_datasets[tfr_lod] = dset
-            self._tf_iterator = tf.data.Iterator.from_structure(self._tf_datasets[0].output_types, self._tf_datasets[0].output_shapes)
-            self._tf_init_ops = {lod: self._tf_iterator.make_initializer(dset) for lod, dset in self._tf_datasets.items()}
+            else:
+                dset = dset.map(functools.partial(self.parse_tfdataset_tf, resize=resize), num_parallel_calls=num_threads)
+            bytes_per_item = np.prod(tfr_shape) * np.dtype(self.dtype).itemsize
+            if shuffle_mb > 0:
+                dset = dset.shuffle(((shuffle_mb << 20) - 1) // bytes_per_item + 1)
+            if repeat:
+                dset = dset.repeat()
+            if prefetch_mb > 0:
+                dset = dset.prefetch(((prefetch_mb << 20) - 1) // bytes_per_item + 1)
+            dset = dset.batch(self._tf_minibatch_in)
+            self._tf_dataset = dset
+
+            self._tf_iterator = tf.data.Iterator.from_structure(
+                tf.compat.v1.data.get_output_types(self._tf_dataset),
+                tf.compat.v1.data.get_output_shapes(self._tf_dataset),
+            )
+            self._tf_init_op = self._tf_iterator.make_initializer(self._tf_dataset)
 
     def close(self):
         pass
 
     # Use the given minibatch size and level-of-detail for the data returned by get_minibatch_tf().
-    def configure(self, minibatch_size, lod=0):
-        lod = int(np.floor(lod))
-        assert minibatch_size >= 1 and lod in self._tf_datasets
-        if self._cur_minibatch != minibatch_size or self._cur_lod != lod:
-            self._tf_init_ops[lod].run({self._tf_minibatch_in: minibatch_size})
+    def configure(self, minibatch_size):
+        assert minibatch_size >= 1
+        if self._cur_minibatch != minibatch_size:
+            self._tf_init_op.run({self._tf_minibatch_in: minibatch_size})
             self._cur_minibatch = minibatch_size
-            self._cur_lod = lod
 
     # Get next minibatch as TensorFlow expressions.
-    def get_minibatch_tf(self): # => images, labels
+    def get_minibatch_tf(self):  # => images, labels
         return self._tf_iterator.get_next()
 
     # Get next minibatch as NumPy arrays.
-    def get_minibatch_np(self, minibatch_size, lod=0): # => images, labels
-        self.configure(minibatch_size, lod)
+    def get_minibatch_np(self, minibatch_size):  # => images, labels
+        self.configure(minibatch_size)
         with tf.name_scope('Dataset'):
             if self._tf_minibatch_np is None:
                 self._tf_minibatch_np = self.get_minibatch_tf()
             return tflib.run(self._tf_minibatch_np)
 
-    # Get random labels as TensorFlow expression.
-    def get_random_labels_tf(self, minibatch_size): # => labels
+    def get_random_labels_tf(self, minibatch_size):  # => labels
         with tf.name_scope('Dataset'):
             if self.label_size > 0:
-                with tf.device('/cpu:0'):
-                    return tf.gather(self._tf_labels_var, tf.random_uniform([minibatch_size], 0, self._np_labels.shape[0], dtype=tf.int32))
-            return tf.zeros([minibatch_size, 0], self.label_dtype)
+                if self.from_tfrecords:
+                    with tf.device('/cpu:0'):
+                        return tf.gather(self._tf_labels_var, tf.random_uniform([minibatch_size], 0, self.num_samples, dtype=tf.int32))
+                else:
+                    return tf.random.uniform([minibatch_size], maxval=self.label_size, dtype=tf.int32)
+            return tf.zeros([minibatch_size], dtype=tf.int32)
 
     # Get random labels as NumPy array.
-    def get_random_labels_np(self, minibatch_size): # => labels
+    def get_random_labels_np(self, minibatch_size):  # => labels
         if self.label_size > 0:
-            return self._np_labels[np.random.randint(self._np_labels.shape[0], size=[minibatch_size])]
-        return np.zeros([minibatch_size, 0], self.label_dtype)
+            if self.from_tfrecords:
+                return self._np_labels[np.random.randint(self.num_samples, size=[minibatch_size])]
+            else:
+                return np.random.randint(self.label_size, size=[minibatch_size])
+        return np.zeros([minibatch_size], dtype=tf.int32)
 
     # Parse individual image from a tfrecords file into TensorFlow expression.
-    @staticmethod
-    def parse_tfrecord_tf(record):
+    def parse_tfrecord_tf(self, record, resize=False):
         features = tf.parse_single_example(record, features={
             'shape': tf.FixedLenFeature([3], tf.int64),
             'data': tf.FixedLenFeature([], tf.string)})
         data = tf.decode_raw(features['data'], tf.uint8)
-        return tf.reshape(data, features['shape'])
+        data = tf.reshape(data, features['shape'])
+        if resize:
+            image = tf.transpose(data, [1, 2, 0])
+            image = tf.image.resize(image, self.shape[1:])
+            data = tf.transpose(image, [2, 0, 1])
+        data.set_shape(self.shape)
+        return data
+
+    def parse_tfdataset_tf(self, record, resize=False):
+        image, label = record['image'], tf.cast(record['label'], tf.int32)
+        if resize:
+            image = tf.image.resize(image, self.shape[1:])
+        image = tf.transpose(image, [2, 0, 1])
+        return image, label
 
     # Parse individual image from a tfrecords file into NumPy array.
     @staticmethod
     def parse_tfrecord_np(record):
         ex = tf.train.Example()
         ex.ParseFromString(record)
-        shape = ex.features.feature['shape'].int64_list.value # pylint: disable=no-member
-        data = ex.features.feature['data'].bytes_list.value[0] # pylint: disable=no-member
+        shape = ex.features.feature['shape'].int64_list.value  # pylint: disable=no-member
+        data = ex.features.feature['data'].bytes_list.value[0]  # pylint: disable=no-member
         return np.fromstring(data, np.uint8).reshape(shape)
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Helper func for constructing a dataset object using the given options.
 
+
 def load_dataset(class_name=None, data_dir=None, verbose=False, **kwargs):
     kwargs = dict(kwargs)
     if 'tfrecord_dir' in kwargs:
@@ -196,4 +253,4 @@ def load_dataset(class_name=None, data_dir=None, verbose=False, **kwargs):
         print('Label size    =', dataset.label_size)
     return dataset
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
diff --git a/training/dataset_tool.py b/training/dataset_tool.py
new file mode 100644
index 0000000..10e09b4
--- /dev/null
+++ b/training/dataset_tool.py
@@ -0,0 +1,216 @@
+# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
+#
+# This work is made available under the Nvidia Source Code License-NC.
+# To view a copy of this license, visit
+# https://nvlabs.github.io/stylegan2/license.html
+
+"""Tool for creating multi-resolution TFRecords datasets."""
+
+# pylint: disable=too-many-lines
+import os
+import sys
+import zipfile
+import glob
+import numpy as np
+import tensorflow as tf
+import PIL.Image
+import dnnlib
+
+# ----------------------------------------------------------------------------
+
+
+def error(msg):
+    print('Error: ' + msg)
+    exit(1)
+
+# ----------------------------------------------------------------------------
+
+
+class TFRecordExporter:
+    def __init__(self, tfrecord_dir, expected_images, resolution=None, print_progress=True, progress_interval=10):
+        self.tfrecord_dir = tfrecord_dir
+        self.tfr_prefix = os.path.join(self.tfrecord_dir, os.path.basename(self.tfrecord_dir))
+        if resolution:
+            self.tfr_prefix += '-{}'.format(resolution)
+        self.expected_images = expected_images
+        self.cur_images = 0
+        self.shape = None
+        self.resolution_log2 = None
+        self.tfr_writers = []
+        self.print_progress = print_progress
+        self.progress_interval = progress_interval
+
+        if self.print_progress:
+            print('Creating dataset "%s"' % tfrecord_dir)
+        if not os.path.isdir(self.tfrecord_dir):
+            os.makedirs(self.tfrecord_dir)
+        assert os.path.isdir(self.tfrecord_dir)
+
+    def close(self):
+        if self.print_progress:
+            print('%-40s\r' % 'Flushing data...', end='', flush=True)
+        for tfr_writer in self.tfr_writers:
+            tfr_writer.close()
+        self.tfr_writers = []
+        if self.print_progress:
+            print('%-40s\r' % '', end='', flush=True)
+            print('Added %d images.' % self.cur_images)
+
+    def choose_shuffled_order(self):  # Note: Images and labels must be added in shuffled order.
+        order = np.arange(self.expected_images)
+        np.random.RandomState(123).shuffle(order)
+        return order
+
+    def set_shape(self, shape):
+        self.shape = shape
+        self.resolution_log2 = int(np.log2(self.shape[1]))
+        # assert self.shape[0] in [1, 3]
+        assert self.shape[1] == self.shape[2]
+        assert self.shape[1] == 2**self.resolution_log2
+        tfr_opt = tf.python_io.TFRecordOptions(tf.python_io.TFRecordCompressionType.NONE)
+        tfr_file = self.tfr_prefix + '.tfrecords'
+        self.tfr_writers.append(tf.python_io.TFRecordWriter(tfr_file, tfr_opt))
+
+    def add_image(self, img):
+        if self.print_progress and self.cur_images % self.progress_interval == 0:
+            print('%d / %d\r' % (self.cur_images, self.expected_images), end='', flush=True)
+        if self.shape is None:
+            self.set_shape(img.shape)
+        assert img.shape == self.shape
+        for lod, tfr_writer in enumerate(self.tfr_writers):
+            if lod:
+                img = img.astype(np.float32)
+                img = (img[:, 0::2, 0::2] + img[:, 0::2, 1::2] + img[:, 1::2, 0::2] + img[:, 1::2, 1::2]) * 0.25
+            quant = np.rint(img).clip(0, 255).astype(np.uint8)
+            ex = tf.train.Example(features=tf.train.Features(feature={
+                'shape': tf.train.Feature(int64_list=tf.train.Int64List(value=quant.shape)),
+                'data': tf.train.Feature(bytes_list=tf.train.BytesList(value=[quant.tostring()]))}))
+            tfr_writer.write(ex.SerializeToString())
+        self.cur_images += 1
+
+    def add_labels(self, labels):
+        if self.print_progress:
+            print('%-40s\r' % 'Saving labels...', end='', flush=True)
+        assert labels.shape[0] == self.cur_images
+        with open(self.tfr_prefix + '-rxx.labels', 'wb') as f:
+            np.save(f, labels.astype(np.int32))
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, *args):
+        self.close()
+
+# ----------------------------------------------------------------------------
+
+def unzip_from_url(data_dir, dataset_url):
+    zip_path = dnnlib.util.open_url(dataset_url, cache_dir='.stylegan2-cache', return_path=True)
+    with zipfile.ZipFile(zip_path, 'r') as f:
+        f.extractall(data_dir)
+
+
+def create_from_lmdb(data_dir, resolution=None, tfrecord_dir=None, max_images=None):
+    if tfrecord_dir is None:
+        tfrecord_dir = data_dir
+    print('Loading LMDB dataset from "%s"' % data_dir)
+    import lmdb # pip install lmdb # pylint: disable=import-error
+    import cv2 # pip install opencv-python
+    import io
+    with lmdb.open(data_dir, readonly=True).begin(write=False) as txn:
+        total_images = txn.stat()['entries'] # pylint: disable=no-value-for-parameter
+        if max_images is None:
+            max_images = total_images
+        with TFRecordExporter(tfrecord_dir, max_images, resolution) as tfr:
+            for _idx, (_key, value) in enumerate(txn.cursor()):
+                try:
+                    try:
+                        img = cv2.imdecode(np.fromstring(value, dtype=np.uint8), 1)
+                        if img is None:
+                            raise IOError('cv2.imdecode failed')
+                        img = img[:, :, ::-1] # BGR => RGB
+                    except IOError:
+                        img = np.asarray(PIL.Image.open(io.BytesIO(value)))
+                    crop = np.min(img.shape[:2])
+                    img = img[(img.shape[0] - crop) // 2 : (img.shape[0] + crop) // 2, (img.shape[1] - crop) // 2 : (img.shape[1] + crop) // 2]
+                    img = PIL.Image.fromarray(img, 'RGB')
+                    img = img.resize((resolution, resolution), PIL.Image.ANTIALIAS)
+                    img = np.asarray(img)
+                    img = img.transpose([2, 0, 1]) # HWC => CHW
+                    tfr.add_image(img)
+                except:
+                    print(sys.exc_info()[1])
+                if tfr.cur_images == max_images:
+                    break
+    return tfrecord_dir
+
+
+def create_from_images(data_dir, resolution=None, tfrecord_dir=None, shuffle=True):
+    if tfrecord_dir is None:
+        tfrecord_dir = data_dir
+    print('Loading images from "%s"' % data_dir)
+    image_filenames = sorted(glob.glob(os.path.join(data_dir, '*')))
+    image_filenames = [fname for fname in image_filenames if fname.split('.')[-1].lower() in ['jpg', 'jpeg', 'png', 'bmp']]
+    if len(image_filenames) == 0:
+        error('No input images found')
+
+    img = np.asarray(PIL.Image.open(image_filenames[0]))
+    if resolution is None:
+        resolution = img.shape[0]
+        if img.shape[1] != resolution:
+            error('Input images must have the same width and height')
+    if resolution != 2 ** int(np.floor(np.log2(resolution))):
+        error('Input image resolution must be a power-of-two')
+    channels = img.shape[2] if img.ndim == 3 else 1
+    if channels not in [1, 3]:
+        error('Input images must be stored as RGB or grayscale')
+
+    with TFRecordExporter(tfrecord_dir, len(image_filenames), resolution) as tfr:
+        order = tfr.choose_shuffled_order() if shuffle else np.arange(len(image_filenames))
+        for idx in range(order.size):
+            img = PIL.Image.open(image_filenames[order[idx]])
+            if resolution is not None:
+                img = img.resize((resolution, resolution), PIL.Image.ANTIALIAS)
+            img = np.asarray(img)
+            if channels == 1 or len(img.shape) == 2:
+                img = np.stack([img] * channels)  # HW => CHW
+            else:
+                img = img.transpose([2, 0, 1])  # HWC => CHW
+            tfr.add_image(img)
+    return tfrecord_dir
+
+
+def create_dataset(dataset, resolution=None):
+    if dataset in predefined_datasets:
+        data_dir = 'datasets/{}'.format(dataset)
+        try:
+            os.makedirs(data_dir)
+        except:
+            pass
+    else:
+        data_dir = dataset
+    assert os.path.isdir(data_dir)
+    
+    if glob.glob(os.path.join(data_dir, '*{}.tfrecords'.format('-{}'.format(resolution) if resolution else ''))):
+        return data_dir
+    
+    if glob.glob(os.path.join(data_dir, '*.mdb')):
+        return create_from_lmdb(data_dir, resolution)
+    
+    if dataset in predefined_datasets:
+        unzip_from_url(data_dir, 'https://hanlab.mit.edu/projects/data-efficient-gans/datasets/{}.zip'.format(dataset))
+    return create_from_images(data_dir, resolution)
+
+
+predefined_datasets = [
+    '100-shot-obama',
+    '100-shot-grumpy_cat',
+    '100-shot-panda',
+    '100-shot-bridge_of_sighs',
+    '100-shot-medici_fountain',
+    '100-shot-temple_of_heaven',
+    '100-shot-wuzhen',
+    'AnimalFace-cat',
+    'AnimalFace-dog',
+]
+
+# ----------------------------------------------------------------------------
diff --git a/training/loss.py b/training/loss.py
index 7ad2fe1..342e4e2 100755
--- a/training/loss.py
+++ b/training/loss.py
@@ -6,192 +6,56 @@
 
 """Loss functions."""
 
-import numpy as np
 import tensorflow as tf
-import dnnlib.tflib as tflib
 from dnnlib.tflib.autosummary import autosummary
+from DiffAugment_tf import DiffAugment
 
-#----------------------------------------------------------------------------
-# Logistic loss from the paper
-# "Generative Adversarial Nets", Goodfellow et al. 2014
 
-def G_logistic(G, D, opt, training_set, minibatch_size):
-    _ = opt
+def ns_DiffAugment_r1(G, D, training_set, minibatch_size, reals, gamma=10, policy='', **kwargs):
     latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
     labels = training_set.get_random_labels_tf(minibatch_size)
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    loss = -tf.nn.softplus(fake_scores_out) # log(1-sigmoid(fake_scores_out)) # pylint: disable=invalid-unary-operand-type
-    return loss, None
+    fakes = G.get_output_for(latents, labels, is_training=True)
 
-def G_logistic_ns(G, D, opt, training_set, minibatch_size):
-    _ = opt
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    labels = training_set.get_random_labels_tf(minibatch_size)
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    loss = tf.nn.softplus(-fake_scores_out) # -log(sigmoid(fake_scores_out))
-    return loss, None
-
-def D_logistic(G, D, opt, training_set, minibatch_size, reals, labels):
-    _ = opt, training_set
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    real_scores_out = D.get_output_for(reals, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    real_scores_out = autosummary('Loss/scores/real', real_scores_out)
-    fake_scores_out = autosummary('Loss/scores/fake', fake_scores_out)
-    loss = tf.nn.softplus(fake_scores_out) # -log(1-sigmoid(fake_scores_out))
-    loss += tf.nn.softplus(-real_scores_out) # -log(sigmoid(real_scores_out)) # pylint: disable=invalid-unary-operand-type
-    return loss, None
+    real_scores = D.get_output_for(DiffAugment(reals, policy=policy, channels_first=True), is_training=True)
+    fake_scores = D.get_output_for(DiffAugment(fakes, policy=policy, channels_first=True), is_training=True)
+    real_scores = autosummary('Loss/scores/real', real_scores)
+    fake_scores = autosummary('Loss/scores/fake', fake_scores)
 
-#----------------------------------------------------------------------------
-# R1 and R2 regularizers from the paper
-# "Which Training Methods for GANs do actually Converge?", Mescheder et al. 2018
-
-def D_logistic_r1(G, D, opt, training_set, minibatch_size, reals, labels, gamma=10.0):
-    _ = opt, training_set
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    real_scores_out = D.get_output_for(reals, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    real_scores_out = autosummary('Loss/scores/real', real_scores_out)
-    fake_scores_out = autosummary('Loss/scores/fake', fake_scores_out)
-    loss = tf.nn.softplus(fake_scores_out) # -log(1-sigmoid(fake_scores_out))
-    loss += tf.nn.softplus(-real_scores_out) # -log(sigmoid(real_scores_out)) # pylint: disable=invalid-unary-operand-type
+    G_loss = tf.nn.softplus(-fake_scores)
+    G_loss = autosummary('Loss/G_loss', G_loss)
+    D_loss = tf.nn.softplus(fake_scores) + tf.nn.softplus(-real_scores)
+    D_loss = autosummary('Loss/D_loss', D_loss)
 
     with tf.name_scope('GradientPenalty'):
-        real_grads = tf.gradients(tf.reduce_sum(real_scores_out), [reals])[0]
-        gradient_penalty = tf.reduce_sum(tf.square(real_grads), axis=[1,2,3])
+        real_grads = tf.gradients(tf.reduce_sum(real_scores), [reals])[0]
+        gradient_penalty = tf.reduce_sum(tf.square(real_grads), axis=[1, 2, 3])
         gradient_penalty = autosummary('Loss/gradient_penalty', gradient_penalty)
-        reg = gradient_penalty * (gamma * 0.5)
-    return loss, reg
+        D_reg = gradient_penalty * (gamma * 0.5)
+    return G_loss, D_loss, D_reg
 
-def D_logistic_r2(G, D, opt, training_set, minibatch_size, reals, labels, gamma=10.0):
-    _ = opt, training_set
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    real_scores_out = D.get_output_for(reals, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    real_scores_out = autosummary('Loss/scores/real', real_scores_out)
-    fake_scores_out = autosummary('Loss/scores/fake', fake_scores_out)
-    loss = tf.nn.softplus(fake_scores_out) # -log(1-sigmoid(fake_scores_out))
-    loss += tf.nn.softplus(-real_scores_out) # -log(sigmoid(real_scores_out)) # pylint: disable=invalid-unary-operand-type
 
-    with tf.name_scope('GradientPenalty'):
-        fake_grads = tf.gradients(tf.reduce_sum(fake_scores_out), [fake_images_out])[0]
-        gradient_penalty = tf.reduce_sum(tf.square(fake_grads), axis=[1,2,3])
-        gradient_penalty = autosummary('Loss/gradient_penalty', gradient_penalty)
-        reg = gradient_penalty * (gamma * 0.5)
-    return loss, reg
-
-#----------------------------------------------------------------------------
-# WGAN loss from the paper
-# "Wasserstein Generative Adversarial Networks", Arjovsky et al. 2017
-
-def G_wgan(G, D, opt, training_set, minibatch_size):
-    _ = opt
+def ns_r1_DiffAugment(G, D, training_set, minibatch_size, reals, gamma=10, policy='', **kwargs):
     latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
     labels = training_set.get_random_labels_tf(minibatch_size)
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    loss = -fake_scores_out
-    return loss, None
-
-def D_wgan(G, D, opt, training_set, minibatch_size, reals, labels, wgan_epsilon=0.001):
-    _ = opt, training_set
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    real_scores_out = D.get_output_for(reals, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    real_scores_out = autosummary('Loss/scores/real', real_scores_out)
-    fake_scores_out = autosummary('Loss/scores/fake', fake_scores_out)
-    loss = fake_scores_out - real_scores_out
-    with tf.name_scope('EpsilonPenalty'):
-        epsilon_penalty = autosummary('Loss/epsilon_penalty', tf.square(real_scores_out))
-        loss += epsilon_penalty * wgan_epsilon
-    return loss, None
+    fakes = G.get_output_for(latents, labels, is_training=True)
 
-#----------------------------------------------------------------------------
-# WGAN-GP loss from the paper
-# "Improved Training of Wasserstein GANs", Gulrajani et al. 2017
+    reals = DiffAugment(reals, policy=policy, channels_first=True)
+    fakes = DiffAugment(fakes, policy=policy, channels_first=True)
+    real_scores = D.get_output_for(reals, is_training=True)
+    fake_scores = D.get_output_for(fakes, is_training=True)
+    real_scores = autosummary('Loss/scores/real', real_scores)
+    fake_scores = autosummary('Loss/scores/fake', fake_scores)
 
-def D_wgan_gp(G, D, opt, training_set, minibatch_size, reals, labels, wgan_lambda=10.0, wgan_epsilon=0.001, wgan_target=1.0):
-    _ = opt, training_set
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    fake_images_out = G.get_output_for(latents, labels, is_training=True)
-    real_scores_out = D.get_output_for(reals, labels, is_training=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    real_scores_out = autosummary('Loss/scores/real', real_scores_out)
-    fake_scores_out = autosummary('Loss/scores/fake', fake_scores_out)
-    loss = fake_scores_out - real_scores_out
-    with tf.name_scope('EpsilonPenalty'):
-        epsilon_penalty = autosummary('Loss/epsilon_penalty', tf.square(real_scores_out))
-    loss += epsilon_penalty * wgan_epsilon
+    G_loss = tf.nn.softplus(-fake_scores)
+    G_loss = autosummary('Loss/G_loss', G_loss)
+    D_loss = tf.nn.softplus(fake_scores) + tf.nn.softplus(-real_scores)
+    D_loss = autosummary('Loss/D_loss', D_loss)
 
     with tf.name_scope('GradientPenalty'):
-        mixing_factors = tf.random_uniform([minibatch_size, 1, 1, 1], 0.0, 1.0, dtype=fake_images_out.dtype)
-        mixed_images_out = tflib.lerp(tf.cast(reals, fake_images_out.dtype), fake_images_out, mixing_factors)
-        mixed_scores_out = D.get_output_for(mixed_images_out, labels, is_training=True)
-        mixed_scores_out = autosummary('Loss/scores/mixed', mixed_scores_out)
-        mixed_grads = tf.gradients(tf.reduce_sum(mixed_scores_out), [mixed_images_out])[0]
-        mixed_norms = tf.sqrt(tf.reduce_sum(tf.square(mixed_grads), axis=[1,2,3]))
-        mixed_norms = autosummary('Loss/mixed_norms', mixed_norms)
-        gradient_penalty = tf.square(mixed_norms - wgan_target)
-        reg = gradient_penalty * (wgan_lambda / (wgan_target**2))
-    return loss, reg
-
-#----------------------------------------------------------------------------
-# Non-saturating logistic loss with path length regularizer from the paper
-# "Analyzing and Improving the Image Quality of StyleGAN", Karras et al. 2019
-
-def G_logistic_ns_pathreg(G, D, opt, training_set, minibatch_size, pl_minibatch_shrink=2, pl_decay=0.01, pl_weight=2.0):
-    _ = opt
-    latents = tf.random_normal([minibatch_size] + G.input_shapes[0][1:])
-    labels = training_set.get_random_labels_tf(minibatch_size)
-    fake_images_out, fake_dlatents_out = G.get_output_for(latents, labels, is_training=True, return_dlatents=True)
-    fake_scores_out = D.get_output_for(fake_images_out, labels, is_training=True)
-    loss = tf.nn.softplus(-fake_scores_out) # -log(sigmoid(fake_scores_out))
-
-    # Path length regularization.
-    with tf.name_scope('PathReg'):
-
-        # Evaluate the regularization term using a smaller minibatch to conserve memory.
-        if pl_minibatch_shrink > 1:
-            pl_minibatch = minibatch_size // pl_minibatch_shrink
-            pl_latents = tf.random_normal([pl_minibatch] + G.input_shapes[0][1:])
-            pl_labels = training_set.get_random_labels_tf(pl_minibatch)
-            fake_images_out, fake_dlatents_out = G.get_output_for(pl_latents, pl_labels, is_training=True, return_dlatents=True)
-
-        # Compute |J*y|.
-        pl_noise = tf.random_normal(tf.shape(fake_images_out)) / np.sqrt(np.prod(G.output_shape[2:]))
-        pl_grads = tf.gradients(tf.reduce_sum(fake_images_out * pl_noise), [fake_dlatents_out])[0]
-        pl_lengths = tf.sqrt(tf.reduce_mean(tf.reduce_sum(tf.square(pl_grads), axis=2), axis=1))
-        pl_lengths = autosummary('Loss/pl_lengths', pl_lengths)
-
-        # Track exponential moving average of |J*y|.
-        with tf.control_dependencies(None):
-            pl_mean_var = tf.Variable(name='pl_mean', trainable=False, initial_value=0.0, dtype=tf.float32)
-        pl_mean = pl_mean_var + pl_decay * (tf.reduce_mean(pl_lengths) - pl_mean_var)
-        pl_update = tf.assign(pl_mean_var, pl_mean)
-
-        # Calculate (|J*y|-a)^2.
-        with tf.control_dependencies([pl_update]):
-            pl_penalty = tf.square(pl_lengths - pl_mean)
-            pl_penalty = autosummary('Loss/pl_penalty', pl_penalty)
-
-        # Apply weight.
-        #
-        # Note: The division in pl_noise decreases the weight by num_pixels, and the reduce_mean
-        # in pl_lengths decreases it by num_affine_layers. The effective weight then becomes:
-        #
-        # gamma_pl = pl_weight / num_pixels / num_affine_layers
-        # = 2 / (r^2) / (log2(r) * 2 - 2)
-        # = 1 / (r^2 * (log2(r) - 1))
-        # = ln(2) / (r^2 * (ln(r) - ln(2))
-        #
-        reg = pl_penalty * pl_weight
-
-    return loss, reg
+        real_grads = tf.gradients(tf.reduce_sum(real_scores), [reals])[0]
+        gradient_penalty = tf.reduce_sum(tf.square(real_grads), axis=[1, 2, 3])
+        gradient_penalty = autosummary('Loss/gradient_penalty', gradient_penalty)
+        D_reg = gradient_penalty * (gamma * 0.5)
+    return G_loss, D_loss, D_reg
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
diff --git a/training/misc.py b/training/misc.py
index 9b3444e..71902a1 100755
--- a/training/misc.py
+++ b/training/misc.py
@@ -13,26 +13,35 @@ import PIL.Image
 import PIL.ImageFont
 import dnnlib
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Convenience wrappers for pickle that are able to load data produced by
 # older versions of the code, and from external URLs.
 
+
 def open_file_or_url(file_or_url):
+    file_or_url = get_path_or_url(file_or_url)
     if dnnlib.util.is_url(file_or_url):
         return dnnlib.util.open_url(file_or_url, cache_dir='.stylegan2-cache')
     return open(file_or_url, 'rb')
 
+
 def load_pkl(file_or_url):
     with open_file_or_url(file_or_url) as file:
         return pickle.load(file, encoding='latin1')
 
+
 def save_pkl(obj, filename):
     with open(filename, 'wb') as file:
         pickle.dump(obj, file, protocol=pickle.HIGHEST_PROTOCOL)
 
-#----------------------------------------------------------------------------
+
+def get_path_or_url(path_or_url):
+    return path_or_url.replace('mit-han-lab:', 'https://hanlab.mit.edu/projects/data-efficient-gans/models/')
+
+# ----------------------------------------------------------------------------
 # Image utils.
 
+
 def adjust_dynamic_range(data, drange_in, drange_out):
     if drange_in != drange_out:
         scale = (np.float32(drange_out[1]) - np.float32(drange_out[0])) / (np.float32(drange_in[1]) - np.float32(drange_in[0]))
@@ -40,6 +49,7 @@ def adjust_dynamic_range(data, drange_in, drange_out):
         data = data * scale + bias
     return data
 
+
 def create_image_grid(images, grid_size=None):
     assert images.ndim == 3 or images.ndim == 4
     num, img_w, img_h = images.shape[0], images.shape[-1], images.shape[-2]
@@ -54,47 +64,52 @@ def create_image_grid(images, grid_size=None):
     for idx in range(num):
         x = (idx % grid_w) * img_w
         y = (idx // grid_w) * img_h
-        grid[..., y : y + img_h, x : x + img_w] = images[idx]
+        grid[..., y: y + img_h, x: x + img_w] = images[idx]
     return grid
 
-def convert_to_pil_image(image, drange=[0,1]):
+
+def convert_to_pil_image(image, drange=[0, 1]):
     assert image.ndim == 2 or image.ndim == 3
     if image.ndim == 3:
         if image.shape[0] == 1:
-            image = image[0] # grayscale CHW => HW
+            image = image[0]  # grayscale CHW => HW
         else:
-            image = image.transpose(1, 2, 0) # CHW -> HWC
+            image = image.transpose(1, 2, 0)  # CHW -> HWC
 
-    image = adjust_dynamic_range(image, drange, [0,255])
+    image = adjust_dynamic_range(image, drange, [0, 255])
     image = np.rint(image).clip(0, 255).astype(np.uint8)
     fmt = 'RGB' if image.ndim == 3 else 'L'
     return PIL.Image.fromarray(image, fmt)
 
-def save_image_grid(images, filename, drange=[0,1], grid_size=None):
+
+def save_image_grid(images, filename, drange=[0, 1], grid_size=None):
     convert_to_pil_image(create_image_grid(images, grid_size), drange).save(filename)
 
+
 def apply_mirror_augment(minibatch):
     mask = np.random.rand(minibatch.shape[0]) < 0.5
     minibatch = np.array(minibatch)
     minibatch[mask] = minibatch[mask, :, :, ::-1]
     return minibatch
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Loading data from previous training runs.
 
+
 def parse_config_for_previous_run(run_dir):
     with open(os.path.join(run_dir, 'submit_config.pkl'), 'rb') as f:
         data = pickle.load(f)
     data = data.get('run_func_kwargs', {})
     return dict(train=data, dataset=data.get('dataset_args', {}))
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Size and contents of the image snapshot grids that are exported
 # periodically during training.
 
+
 def setup_snapshot_image_grid(training_set,
-    size    = '1080p',      # '1080p' = to be viewed on 1080p display, '4k' = to be viewed on 4k display.
-    layout  = 'random'):    # 'random' = grid contents are selected randomly, 'row_per_class' = each row corresponds to one class label.
+                              size='1080p',      # '1080p' = to be viewed on 1080p display, '4k' = to be viewed on 4k display.
+                              layout='random'):    # 'random' = grid contents are selected randomly, 'row_per_class' = each row corresponds to one class label.
 
     # Select size.
     gw = 1; gh = 1
@@ -110,14 +125,14 @@ def setup_snapshot_image_grid(training_set,
 
     # Initialize data arrays.
     reals = np.zeros([gw * gh] + training_set.shape, dtype=training_set.dtype)
-    labels = np.zeros([gw * gh, training_set.label_size], dtype=training_set.label_dtype)
+    labels = np.zeros([gw * gh], dtype=np.int32)
 
     # Random layout.
     if layout == 'random':
         reals[:], labels[:] = training_set.get_minibatch_np(gw * gh)
 
     # Class-conditional layouts.
-    class_layouts = dict(row_per_class=[gw,1], col_per_class=[1,gh], class4x4=[4,4])
+    class_layouts = dict(row_per_class=[gw, 1], col_per_class=[1, gh], class4x4=[4, 4])
     if layout in class_layouts:
         bw, bh = class_layouts[layout]
         nw = (gw - 1) // bw + 1
@@ -125,7 +140,7 @@ def setup_snapshot_image_grid(training_set,
         blocks = [[] for _i in range(nw * nh)]
         for _iter in range(1000000):
             real, label = training_set.get_minibatch_np(1)
-            idx = np.argmax(label[0])
+            idx = label[0]
             while idx < len(blocks) and len(blocks[idx]) >= bw * bh:
                 idx += training_set.label_size
             if idx < len(blocks):
@@ -134,7 +149,7 @@ def setup_snapshot_image_grid(training_set,
                     break
         for i, block in enumerate(blocks):
             for j, (real, label) in enumerate(block):
-                x = (i %  nw) * bw + j %  bw
+                x = (i % nw) * bw + j % bw
                 y = (i // nw) * bh + j // bw
                 if x < gw and y < gh:
                     reals[x + y * gw] = real[0]
@@ -142,4 +157,4 @@ def setup_snapshot_image_grid(training_set,
 
     return (gw, gh), reals, labels
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
diff --git a/training/networks_stylegan.py b/training/networks_stylegan.py
deleted file mode 100755
index 76ce31c..0000000
--- a/training/networks_stylegan.py
+++ /dev/null
@@ -1,660 +0,0 @@
-# Copyright (c) 2019, NVIDIA Corporation. All rights reserved.
-#
-# This work is made available under the Nvidia Source Code License-NC.
-# To view a copy of this license, visit
-# https://nvlabs.github.io/stylegan2/license.html
-
-"""Network architectures used in the StyleGAN paper."""
-
-import numpy as np
-import tensorflow as tf
-import dnnlib
-import dnnlib.tflib as tflib
-
-# NOTE: Do not import any application-specific modules here!
-# Specify all network parameters as kwargs.
-
-#----------------------------------------------------------------------------
-# Primitive ops for manipulating 4D activation tensors.
-# The gradients of these are not necessary efficient or even meaningful.
-
-def _blur2d(x, f=[1,2,1], normalize=True, flip=False, stride=1):
-    assert x.shape.ndims == 4 and all(dim.value is not None for dim in x.shape[1:])
-    assert isinstance(stride, int) and stride >= 1
-
-    # Finalize filter kernel.
-    f = np.array(f, dtype=np.float32)
-    if f.ndim == 1:
-        f = f[:, np.newaxis] * f[np.newaxis, :]
-    assert f.ndim == 2
-    if normalize:
-        f /= np.sum(f)
-    if flip:
-        f = f[::-1, ::-1]
-    f = f[:, :, np.newaxis, np.newaxis]
-    f = np.tile(f, [1, 1, int(x.shape[1]), 1])
-
-    # No-op => early exit.
-    if f.shape == (1, 1) and f[0,0] == 1:
-        return x
-
-    # Convolve using depthwise_conv2d.
-    orig_dtype = x.dtype
-    x = tf.cast(x, tf.float32)  # tf.nn.depthwise_conv2d() doesn't support fp16
-    f = tf.constant(f, dtype=x.dtype, name='filter')
-    strides = [1, 1, stride, stride]
-    x = tf.nn.depthwise_conv2d(x, f, strides=strides, padding='SAME', data_format='NCHW')
-    x = tf.cast(x, orig_dtype)
-    return x
-
-def _upscale2d(x, factor=2, gain=1):
-    assert x.shape.ndims == 4 and all(dim.value is not None for dim in x.shape[1:])
-    assert isinstance(factor, int) and factor >= 1
-
-    # Apply gain.
-    if gain != 1:
-        x *= gain
-
-    # No-op => early exit.
-    if factor == 1:
-        return x
-
-    # Upscale using tf.tile().
-    s = x.shape
-    x = tf.reshape(x, [-1, s[1], s[2], 1, s[3], 1])
-    x = tf.tile(x, [1, 1, 1, factor, 1, factor])
-    x = tf.reshape(x, [-1, s[1], s[2] * factor, s[3] * factor])
-    return x
-
-def _downscale2d(x, factor=2, gain=1):
-    assert x.shape.ndims == 4 and all(dim.value is not None for dim in x.shape[1:])
-    assert isinstance(factor, int) and factor >= 1
-
-    # 2x2, float32 => downscale using _blur2d().
-    if factor == 2 and x.dtype == tf.float32:
-        f = [np.sqrt(gain) / factor] * factor
-        return _blur2d(x, f=f, normalize=False, stride=factor)
-
-    # Apply gain.
-    if gain != 1:
-        x *= gain
-
-    # No-op => early exit.
-    if factor == 1:
-        return x
-
-    # Large factor => downscale using tf.nn.avg_pool().
-    # NOTE: Requires tf_config['graph_options.place_pruned_graph']=True to work.
-    ksize = [1, 1, factor, factor]
-    return tf.nn.avg_pool(x, ksize=ksize, strides=ksize, padding='VALID', data_format='NCHW')
-
-#----------------------------------------------------------------------------
-# High-level ops for manipulating 4D activation tensors.
-# The gradients of these are meant to be as efficient as possible.
-
-def blur2d(x, f=[1,2,1], normalize=True):
-    with tf.variable_scope('Blur2D'):
-        @tf.custom_gradient
-        def func(x):
-            y = _blur2d(x, f, normalize)
-            @tf.custom_gradient
-            def grad(dy):
-                dx = _blur2d(dy, f, normalize, flip=True)
-                return dx, lambda ddx: _blur2d(ddx, f, normalize)
-            return y, grad
-        return func(x)
-
-def upscale2d(x, factor=2):
-    with tf.variable_scope('Upscale2D'):
-        @tf.custom_gradient
-        def func(x):
-            y = _upscale2d(x, factor)
-            @tf.custom_gradient
-            def grad(dy):
-                dx = _downscale2d(dy, factor, gain=factor**2)
-                return dx, lambda ddx: _upscale2d(ddx, factor)
-            return y, grad
-        return func(x)
-
-def downscale2d(x, factor=2):
-    with tf.variable_scope('Downscale2D'):
-        @tf.custom_gradient
-        def func(x):
-            y = _downscale2d(x, factor)
-            @tf.custom_gradient
-            def grad(dy):
-                dx = _upscale2d(dy, factor, gain=1/factor**2)
-                return dx, lambda ddx: _downscale2d(ddx, factor)
-            return y, grad
-        return func(x)
-
-#----------------------------------------------------------------------------
-# Get/create weight tensor for a convolutional or fully-connected layer.
-
-def get_weight(shape, gain=np.sqrt(2), use_wscale=False, lrmul=1):
-    fan_in = np.prod(shape[:-1]) # [kernel, kernel, fmaps_in, fmaps_out] or [in, out]
-    he_std = gain / np.sqrt(fan_in) # He init
-
-    # Equalized learning rate and custom learning rate multiplier.
-    if use_wscale:
-        init_std = 1.0 / lrmul
-        runtime_coef = he_std * lrmul
-    else:
-        init_std = he_std / lrmul
-        runtime_coef = lrmul
-
-    # Create variable.
-    init = tf.initializers.random_normal(0, init_std)
-    return tf.get_variable('weight', shape=shape, initializer=init) * runtime_coef
-
-#----------------------------------------------------------------------------
-# Fully-connected layer.
-
-def dense(x, fmaps, **kwargs):
-    if len(x.shape) > 2:
-        x = tf.reshape(x, [-1, np.prod([d.value for d in x.shape[1:]])])
-    w = get_weight([x.shape[1].value, fmaps], **kwargs)
-    w = tf.cast(w, x.dtype)
-    return tf.matmul(x, w)
-
-#----------------------------------------------------------------------------
-# Convolutional layer.
-
-def conv2d(x, fmaps, kernel, **kwargs):
-    assert kernel >= 1 and kernel % 2 == 1
-    w = get_weight([kernel, kernel, x.shape[1].value, fmaps], **kwargs)
-    w = tf.cast(w, x.dtype)
-    return tf.nn.conv2d(x, w, strides=[1,1,1,1], padding='SAME', data_format='NCHW')
-
-#----------------------------------------------------------------------------
-# Fused convolution + scaling.
-# Faster and uses less memory than performing the operations separately.
-
-def upscale2d_conv2d(x, fmaps, kernel, fused_scale='auto', **kwargs):
-    assert kernel >= 1 and kernel % 2 == 1
-    assert fused_scale in [True, False, 'auto']
-    if fused_scale == 'auto':
-        fused_scale = min(x.shape[2:]) * 2 >= 128
-
-    # Not fused => call the individual ops directly.
-    if not fused_scale:
-        return conv2d(upscale2d(x), fmaps, kernel, **kwargs)
-
-    # Fused => perform both ops simultaneously using tf.nn.conv2d_transpose().
-    w = get_weight([kernel, kernel, x.shape[1].value, fmaps], **kwargs)
-    w = tf.transpose(w, [0, 1, 3, 2]) # [kernel, kernel, fmaps_out, fmaps_in]
-    w = tf.pad(w, [[1,1], [1,1], [0,0], [0,0]], mode='CONSTANT')
-    w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]])
-    w = tf.cast(w, x.dtype)
-    os = [tf.shape(x)[0], fmaps, x.shape[2] * 2, x.shape[3] * 2]
-    return tf.nn.conv2d_transpose(x, w, os, strides=[1,1,2,2], padding='SAME', data_format='NCHW')
-
-def conv2d_downscale2d(x, fmaps, kernel, fused_scale='auto', **kwargs):
-    assert kernel >= 1 and kernel % 2 == 1
-    assert fused_scale in [True, False, 'auto']
-    if fused_scale == 'auto':
-        fused_scale = min(x.shape[2:]) >= 128
-
-    # Not fused => call the individual ops directly.
-    if not fused_scale:
-        return downscale2d(conv2d(x, fmaps, kernel, **kwargs))
-
-    # Fused => perform both ops simultaneously using tf.nn.conv2d().
-    w = get_weight([kernel, kernel, x.shape[1].value, fmaps], **kwargs)
-    w = tf.pad(w, [[1,1], [1,1], [0,0], [0,0]], mode='CONSTANT')
-    w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]]) * 0.25
-    w = tf.cast(w, x.dtype)
-    return tf.nn.conv2d(x, w, strides=[1,1,2,2], padding='SAME', data_format='NCHW')
-
-#----------------------------------------------------------------------------
-# Apply bias to the given activation tensor.
-
-def apply_bias(x, lrmul=1):
-    b = tf.get_variable('bias', shape=[x.shape[1]], initializer=tf.initializers.zeros()) * lrmul
-    b = tf.cast(b, x.dtype)
-    if len(x.shape) == 2:
-        return x + b
-    return x + tf.reshape(b, [1, -1, 1, 1])
-
-#----------------------------------------------------------------------------
-# Leaky ReLU activation. More efficient than tf.nn.leaky_relu() and supports FP16.
-
-def leaky_relu(x, alpha=0.2):
-    with tf.variable_scope('LeakyReLU'):
-        alpha = tf.constant(alpha, dtype=x.dtype, name='alpha')
-        @tf.custom_gradient
-        def func(x):
-            y = tf.maximum(x, x * alpha)
-            @tf.custom_gradient
-            def grad(dy):
-                dx = tf.where(y >= 0, dy, dy * alpha)
-                return dx, lambda ddx: tf.where(y >= 0, ddx, ddx * alpha)
-            return y, grad
-        return func(x)
-
-#----------------------------------------------------------------------------
-# Pixelwise feature vector normalization.
-
-def pixel_norm(x, epsilon=1e-8):
-    with tf.variable_scope('PixelNorm'):
-        epsilon = tf.constant(epsilon, dtype=x.dtype, name='epsilon')
-        return x * tf.rsqrt(tf.reduce_mean(tf.square(x), axis=1, keepdims=True) + epsilon)
-
-#----------------------------------------------------------------------------
-# Instance normalization.
-
-def instance_norm(x, epsilon=1e-8):
-    assert len(x.shape) == 4 # NCHW
-    with tf.variable_scope('InstanceNorm'):
-        orig_dtype = x.dtype
-        x = tf.cast(x, tf.float32)
-        x -= tf.reduce_mean(x, axis=[2,3], keepdims=True)
-        epsilon = tf.constant(epsilon, dtype=x.dtype, name='epsilon')
-        x *= tf.rsqrt(tf.reduce_mean(tf.square(x), axis=[2,3], keepdims=True) + epsilon)
-        x = tf.cast(x, orig_dtype)
-        return x
-
-#----------------------------------------------------------------------------
-# Style modulation.
-
-def style_mod(x, dlatent, **kwargs):
-    with tf.variable_scope('StyleMod'):
-        style = apply_bias(dense(dlatent, fmaps=x.shape[1]*2, gain=1, **kwargs))
-        style = tf.reshape(style, [-1, 2, x.shape[1]] + [1] * (len(x.shape) - 2))
-        return x * (style[:,0] + 1) + style[:,1]
-
-#----------------------------------------------------------------------------
-# Noise input.
-
-def apply_noise(x, noise_var=None, randomize_noise=True):
-    assert len(x.shape) == 4 # NCHW
-    with tf.variable_scope('Noise'):
-        if noise_var is None or randomize_noise:
-            noise = tf.random_normal([tf.shape(x)[0], 1, x.shape[2], x.shape[3]], dtype=x.dtype)
-        else:
-            noise = tf.cast(noise_var, x.dtype)
-        weight = tf.get_variable('weight', shape=[x.shape[1].value], initializer=tf.initializers.zeros())
-        return x + noise * tf.reshape(tf.cast(weight, x.dtype), [1, -1, 1, 1])
-
-#----------------------------------------------------------------------------
-# Minibatch standard deviation.
-
-def minibatch_stddev_layer(x, group_size=4, num_new_features=1):
-    with tf.variable_scope('MinibatchStddev'):
-        group_size = tf.minimum(group_size, tf.shape(x)[0])     # Minibatch must be divisible by (or smaller than) group_size.
-        s = x.shape                                             # [NCHW]  Input shape.
-        y = tf.reshape(x, [group_size, -1, num_new_features, s[1]//num_new_features, s[2], s[3]])   # [GMncHW] Split minibatch into M groups of size G. Split channels into n channel groups c.
-        y = tf.cast(y, tf.float32)                              # [GMncHW] Cast to FP32.
-        y -= tf.reduce_mean(y, axis=0, keepdims=True)           # [GMncHW] Subtract mean over group.
-        y = tf.reduce_mean(tf.square(y), axis=0)                # [MncHW]  Calc variance over group.
-        y = tf.sqrt(y + 1e-8)                                   # [MncHW]  Calc stddev over group.
-        y = tf.reduce_mean(y, axis=[2,3,4], keepdims=True)      # [Mn111]  Take average over fmaps and pixels.
-        y = tf.reduce_mean(y, axis=[2])                         # [Mn11] Split channels into c channel groups
-        y = tf.cast(y, x.dtype)                                 # [Mn11]  Cast back to original data type.
-        y = tf.tile(y, [group_size, 1, s[2], s[3]])             # [NnHW]  Replicate over group and pixels.
-        return tf.concat([x, y], axis=1)                        # [NCHW]  Append as new fmap.
-
-#----------------------------------------------------------------------------
-# Style-based generator used in the StyleGAN paper.
-# Composed of two sub-networks (G_mapping and G_synthesis) that are defined below.
-
-def G_style(
-    latents_in,                                     # First input: Latent vectors (Z) [minibatch, latent_size].
-    labels_in,                                      # Second input: Conditioning labels [minibatch, label_size].
-    truncation_psi          = 0.7,                  # Style strength multiplier for the truncation trick. None = disable.
-    truncation_cutoff       = 8,                    # Number of layers for which to apply the truncation trick. None = disable.
-    truncation_psi_val      = None,                 # Value for truncation_psi to use during validation.
-    truncation_cutoff_val   = None,                 # Value for truncation_cutoff to use during validation.
-    dlatent_avg_beta        = 0.995,                # Decay for tracking the moving average of W during training. None = disable.
-    style_mixing_prob       = 0.9,                  # Probability of mixing styles during training. None = disable.
-    is_training             = False,                # Network is under training? Enables and disables specific features.
-    is_validation           = False,                # Network is under validation? Chooses which value to use for truncation_psi.
-    is_template_graph       = False,                # True = template graph constructed by the Network class, False = actual evaluation.
-    components              = dnnlib.EasyDict(),    # Container for sub-networks. Retained between calls.
-    **kwargs):                                      # Arguments for sub-networks (G_mapping and G_synthesis).
-
-    # Validate arguments.
-    assert not is_training or not is_validation
-    assert isinstance(components, dnnlib.EasyDict)
-    if is_validation:
-        truncation_psi = truncation_psi_val
-        truncation_cutoff = truncation_cutoff_val
-    if is_training or (truncation_psi is not None and not tflib.is_tf_expression(truncation_psi) and truncation_psi == 1):
-        truncation_psi = None
-    if is_training or (truncation_cutoff is not None and not tflib.is_tf_expression(truncation_cutoff) and truncation_cutoff <= 0):
-        truncation_cutoff = None
-    if not is_training or (dlatent_avg_beta is not None and not tflib.is_tf_expression(dlatent_avg_beta) and dlatent_avg_beta == 1):
-        dlatent_avg_beta = None
-    if not is_training or (style_mixing_prob is not None and not tflib.is_tf_expression(style_mixing_prob) and style_mixing_prob <= 0):
-        style_mixing_prob = None
-
-    # Setup components.
-    if 'synthesis' not in components:
-        components.synthesis = tflib.Network('G_synthesis', func_name=G_synthesis, **kwargs)
-    num_layers = components.synthesis.input_shape[1]
-    dlatent_size = components.synthesis.input_shape[2]
-    if 'mapping' not in components:
-        components.mapping = tflib.Network('G_mapping', func_name=G_mapping, dlatent_broadcast=num_layers, **kwargs)
-
-    # Setup variables.
-    lod_in = tf.get_variable('lod', initializer=np.float32(0), trainable=False)
-    dlatent_avg = tf.get_variable('dlatent_avg', shape=[dlatent_size], initializer=tf.initializers.zeros(), trainable=False)
-
-    # Evaluate mapping network.
-    dlatents = components.mapping.get_output_for(latents_in, labels_in, **kwargs)
-
-    # Update moving average of W.
-    if dlatent_avg_beta is not None:
-        with tf.variable_scope('DlatentAvg'):
-            batch_avg = tf.reduce_mean(dlatents[:, 0], axis=0)
-            update_op = tf.assign(dlatent_avg, tflib.lerp(batch_avg, dlatent_avg, dlatent_avg_beta))
-            with tf.control_dependencies([update_op]):
-                dlatents = tf.identity(dlatents)
-
-    # Perform style mixing regularization.
-    if style_mixing_prob is not None:
-        with tf.name_scope('StyleMix'):
-            latents2 = tf.random_normal(tf.shape(latents_in))
-            dlatents2 = components.mapping.get_output_for(latents2, labels_in, **kwargs)
-            layer_idx = np.arange(num_layers)[np.newaxis, :, np.newaxis]
-            cur_layers = num_layers - tf.cast(lod_in, tf.int32) * 2
-            mixing_cutoff = tf.cond(
-                tf.random_uniform([], 0.0, 1.0) < style_mixing_prob,
-                lambda: tf.random_uniform([], 1, cur_layers, dtype=tf.int32),
-                lambda: cur_layers)
-            dlatents = tf.where(tf.broadcast_to(layer_idx < mixing_cutoff, tf.shape(dlatents)), dlatents, dlatents2)
-
-    # Apply truncation trick.
-    if truncation_psi is not None and truncation_cutoff is not None:
-        with tf.variable_scope('Truncation'):
-            layer_idx = np.arange(num_layers)[np.newaxis, :, np.newaxis]
-            ones = np.ones(layer_idx.shape, dtype=np.float32)
-            coefs = tf.where(layer_idx < truncation_cutoff, truncation_psi * ones, ones)
-            dlatents = tflib.lerp(dlatent_avg, dlatents, coefs)
-
-    # Evaluate synthesis network.
-    with tf.control_dependencies([tf.assign(components.synthesis.find_var('lod'), lod_in)]):
-        images_out = components.synthesis.get_output_for(dlatents, force_clean_graph=is_template_graph, **kwargs)
-    return tf.identity(images_out, name='images_out')
-
-#----------------------------------------------------------------------------
-# Mapping network used in the StyleGAN paper.
-
-def G_mapping(
-    latents_in,                             # First input: Latent vectors (Z) [minibatch, latent_size].
-    labels_in,                              # Second input: Conditioning labels [minibatch, label_size].
-    latent_size             = 512,          # Latent vector (Z) dimensionality.
-    label_size              = 0,            # Label dimensionality, 0 if no labels.
-    dlatent_size            = 512,          # Disentangled latent (W) dimensionality.
-    dlatent_broadcast       = None,         # Output disentangled latent (W) as [minibatch, dlatent_size] or [minibatch, dlatent_broadcast, dlatent_size].
-    mapping_layers          = 8,            # Number of mapping layers.
-    mapping_fmaps           = 512,          # Number of activations in the mapping layers.
-    mapping_lrmul           = 0.01,         # Learning rate multiplier for the mapping layers.
-    mapping_nonlinearity    = 'lrelu',      # Activation function: 'relu', 'lrelu'.
-    use_wscale              = True,         # Enable equalized learning rate?
-    normalize_latents       = True,         # Normalize latent vectors (Z) before feeding them to the mapping layers?
-    dtype                   = 'float32',    # Data type to use for activations and outputs.
-    **_kwargs):                             # Ignore unrecognized keyword args.
-
-    act, gain = {'relu': (tf.nn.relu, np.sqrt(2)), 'lrelu': (leaky_relu, np.sqrt(2))}[mapping_nonlinearity]
-
-    # Inputs.
-    latents_in.set_shape([None, latent_size])
-    labels_in.set_shape([None, label_size])
-    latents_in = tf.cast(latents_in, dtype)
-    labels_in = tf.cast(labels_in, dtype)
-    x = latents_in
-
-    # Embed labels and concatenate them with latents.
-    if label_size:
-        with tf.variable_scope('LabelConcat'):
-            w = tf.get_variable('weight', shape=[label_size, latent_size], initializer=tf.initializers.random_normal())
-            y = tf.matmul(labels_in, tf.cast(w, dtype))
-            x = tf.concat([x, y], axis=1)
-
-    # Normalize latents.
-    if normalize_latents:
-        x = pixel_norm(x)
-
-    # Mapping layers.
-    for layer_idx in range(mapping_layers):
-        with tf.variable_scope('Dense%d' % layer_idx):
-            fmaps = dlatent_size if layer_idx == mapping_layers - 1 else mapping_fmaps
-            x = dense(x, fmaps=fmaps, gain=gain, use_wscale=use_wscale, lrmul=mapping_lrmul)
-            x = apply_bias(x, lrmul=mapping_lrmul)
-            x = act(x)
-
-    # Broadcast.
-    if dlatent_broadcast is not None:
-        with tf.variable_scope('Broadcast'):
-            x = tf.tile(x[:, np.newaxis], [1, dlatent_broadcast, 1])
-
-    # Output.
-    assert x.dtype == tf.as_dtype(dtype)
-    return tf.identity(x, name='dlatents_out')
-
-#----------------------------------------------------------------------------
-# Synthesis network used in the StyleGAN paper.
-
-def G_synthesis(
-    dlatents_in,                        # Input: Disentangled latents (W) [minibatch, num_layers, dlatent_size].
-    dlatent_size        = 512,          # Disentangled latent (W) dimensionality.
-    num_channels        = 3,            # Number of output color channels.
-    resolution          = 1024,         # Output resolution.
-    fmap_base           = 8192,         # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    use_styles          = True,         # Enable style inputs?
-    const_input_layer   = True,         # First layer is a learned constant?
-    use_noise           = True,         # Enable noise inputs?
-    randomize_noise     = True,         # True = randomize noise inputs every time (non-deterministic), False = read noise inputs from variables.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu'
-    use_wscale          = True,         # Enable equalized learning rate?
-    use_pixel_norm      = False,        # Enable pixelwise feature vector normalization?
-    use_instance_norm   = True,         # Enable instance normalization?
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    fused_scale         = 'auto',       # True = fused convolution + scaling, False = separate ops, 'auto' = decide automatically.
-    blur_filter         = [1,2,1],      # Low-pass filter to apply when resampling activations. None = no filtering.
-    structure           = 'auto',       # 'fixed' = no progressive growing, 'linear' = human-readable, 'recursive' = efficient, 'auto' = select automatically.
-    is_template_graph   = False,        # True = template graph constructed by the Network class, False = actual evaluation.
-    force_clean_graph   = False,        # True = construct a clean graph that looks nice in TensorBoard, False = default behavior.
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
-    def nf(stage): return min(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_max)
-    def blur(x): return blur2d(x, blur_filter) if blur_filter else x
-    if is_template_graph: force_clean_graph = True
-    if force_clean_graph: randomize_noise = False
-    if structure == 'auto': structure = 'linear' if force_clean_graph else 'recursive'
-    act, gain = {'relu': (tf.nn.relu, np.sqrt(2)), 'lrelu': (leaky_relu, np.sqrt(2))}[nonlinearity]
-    num_layers = resolution_log2 * 2 - 2
-    num_styles = num_layers if use_styles else 1
-    images_out = None
-
-    # Primary inputs.
-    dlatents_in.set_shape([None, num_styles, dlatent_size])
-    dlatents_in = tf.cast(dlatents_in, dtype)
-    lod_in = tf.cast(tf.get_variable('lod', initializer=np.float32(0), trainable=False), dtype)
-
-    # Noise inputs.
-    noise_inputs = []
-    if use_noise:
-        for layer_idx in range(num_layers):
-            res = layer_idx // 2 + 2
-            shape = [1, use_noise, 2**res, 2**res]
-            noise_inputs.append(tf.get_variable('noise%d' % layer_idx, shape=shape, initializer=tf.initializers.random_normal(), trainable=False))
-
-    # Things to do at the end of each layer.
-    def layer_epilogue(x, layer_idx):
-        if use_noise:
-            x = apply_noise(x, noise_inputs[layer_idx], randomize_noise=randomize_noise)
-        x = apply_bias(x)
-        x = act(x)
-        if use_pixel_norm:
-            x = pixel_norm(x)
-        if use_instance_norm:
-            x = instance_norm(x)
-        if use_styles:
-            x = style_mod(x, dlatents_in[:, layer_idx], use_wscale=use_wscale)
-        return x
-
-    # Early layers.
-    with tf.variable_scope('4x4'):
-        if const_input_layer:
-            with tf.variable_scope('Const'):
-                x = tf.get_variable('const', shape=[1, nf(1), 4, 4], initializer=tf.initializers.ones())
-                x = layer_epilogue(tf.tile(tf.cast(x, dtype), [tf.shape(dlatents_in)[0], 1, 1, 1]), 0)
-        else:
-            with tf.variable_scope('Dense'):
-                x = dense(dlatents_in[:, 0], fmaps=nf(1)*16, gain=gain/4, use_wscale=use_wscale) # tweak gain to match the official implementation of Progressing GAN
-                x = layer_epilogue(tf.reshape(x, [-1, nf(1), 4, 4]), 0)
-        with tf.variable_scope('Conv'):
-            x = layer_epilogue(conv2d(x, fmaps=nf(1), kernel=3, gain=gain, use_wscale=use_wscale), 1)
-
-    # Building blocks for remaining layers.
-    def block(res, x): # res = 3..resolution_log2
-        with tf.variable_scope('%dx%d' % (2**res, 2**res)):
-            with tf.variable_scope('Conv0_up'):
-                x = layer_epilogue(blur(upscale2d_conv2d(x, fmaps=nf(res-1), kernel=3, gain=gain, use_wscale=use_wscale, fused_scale=fused_scale)), res*2-4)
-            with tf.variable_scope('Conv1'):
-                x = layer_epilogue(conv2d(x, fmaps=nf(res-1), kernel=3, gain=gain, use_wscale=use_wscale), res*2-3)
-            return x
-    def torgb(res, x): # res = 2..resolution_log2
-        lod = resolution_log2 - res
-        with tf.variable_scope('ToRGB_lod%d' % lod):
-            return apply_bias(conv2d(x, fmaps=num_channels, kernel=1, gain=1, use_wscale=use_wscale))
-
-    # Fixed structure: simple and efficient, but does not support progressive growing.
-    if structure == 'fixed':
-        for res in range(3, resolution_log2 + 1):
-            x = block(res, x)
-        images_out = torgb(resolution_log2, x)
-
-    # Linear structure: simple but inefficient.
-    if structure == 'linear':
-        images_out = torgb(2, x)
-        for res in range(3, resolution_log2 + 1):
-            lod = resolution_log2 - res
-            x = block(res, x)
-            img = torgb(res, x)
-            images_out = upscale2d(images_out)
-            with tf.variable_scope('Grow_lod%d' % lod):
-                images_out = tflib.lerp_clip(img, images_out, lod_in - lod)
-
-    # Recursive structure: complex but efficient.
-    if structure == 'recursive':
-        def cset(cur_lambda, new_cond, new_lambda):
-            return lambda: tf.cond(new_cond, new_lambda, cur_lambda)
-        def grow(x, res, lod):
-            y = block(res, x)
-            img = lambda: upscale2d(torgb(res, y), 2**lod)
-            img = cset(img, (lod_in > lod), lambda: upscale2d(tflib.lerp(torgb(res, y), upscale2d(torgb(res - 1, x)), lod_in - lod), 2**lod))
-            if lod > 0: img = cset(img, (lod_in < lod), lambda: grow(y, res + 1, lod - 1))
-            return img()
-        images_out = grow(x, 3, resolution_log2 - 3)
-
-    assert images_out.dtype == tf.as_dtype(dtype)
-    return tf.identity(images_out, name='images_out')
-
-#----------------------------------------------------------------------------
-# Discriminator used in the StyleGAN paper.
-
-def D_basic(
-    images_in,                          # First input: Images [minibatch, channel, height, width].
-    labels_in,                          # Second input: Labels [minibatch, label_size].
-    num_channels        = 1,            # Number of input color channels. Overridden based on dataset.
-    resolution          = 32,           # Input resolution. Overridden based on dataset.
-    label_size          = 0,            # Dimensionality of the labels, 0 if no labels. Overridden based on dataset.
-    fmap_base           = 8192,         # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu',
-    use_wscale          = True,         # Enable equalized learning rate?
-    mbstd_group_size    = 4,            # Group size for the minibatch standard deviation layer, 0 = disable.
-    mbstd_num_features  = 1,            # Number of features for the minibatch standard deviation layer.
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    fused_scale         = 'auto',       # True = fused convolution + scaling, False = separate ops, 'auto' = decide automatically.
-    blur_filter         = [1,2,1],      # Low-pass filter to apply when resampling activations. None = no filtering.
-    structure           = 'auto',       # 'fixed' = no progressive growing, 'linear' = human-readable, 'recursive' = efficient, 'auto' = select automatically.
-    is_template_graph   = False,        # True = template graph constructed by the Network class, False = actual evaluation.
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
-    def nf(stage): return min(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_max)
-    def blur(x): return blur2d(x, blur_filter) if blur_filter else x
-    if structure == 'auto': structure = 'linear' if is_template_graph else 'recursive'
-    act, gain = {'relu': (tf.nn.relu, np.sqrt(2)), 'lrelu': (leaky_relu, np.sqrt(2))}[nonlinearity]
-
-    images_in.set_shape([None, num_channels, resolution, resolution])
-    labels_in.set_shape([None, label_size])
-    images_in = tf.cast(images_in, dtype)
-    labels_in = tf.cast(labels_in, dtype)
-    lod_in = tf.cast(tf.get_variable('lod', initializer=np.float32(0.0), trainable=False), dtype)
-    scores_out = None
-
-    # Building blocks.
-    def fromrgb(x, res): # res = 2..resolution_log2
-        with tf.variable_scope('FromRGB_lod%d' % (resolution_log2 - res)):
-            return act(apply_bias(conv2d(x, fmaps=nf(res-1), kernel=1, gain=gain, use_wscale=use_wscale)))
-    def block(x, res): # res = 2..resolution_log2
-        with tf.variable_scope('%dx%d' % (2**res, 2**res)):
-            if res >= 3: # 8x8 and up
-                with tf.variable_scope('Conv0'):
-                    x = act(apply_bias(conv2d(x, fmaps=nf(res-1), kernel=3, gain=gain, use_wscale=use_wscale)))
-                with tf.variable_scope('Conv1_down'):
-                    x = act(apply_bias(conv2d_downscale2d(blur(x), fmaps=nf(res-2), kernel=3, gain=gain, use_wscale=use_wscale, fused_scale=fused_scale)))
-            else: # 4x4
-                if mbstd_group_size > 1:
-                    x = minibatch_stddev_layer(x, mbstd_group_size, mbstd_num_features)
-                with tf.variable_scope('Conv'):
-                    x = act(apply_bias(conv2d(x, fmaps=nf(res-1), kernel=3, gain=gain, use_wscale=use_wscale)))
-                with tf.variable_scope('Dense0'):
-                    x = act(apply_bias(dense(x, fmaps=nf(res-2), gain=gain, use_wscale=use_wscale)))
-                with tf.variable_scope('Dense1'):
-                    x = apply_bias(dense(x, fmaps=max(label_size, 1), gain=1, use_wscale=use_wscale))
-            return x
-
-    # Fixed structure: simple and efficient, but does not support progressive growing.
-    if structure == 'fixed':
-        x = fromrgb(images_in, resolution_log2)
-        for res in range(resolution_log2, 2, -1):
-            x = block(x, res)
-        scores_out = block(x, 2)
-
-    # Linear structure: simple but inefficient.
-    if structure == 'linear':
-        img = images_in
-        x = fromrgb(img, resolution_log2)
-        for res in range(resolution_log2, 2, -1):
-            lod = resolution_log2 - res
-            x = block(x, res)
-            img = downscale2d(img)
-            y = fromrgb(img, res - 1)
-            with tf.variable_scope('Grow_lod%d' % lod):
-                x = tflib.lerp_clip(x, y, lod_in - lod)
-        scores_out = block(x, 2)
-
-    # Recursive structure: complex but efficient.
-    if structure == 'recursive':
-        def cset(cur_lambda, new_cond, new_lambda):
-            return lambda: tf.cond(new_cond, new_lambda, cur_lambda)
-        def grow(res, lod):
-            x = lambda: fromrgb(downscale2d(images_in, 2**lod), res)
-            if lod > 0: x = cset(x, (lod_in < lod), lambda: grow(res + 1, lod - 1))
-            x = block(x(), res); y = lambda: x
-            if res > 2: y = cset(y, (lod_in > lod), lambda: tflib.lerp(x, fromrgb(downscale2d(images_in, 2**(lod+1)), res - 1), lod_in - lod))
-            return y()
-        scores_out = grow(2, resolution_log2 - 2)
-
-    # Label conditioning from "Which Training Methods for GANs do actually Converge?"
-    if label_size:
-        with tf.variable_scope('LabelSwitch'):
-            scores_out = tf.reduce_sum(scores_out * labels_in, axis=1, keepdims=True)
-
-    assert scores_out.dtype == tf.as_dtype(dtype)
-    scores_out = tf.identity(scores_out, name='scores_out')
-    return scores_out
-
-#----------------------------------------------------------------------------
diff --git a/training/networks_stylegan2.py b/training/networks_stylegan2.py
index 6c96fc1..118a138 100755
--- a/training/networks_stylegan2.py
+++ b/training/networks_stylegan2.py
@@ -16,12 +16,13 @@ from dnnlib.tflib.ops.fused_bias_act import fused_bias_act
 # NOTE: Do not import any application-specific modules here!
 # Specify all network parameters as kwargs.
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Get/create weight tensor for a convolution or fully-connected layer.
 
+
 def get_weight(shape, gain=1, use_wscale=True, lrmul=1, weight_var='weight'):
-    fan_in = np.prod(shape[:-1]) # [kernel, kernel, fmaps_in, fmaps_out] or [in, out]
-    he_std = gain / np.sqrt(fan_in) # He init
+    fan_in = np.prod(shape[:-1])  # [kernel, kernel, fmaps_in, fmaps_out] or [in, out]
+    he_std = gain / np.sqrt(fan_in)  # He init
 
     # Equalized learning rate and custom learning rate multiplier.
     if use_wscale:
@@ -35,9 +36,10 @@ def get_weight(shape, gain=1, use_wscale=True, lrmul=1, weight_var='weight'):
     init = tf.initializers.random_normal(0, init_std)
     return tf.get_variable(weight_var, shape=shape, initializer=init) * runtime_coef
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Fully-connected layer.
 
+
 def dense_layer(x, fmaps, gain=1, use_wscale=True, lrmul=1, weight_var='weight'):
     if len(x.shape) > 2:
         x = tf.reshape(x, [-1, np.prod([d.value for d in x.shape[1:]])])
@@ -45,31 +47,34 @@ def dense_layer(x, fmaps, gain=1, use_wscale=True, lrmul=1, weight_var='weight')
     w = tf.cast(w, x.dtype)
     return tf.matmul(x, w)
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Convolution layer with optional upsampling or downsampling.
 
-def conv2d_layer(x, fmaps, kernel, up=False, down=False, resample_kernel=None, gain=1, use_wscale=True, lrmul=1, weight_var='weight'):
+
+def conv2d_layer(x, fmaps, kernel, up=False, down=False, resample_kernel=None, gain=1, use_wscale=True, lrmul=1, weight_var='weight', impl='cuda'):
     assert not (up and down)
     assert kernel >= 1 and kernel % 2 == 1
     w = get_weight([kernel, kernel, x.shape[1].value, fmaps], gain=gain, use_wscale=use_wscale, lrmul=lrmul, weight_var=weight_var)
     if up:
-        x = upsample_conv_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel)
+        x = upsample_conv_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel, impl=impl)
     elif down:
-        x = conv_downsample_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel)
+        x = conv_downsample_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel, impl=impl)
     else:
-        x = tf.nn.conv2d(x, tf.cast(w, x.dtype), data_format='NCHW', strides=[1,1,1,1], padding='SAME')
+        x = tf.nn.conv2d(x, tf.cast(w, x.dtype), data_format='NCHW', strides=[1, 1, 1, 1], padding='SAME')
     return x
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Apply bias and activation func.
 
-def apply_bias_act(x, act='linear', alpha=None, gain=None, lrmul=1, bias_var='bias'):
+
+def apply_bias_act(x, act='linear', alpha=None, gain=None, lrmul=1, bias_var='bias', impl='cuda'):
     b = tf.get_variable(bias_var, shape=[x.shape[1]], initializer=tf.initializers.zeros()) * lrmul
-    return fused_bias_act(x, b=tf.cast(b, x.dtype), act=act, alpha=alpha, gain=gain)
+    return fused_bias_act(x, b=tf.cast(b, x.dtype), act=act, alpha=alpha, gain=gain, impl=impl)
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Naive upsampling (nearest neighbor) and downsampling (average pooling).
 
+
 def naive_upsample_2d(x, factor=2):
     with tf.variable_scope('NaiveUpsample'):
         _N, C, H, W = x.shape.as_list()
@@ -77,94 +82,98 @@ def naive_upsample_2d(x, factor=2):
         x = tf.tile(x, [1, 1, 1, factor, 1, factor])
         return tf.reshape(x, [-1, C, H * factor, W * factor])
 
+
 def naive_downsample_2d(x, factor=2):
     with tf.variable_scope('NaiveDownsample'):
         _N, C, H, W = x.shape.as_list()
         x = tf.reshape(x, [-1, C, H // factor, factor, W // factor, factor])
-        return tf.reduce_mean(x, axis=[3,5])
+        return tf.reduce_mean(x, axis=[3, 5])
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Modulated convolution layer.
 
-def modulated_conv2d_layer(x, y, fmaps, kernel, up=False, down=False, demodulate=True, resample_kernel=None, gain=1, use_wscale=True, lrmul=1, fused_modconv=True, weight_var='weight', mod_weight_var='mod_weight', mod_bias_var='mod_bias'):
+
+def modulated_conv2d_layer(x, y, fmaps, kernel, up=False, down=False, demodulate=True, resample_kernel=None, gain=1, use_wscale=True, lrmul=1, fused_modconv=True, weight_var='weight', mod_weight_var='mod_weight', mod_bias_var='mod_bias', impl='cuda'):
     assert not (up and down)
     assert kernel >= 1 and kernel % 2 == 1
 
     # Get weight.
     w = get_weight([kernel, kernel, x.shape[1].value, fmaps], gain=gain, use_wscale=use_wscale, lrmul=lrmul, weight_var=weight_var)
-    ww = w[np.newaxis] # [BkkIO] Introduce minibatch dimension.
+    ww = w[np.newaxis]  # [BkkIO] Introduce minibatch dimension.
 
     # Modulate.
-    s = dense_layer(y, fmaps=x.shape[1].value, weight_var=mod_weight_var) # [BI] Transform incoming W to style.
-    s = apply_bias_act(s, bias_var=mod_bias_var) + 1 # [BI] Add bias (initially 1).
-    ww *= tf.cast(s[:, np.newaxis, np.newaxis, :, np.newaxis], w.dtype) # [BkkIO] Scale input feature maps.
+    s = dense_layer(y, fmaps=x.shape[1].value, weight_var=mod_weight_var)  # [BI] Transform incoming W to style.
+    s = apply_bias_act(s, bias_var=mod_bias_var, impl=impl) + 1  # [BI] Add bias (initially 1).
+    ww *= tf.cast(s[:, np.newaxis, np.newaxis, :, np.newaxis], w.dtype)  # [BkkIO] Scale input feature maps.
 
     # Demodulate.
     if demodulate:
-        d = tf.rsqrt(tf.reduce_sum(tf.square(ww), axis=[1,2,3]) + 1e-8) # [BO] Scaling factor.
-        ww *= d[:, np.newaxis, np.newaxis, np.newaxis, :] # [BkkIO] Scale output feature maps.
+        d = tf.rsqrt(tf.reduce_sum(tf.square(ww), axis=[1, 2, 3]) + 1e-8)  # [BO] Scaling factor.
+        ww *= d[:, np.newaxis, np.newaxis, np.newaxis, :]  # [BkkIO] Scale output feature maps.
 
     # Reshape/scale input.
     if fused_modconv:
-        x = tf.reshape(x, [1, -1, x.shape[2], x.shape[3]]) # Fused => reshape minibatch to convolution groups.
+        x = tf.reshape(x, [1, -1, x.shape[2], x.shape[3]])  # Fused => reshape minibatch to convolution groups.
         w = tf.reshape(tf.transpose(ww, [1, 2, 3, 0, 4]), [ww.shape[1], ww.shape[2], ww.shape[3], -1])
     else:
-        x *= tf.cast(s[:, :, np.newaxis, np.newaxis], x.dtype) # [BIhw] Not fused => scale input activations.
+        x *= tf.cast(s[:, :, np.newaxis, np.newaxis], x.dtype)  # [BIhw] Not fused => scale input activations.
 
     # Convolution with optional up/downsampling.
     if up:
-        x = upsample_conv_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel)
+        x = upsample_conv_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel, impl=impl)
     elif down:
-        x = conv_downsample_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel)
+        x = conv_downsample_2d(x, tf.cast(w, x.dtype), data_format='NCHW', k=resample_kernel, impl=impl)
     else:
-        x = tf.nn.conv2d(x, tf.cast(w, x.dtype), data_format='NCHW', strides=[1,1,1,1], padding='SAME')
+        x = tf.nn.conv2d(x, tf.cast(w, x.dtype), data_format='NCHW', strides=[1, 1, 1, 1], padding='SAME')
 
     # Reshape/scale output.
     if fused_modconv:
-        x = tf.reshape(x, [-1, fmaps, x.shape[2], x.shape[3]]) # Fused => reshape convolution groups back to minibatch.
+        x = tf.reshape(x, [-1, fmaps, x.shape[2], x.shape[3]])  # Fused => reshape convolution groups back to minibatch.
     elif demodulate:
-        x *= tf.cast(d[:, :, np.newaxis, np.newaxis], x.dtype) # [BOhw] Not fused => scale output activations.
+        x *= tf.cast(d[:, :, np.newaxis, np.newaxis], x.dtype)  # [BOhw] Not fused => scale output activations.
     return x
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Minibatch standard deviation layer.
 
+
 def minibatch_stddev_layer(x, group_size=4, num_new_features=1):
     group_size = tf.minimum(group_size, tf.shape(x)[0])     # Minibatch must be divisible by (or smaller than) group_size.
     s = x.shape                                             # [NCHW]  Input shape.
-    y = tf.reshape(x, [group_size, -1, num_new_features, s[1]//num_new_features, s[2], s[3]])   # [GMncHW] Split minibatch into M groups of size G. Split channels into n channel groups c.
+    y = tf.reshape(x, [group_size, -1, num_new_features, s[1] // num_new_features, s[2], s[3]])   # [GMncHW] Split minibatch into M groups of size G. Split channels into n channel groups c.
     y = tf.cast(y, tf.float32)                              # [GMncHW] Cast to FP32.
     y -= tf.reduce_mean(y, axis=0, keepdims=True)           # [GMncHW] Subtract mean over group.
     y = tf.reduce_mean(tf.square(y), axis=0)                # [MncHW]  Calc variance over group.
     y = tf.sqrt(y + 1e-8)                                   # [MncHW]  Calc stddev over group.
-    y = tf.reduce_mean(y, axis=[2,3,4], keepdims=True)      # [Mn111]  Take average over fmaps and pixels.
+    y = tf.reduce_mean(y, axis=[2, 3, 4], keepdims=True)      # [Mn111]  Take average over fmaps and pixels.
     y = tf.reduce_mean(y, axis=[2])                         # [Mn11] Split channels into c channel groups
     y = tf.cast(y, x.dtype)                                 # [Mn11]  Cast back to original data type.
     y = tf.tile(y, [group_size, 1, s[2], s[3]])             # [NnHW]  Replicate over group and pixels.
     return tf.concat([x, y], axis=1)                        # [NCHW]  Append as new fmap.
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Main generator network.
 # Composed of two sub-networks (mapping and synthesis) that are defined below.
 # Used in configs B-F (Table 1).
 
+
 def G_main(
-    latents_in,                                         # First input: Latent vectors (Z) [minibatch, latent_size].
-    labels_in,                                          # Second input: Conditioning labels [minibatch, label_size].
-    truncation_psi          = 0.5,                      # Style strength multiplier for the truncation trick. None = disable.
-    truncation_cutoff       = None,                     # Number of layers for which to apply the truncation trick. None = disable.
-    truncation_psi_val      = None,                     # Value for truncation_psi to use during validation.
-    truncation_cutoff_val   = None,                     # Value for truncation_cutoff to use during validation.
-    dlatent_avg_beta        = 0.995,                    # Decay for tracking the moving average of W during training. None = disable.
-    style_mixing_prob       = 0.9,                      # Probability of mixing styles during training. None = disable.
-    is_training             = False,                    # Network is under training? Enables and disables specific features.
-    is_validation           = False,                    # Network is under validation? Chooses which value to use for truncation_psi.
-    return_dlatents         = False,                    # Return dlatents in addition to the images?
-    is_template_graph       = False,                    # True = template graph constructed by the Network class, False = actual evaluation.
-    components              = dnnlib.EasyDict(),        # Container for sub-networks. Retained between calls.
-    mapping_func            = 'G_mapping',              # Build func name for the mapping network.
-    synthesis_func          = 'G_synthesis_stylegan2',  # Build func name for the synthesis network.
-    **kwargs):                                          # Arguments for sub-networks (mapping and synthesis).
+        latents_in,                                         # First input: Latent vectors (Z) [minibatch, latent_size].
+        labels_in,                                          # Second input: Conditioning labels [minibatch].
+        truncation_psi=None,                     # Style strength multiplier for the truncation trick. None = disable.
+        truncation_cutoff=None,                     # Number of layers for which to apply the truncation trick. None = disable.
+        truncation_psi_val=None,                     # Value for truncation_psi to use during validation.
+        truncation_cutoff_val=None,                     # Value for truncation_cutoff to use during validation.
+        dlatent_avg_beta=0.995,                    # Decay for tracking the moving average of W during training. None = disable.
+        style_mixing_prob=0.9,                      # Probability of mixing styles during training. None = disable.
+        is_training=False,                    # Network is under training? Enables and disables specific features.
+        is_validation=False,                    # Network is under validation? Chooses which value to use for truncation_psi.
+        return_dlatents=False,                    # Return dlatents in addition to the images?
+        is_template_graph=False,                    # True = template graph constructed by the Network class, False = actual evaluation.
+        components=dnnlib.EasyDict(),        # Container for sub-networks. Retained between calls.
+        mapping_func='G_mapping',              # Build func name for the mapping network.
+        synthesis_func='G_synthesis_stylegan2',  # Build func name for the synthesis network.
+        **kwargs):                                          # Arguments for sub-networks (mapping and synthesis).
 
     # Validate arguments.
     assert not is_training or not is_validation
@@ -213,10 +222,10 @@ def G_main(
             dlatents2 = tf.cast(dlatents2, tf.float32)
             layer_idx = np.arange(num_layers)[np.newaxis, :, np.newaxis]
             cur_layers = num_layers - tf.cast(lod_in, tf.int32) * 2
-            mixing_cutoff = tf.cond(
-                tf.random_uniform([], 0.0, 1.0) < style_mixing_prob,
-                lambda: tf.random_uniform([], 1, cur_layers, dtype=tf.int32),
-                lambda: cur_layers)
+            mixing_cutoff = tf.where_v2(
+                tf.random_uniform([tf.shape(dlatents)[0]], 0.0, 1.0) < style_mixing_prob,
+                tf.random_uniform([tf.shape(dlatents)[0]], 1, cur_layers, dtype=tf.int32),
+                cur_layers[np.newaxis])[:, np.newaxis, np.newaxis]
             dlatents = tf.where(tf.broadcast_to(layer_idx < mixing_cutoff, tf.shape(dlatents)), dlatents, dlatents2)
 
     # Apply truncation trick.
@@ -243,40 +252,42 @@ def G_main(
         return images_out, dlatents
     return images_out
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Mapping network.
 # Transforms the input latent code (z) to the disentangled latent code (w).
 # Used in configs B-F (Table 1).
 
+
 def G_mapping(
-    latents_in,                             # First input: Latent vectors (Z) [minibatch, latent_size].
-    labels_in,                              # Second input: Conditioning labels [minibatch, label_size].
-    latent_size             = 512,          # Latent vector (Z) dimensionality.
-    label_size              = 0,            # Label dimensionality, 0 if no labels.
-    dlatent_size            = 512,          # Disentangled latent (W) dimensionality.
-    dlatent_broadcast       = None,         # Output disentangled latent (W) as [minibatch, dlatent_size] or [minibatch, dlatent_broadcast, dlatent_size].
-    mapping_layers          = 8,            # Number of mapping layers.
-    mapping_fmaps           = 512,          # Number of activations in the mapping layers.
-    mapping_lrmul           = 0.01,         # Learning rate multiplier for the mapping layers.
-    mapping_nonlinearity    = 'lrelu',      # Activation function: 'relu', 'lrelu', etc.
-    normalize_latents       = True,         # Normalize latent vectors (Z) before feeding them to the mapping layers?
-    dtype                   = 'float32',    # Data type to use for activations and outputs.
-    **_kwargs):                             # Ignore unrecognized keyword args.
+        latents_in,                             # First input: Latent vectors (Z) [minibatch, latent_size].
+        labels_in,                              # Second input: label latent vectors [minibatch].
+        latent_size=512,          # Latent vector (Z) dimensionality.
+        label_size=0,            # Label dimensionality.
+        dlatent_size=512,          # Disentangled latent (W) dimensionality.
+        dlatent_broadcast=None,         # Output disentangled latent (W) as [minibatch, dlatent_size] or [minibatch, dlatent_broadcast, dlatent_size].
+        mapping_layers=8,            # Number of mapping layers.
+        mapping_fmaps=512,          # Number of activations in the mapping layers.
+        mapping_lrmul=0.01,         # Learning rate multiplier for the mapping layers.
+        mapping_nonlinearity='lrelu',      # Activation function: 'relu', 'lrelu', etc.
+        normalize_latents=True,         # Normalize latent vectors (Z) before feeding them to the mapping layers?
+        dtype='float32',    # Data type to use for activations and outputs.
+        impl='cuda',
+        **_kwargs):                             # Ignore unrecognized keyword args.
 
     act = mapping_nonlinearity
 
     # Inputs.
     latents_in.set_shape([None, latent_size])
-    labels_in.set_shape([None, label_size])
+    labels_in.set_shape([None])
     latents_in = tf.cast(latents_in, dtype)
-    labels_in = tf.cast(labels_in, dtype)
+    labels_in = tf.cast(labels_in, tf.int64)
     x = latents_in
 
     # Embed labels and concatenate them with latents.
     if label_size:
         with tf.variable_scope('LabelConcat'):
-            w = tf.get_variable('weight', shape=[label_size, latent_size], initializer=tf.initializers.random_normal())
-            y = tf.matmul(labels_in, tf.cast(w, dtype))
+            w = get_weight([label_size, latent_size], gain=np.sqrt(label_size), lrmul=mapping_lrmul)
+            y = tf.matmul(tf.one_hot(labels_in, label_size, dtype=dtype), tf.cast(w, dtype))
             x = tf.concat([x, y], axis=1)
 
     # Normalize latents.
@@ -288,7 +299,7 @@ def G_mapping(
     for layer_idx in range(mapping_layers):
         with tf.variable_scope('Dense%d' % layer_idx):
             fmaps = dlatent_size if layer_idx == mapping_layers - 1 else mapping_fmaps
-            x = apply_bias_act(dense_layer(x, fmaps=fmaps, lrmul=mapping_lrmul), act=act, lrmul=mapping_lrmul)
+            x = apply_bias_act(dense_layer(x, fmaps=fmaps, lrmul=mapping_lrmul), act=act, lrmul=mapping_lrmul, impl=impl)
 
     # Broadcast.
     if dlatent_broadcast is not None:
@@ -299,140 +310,32 @@ def G_mapping(
     assert x.dtype == tf.as_dtype(dtype)
     return tf.identity(x, name='dlatents_out')
 
-#----------------------------------------------------------------------------
-# StyleGAN synthesis network with revised architecture (Figure 2d).
-# Implements progressive growing, but no skip connections or residual nets (Figure 7).
-# Used in configs B-D (Table 1).
-
-def G_synthesis_stylegan_revised(
-    dlatents_in,                        # Input: Disentangled latents (W) [minibatch, num_layers, dlatent_size].
-    dlatent_size        = 512,          # Disentangled latent (W) dimensionality.
-    num_channels        = 3,            # Number of output color channels.
-    resolution          = 1024,         # Output resolution.
-    fmap_base           = 16 << 10,     # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_min            = 1,            # Minimum number of feature maps in any layer.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    randomize_noise     = True,         # True = randomize noise inputs every time (non-deterministic), False = read noise inputs from variables.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu', etc.
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    resample_kernel     = [1,3,3,1],    # Low-pass filter to apply when resampling activations. None = no filtering.
-    fused_modconv       = True,         # Implement modulated_conv2d_layer() as a single fused op?
-    structure           = 'auto',       # 'fixed' = no progressive growing, 'linear' = human-readable, 'recursive' = efficient, 'auto' = select automatically.
-    is_template_graph   = False,        # True = template graph constructed by the Network class, False = actual evaluation.
-    force_clean_graph   = False,        # True = construct a clean graph that looks nice in TensorBoard, False = default behavior.
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
-    def nf(stage): return np.clip(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_min, fmap_max)
-    if is_template_graph: force_clean_graph = True
-    if force_clean_graph: randomize_noise = False
-    if structure == 'auto': structure = 'linear' if force_clean_graph else 'recursive'
-    act = nonlinearity
-    num_layers = resolution_log2 * 2 - 2
-    images_out = None
-
-    # Primary inputs.
-    dlatents_in.set_shape([None, num_layers, dlatent_size])
-    dlatents_in = tf.cast(dlatents_in, dtype)
-    lod_in = tf.cast(tf.get_variable('lod', initializer=np.float32(0), trainable=False), dtype)
-
-    # Noise inputs.
-    noise_inputs = []
-    for layer_idx in range(num_layers - 1):
-        res = (layer_idx + 5) // 2
-        shape = [1, 1, 2**res, 2**res]
-        noise_inputs.append(tf.get_variable('noise%d' % layer_idx, shape=shape, initializer=tf.initializers.random_normal(), trainable=False))
-
-    # Single convolution layer with all the bells and whistles.
-    def layer(x, layer_idx, fmaps, kernel, up=False):
-        x = modulated_conv2d_layer(x, dlatents_in[:, layer_idx], fmaps=fmaps, kernel=kernel, up=up, resample_kernel=resample_kernel, fused_modconv=fused_modconv)
-        if randomize_noise:
-            noise = tf.random_normal([tf.shape(x)[0], 1, x.shape[2], x.shape[3]], dtype=x.dtype)
-        else:
-            noise = tf.cast(noise_inputs[layer_idx], x.dtype)
-        noise_strength = tf.get_variable('noise_strength', shape=[], initializer=tf.initializers.zeros())
-        x += noise * tf.cast(noise_strength, x.dtype)
-        return apply_bias_act(x, act=act)
-
-    # Early layers.
-    with tf.variable_scope('4x4'):
-        with tf.variable_scope('Const'):
-            x = tf.get_variable('const', shape=[1, nf(1), 4, 4], initializer=tf.initializers.random_normal())
-            x = tf.tile(tf.cast(x, dtype), [tf.shape(dlatents_in)[0], 1, 1, 1])
-        with tf.variable_scope('Conv'):
-            x = layer(x, layer_idx=0, fmaps=nf(1), kernel=3)
-
-    # Building blocks for remaining layers.
-    def block(res, x): # res = 3..resolution_log2
-        with tf.variable_scope('%dx%d' % (2**res, 2**res)):
-            with tf.variable_scope('Conv0_up'):
-                x = layer(x, layer_idx=res*2-5, fmaps=nf(res-1), kernel=3, up=True)
-            with tf.variable_scope('Conv1'):
-                x = layer(x, layer_idx=res*2-4, fmaps=nf(res-1), kernel=3)
-            return x
-    def torgb(res, x): # res = 2..resolution_log2
-        with tf.variable_scope('ToRGB_lod%d' % (resolution_log2 - res)):
-            return apply_bias_act(modulated_conv2d_layer(x, dlatents_in[:, res*2-3], fmaps=num_channels, kernel=1, demodulate=False, fused_modconv=fused_modconv))
-
-    # Fixed structure: simple and efficient, but does not support progressive growing.
-    if structure == 'fixed':
-        for res in range(3, resolution_log2 + 1):
-            x = block(res, x)
-        images_out = torgb(resolution_log2, x)
-
-    # Linear structure: simple but inefficient.
-    if structure == 'linear':
-        images_out = torgb(2, x)
-        for res in range(3, resolution_log2 + 1):
-            lod = resolution_log2 - res
-            x = block(res, x)
-            img = torgb(res, x)
-            with tf.variable_scope('Upsample_lod%d' % lod):
-                images_out = upsample_2d(images_out)
-            with tf.variable_scope('Grow_lod%d' % lod):
-                images_out = tflib.lerp_clip(img, images_out, lod_in - lod)
-
-    # Recursive structure: complex but efficient.
-    if structure == 'recursive':
-        def cset(cur_lambda, new_cond, new_lambda):
-            return lambda: tf.cond(new_cond, new_lambda, cur_lambda)
-        def grow(x, res, lod):
-            y = block(res, x)
-            img = lambda: naive_upsample_2d(torgb(res, y), factor=2**lod)
-            img = cset(img, (lod_in > lod), lambda: naive_upsample_2d(tflib.lerp(torgb(res, y), upsample_2d(torgb(res - 1, x)), lod_in - lod), factor=2**lod))
-            if lod > 0: img = cset(img, (lod_in < lod), lambda: grow(y, res + 1, lod - 1))
-            return img()
-        images_out = grow(x, 3, resolution_log2 - 3)
-
-    assert images_out.dtype == tf.as_dtype(dtype)
-    return tf.identity(images_out, name='images_out')
-
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # StyleGAN2 synthesis network (Figure 7).
 # Implements skip connections and residual nets (Figure 7), but no progressive growing.
 # Used in configs E-F (Table 1).
 
+
 def G_synthesis_stylegan2(
-    dlatents_in,                        # Input: Disentangled latents (W) [minibatch, num_layers, dlatent_size].
-    dlatent_size        = 512,          # Disentangled latent (W) dimensionality.
-    num_channels        = 3,            # Number of output color channels.
-    resolution          = 1024,         # Output resolution.
-    fmap_base           = 16 << 10,     # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_min            = 1,            # Minimum number of feature maps in any layer.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    randomize_noise     = True,         # True = randomize noise inputs every time (non-deterministic), False = read noise inputs from variables.
-    architecture        = 'skip',       # Architecture: 'orig', 'skip', 'resnet'.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu', etc.
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    resample_kernel     = [1,3,3,1],    # Low-pass filter to apply when resampling activations. None = no filtering.
-    fused_modconv       = True,         # Implement modulated_conv2d_layer() as a single fused op?
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
+        dlatents_in,                        # Input: Disentangled latents (W) [minibatch, num_layers, dlatent_size].
+        dlatent_size=512,          # Disentangled latent (W) dimensionality.
+        num_channels=3,            # Number of output color channels.
+        resolution=1024,         # Output resolution.
+        fmap_base=16384,        # Overall multiplier for the number of feature maps.
+        fmap_decay=1.0,          # log2 feature map reduction when doubling the resolution.
+        fmap_min=1,            # Minimum number of feature maps in any layer.
+        fmap_max=512,          # Maximum number of feature maps in any layer.
+        randomize_noise=True,         # True = randomize noise inputs every time (non-deterministic), False = read noise inputs from variables.
+        architecture='skip',       # Architecture: 'orig', 'skip', 'resnet'.
+        nonlinearity='lrelu',      # Activation function: 'relu', 'lrelu', etc.
+        dtype='float32',    # Data type to use for activations and outputs.
+        resample_kernel=[1, 3, 3, 1],    # Low-pass filter to apply when resampling activations. None = no filtering.
+        fused_modconv=True,         # Implement modulated_conv2d_layer() as a single fused op?
+        impl='cuda',
+        **_kwargs):                         # Ignore unrecognized keyword args.
+
+    resolution_log2 = int(np.ceil(np.log2(resolution)))
+    pad = (2 ** resolution_log2 - resolution) // 2
     def nf(stage): return np.clip(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_min, fmap_max)
     assert architecture in ['orig', 'skip', 'resnet']
     act = nonlinearity
@@ -452,33 +355,35 @@ def G_synthesis_stylegan2(
 
     # Single convolution layer with all the bells and whistles.
     def layer(x, layer_idx, fmaps, kernel, up=False):
-        x = modulated_conv2d_layer(x, dlatents_in[:, layer_idx], fmaps=fmaps, kernel=kernel, up=up, resample_kernel=resample_kernel, fused_modconv=fused_modconv)
+        x = modulated_conv2d_layer(x, dlatents_in[:, layer_idx], fmaps=fmaps, kernel=kernel, up=up, resample_kernel=resample_kernel, fused_modconv=fused_modconv, impl=impl)
         if randomize_noise:
             noise = tf.random_normal([tf.shape(x)[0], 1, x.shape[2], x.shape[3]], dtype=x.dtype)
         else:
             noise = tf.cast(noise_inputs[layer_idx], x.dtype)
         noise_strength = tf.get_variable('noise_strength', shape=[], initializer=tf.initializers.zeros())
         x += noise * tf.cast(noise_strength, x.dtype)
-        return apply_bias_act(x, act=act)
+        return apply_bias_act(x, act=act, impl=impl)
 
     # Building blocks for main layers.
-    def block(x, res): # res = 3..resolution_log2
+    def block(x, res):  # res = 3..resolution_log2
         t = x
         with tf.variable_scope('Conv0_up'):
-            x = layer(x, layer_idx=res*2-5, fmaps=nf(res-1), kernel=3, up=True)
+            x = layer(x, layer_idx=res * 2 - 5, fmaps=nf(res - 1), kernel=3, up=True)
         with tf.variable_scope('Conv1'):
-            x = layer(x, layer_idx=res*2-4, fmaps=nf(res-1), kernel=3)
+            x = layer(x, layer_idx=res * 2 - 4, fmaps=nf(res - 1), kernel=3)
         if architecture == 'resnet':
             with tf.variable_scope('Skip'):
-                t = conv2d_layer(t, fmaps=nf(res-1), kernel=1, up=True, resample_kernel=resample_kernel)
+                t = conv2d_layer(t, fmaps=nf(res - 1), kernel=1, up=True, resample_kernel=resample_kernel, impl=impl)
                 x = (x + t) * (1 / np.sqrt(2))
         return x
+
     def upsample(y):
         with tf.variable_scope('Upsample'):
-            return upsample_2d(y, k=resample_kernel)
-    def torgb(x, y, res): # res = 2..resolution_log2
+            return upsample_2d(y, k=resample_kernel, impl=impl)
+
+    def torgb(x, y, res):  # res = 2..resolution_log2
         with tf.variable_scope('ToRGB'):
-            t = apply_bias_act(modulated_conv2d_layer(x, dlatents_in[:, res*2-3], fmaps=num_channels, kernel=1, demodulate=False, fused_modconv=fused_modconv))
+            t = apply_bias_act(modulated_conv2d_layer(x, dlatents_in[:, res * 2 - 3], fmaps=num_channels, kernel=1, demodulate=False, fused_modconv=fused_modconv, impl=impl), impl=impl)
             return t if y is None else y + t
 
     # Early layers.
@@ -502,166 +407,71 @@ def G_synthesis_stylegan2(
                 y = torgb(x, y, res)
     images_out = y
 
+    if pad > 0:
+        images_out = images_out[:, :, pad: -pad, pad: -pad]
+
     assert images_out.dtype == tf.as_dtype(dtype)
     return tf.identity(images_out, name='images_out')
 
-#----------------------------------------------------------------------------
-# Original StyleGAN discriminator.
-# Used in configs B-D (Table 1).
-
-def D_stylegan(
-    images_in,                          # First input: Images [minibatch, channel, height, width].
-    labels_in,                          # Second input: Labels [minibatch, label_size].
-    num_channels        = 3,            # Number of input color channels. Overridden based on dataset.
-    resolution          = 1024,         # Input resolution. Overridden based on dataset.
-    label_size          = 0,            # Dimensionality of the labels, 0 if no labels. Overridden based on dataset.
-    fmap_base           = 16 << 10,     # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_min            = 1,            # Minimum number of feature maps in any layer.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu', etc.
-    mbstd_group_size    = 4,            # Group size for the minibatch standard deviation layer, 0 = disable.
-    mbstd_num_features  = 1,            # Number of features for the minibatch standard deviation layer.
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    resample_kernel     = [1,3,3,1],    # Low-pass filter to apply when resampling activations. None = no filtering.
-    structure           = 'auto',       # 'fixed' = no progressive growing, 'linear' = human-readable, 'recursive' = efficient, 'auto' = select automatically.
-    is_template_graph   = False,        # True = template graph constructed by the Network class, False = actual evaluation.
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
-    def nf(stage): return np.clip(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_min, fmap_max)
-    if structure == 'auto': structure = 'linear' if is_template_graph else 'recursive'
-    act = nonlinearity
-
-    images_in.set_shape([None, num_channels, resolution, resolution])
-    labels_in.set_shape([None, label_size])
-    images_in = tf.cast(images_in, dtype)
-    labels_in = tf.cast(labels_in, dtype)
-    lod_in = tf.cast(tf.get_variable('lod', initializer=np.float32(0.0), trainable=False), dtype)
-
-    # Building blocks for spatial layers.
-    def fromrgb(x, res): # res = 2..resolution_log2
-        with tf.variable_scope('FromRGB_lod%d' % (resolution_log2 - res)):
-            return apply_bias_act(conv2d_layer(x, fmaps=nf(res-1), kernel=1), act=act)
-    def block(x, res): # res = 2..resolution_log2
-        with tf.variable_scope('%dx%d' % (2**res, 2**res)):
-            with tf.variable_scope('Conv0'):
-                x = apply_bias_act(conv2d_layer(x, fmaps=nf(res-1), kernel=3), act=act)
-            with tf.variable_scope('Conv1_down'):
-                x = apply_bias_act(conv2d_layer(x, fmaps=nf(res-2), kernel=3, down=True, resample_kernel=resample_kernel), act=act)
-            return x
-
-    # Fixed structure: simple and efficient, but does not support progressive growing.
-    if structure == 'fixed':
-        x = fromrgb(images_in, resolution_log2)
-        for res in range(resolution_log2, 2, -1):
-            x = block(x, res)
-
-    # Linear structure: simple but inefficient.
-    if structure == 'linear':
-        img = images_in
-        x = fromrgb(img, resolution_log2)
-        for res in range(resolution_log2, 2, -1):
-            lod = resolution_log2 - res
-            x = block(x, res)
-            with tf.variable_scope('Downsample_lod%d' % lod):
-                img = downsample_2d(img)
-            y = fromrgb(img, res - 1)
-            with tf.variable_scope('Grow_lod%d' % lod):
-                x = tflib.lerp_clip(x, y, lod_in - lod)
-
-    # Recursive structure: complex but efficient.
-    if structure == 'recursive':
-        def cset(cur_lambda, new_cond, new_lambda):
-            return lambda: tf.cond(new_cond, new_lambda, cur_lambda)
-        def grow(res, lod):
-            x = lambda: fromrgb(naive_downsample_2d(images_in, factor=2**lod), res)
-            if lod > 0: x = cset(x, (lod_in < lod), lambda: grow(res + 1, lod - 1))
-            x = block(x(), res); y = lambda: x
-            y = cset(y, (lod_in > lod), lambda: tflib.lerp(x, fromrgb(naive_downsample_2d(images_in, factor=2**(lod+1)), res - 1), lod_in - lod))
-            return y()
-        x = grow(3, resolution_log2 - 3)
-
-    # Final layers at 4x4 resolution.
-    with tf.variable_scope('4x4'):
-        if mbstd_group_size > 1:
-            with tf.variable_scope('MinibatchStddev'):
-                x = minibatch_stddev_layer(x, mbstd_group_size, mbstd_num_features)
-        with tf.variable_scope('Conv'):
-            x = apply_bias_act(conv2d_layer(x, fmaps=nf(1), kernel=3), act=act)
-        with tf.variable_scope('Dense0'):
-            x = apply_bias_act(dense_layer(x, fmaps=nf(0)), act=act)
-
-    # Output layer with label conditioning from "Which Training Methods for GANs do actually Converge?"
-    with tf.variable_scope('Output'):
-        x = apply_bias_act(dense_layer(x, fmaps=max(labels_in.shape[1], 1)))
-        if labels_in.shape[1] > 0:
-            x = tf.reduce_sum(x * labels_in, axis=1, keepdims=True)
-    scores_out = x
-
-    # Output.
-    assert scores_out.dtype == tf.as_dtype(dtype)
-    scores_out = tf.identity(scores_out, name='scores_out')
-    return scores_out
-
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # StyleGAN2 discriminator (Figure 7).
 # Implements skip connections and residual nets (Figure 7), but no progressive growing.
 # Used in configs E-F (Table 1).
 
+
 def D_stylegan2(
-    images_in,                          # First input: Images [minibatch, channel, height, width].
-    labels_in,                          # Second input: Labels [minibatch, label_size].
-    num_channels        = 3,            # Number of input color channels. Overridden based on dataset.
-    resolution          = 1024,         # Input resolution. Overridden based on dataset.
-    label_size          = 0,            # Dimensionality of the labels, 0 if no labels. Overridden based on dataset.
-    fmap_base           = 16 << 10,     # Overall multiplier for the number of feature maps.
-    fmap_decay          = 1.0,          # log2 feature map reduction when doubling the resolution.
-    fmap_min            = 1,            # Minimum number of feature maps in any layer.
-    fmap_max            = 512,          # Maximum number of feature maps in any layer.
-    architecture        = 'resnet',     # Architecture: 'orig', 'skip', 'resnet'.
-    nonlinearity        = 'lrelu',      # Activation function: 'relu', 'lrelu', etc.
-    mbstd_group_size    = 4,            # Group size for the minibatch standard deviation layer, 0 = disable.
-    mbstd_num_features  = 1,            # Number of features for the minibatch standard deviation layer.
-    dtype               = 'float32',    # Data type to use for activations and outputs.
-    resample_kernel     = [1,3,3,1],    # Low-pass filter to apply when resampling activations. None = no filtering.
-    **_kwargs):                         # Ignore unrecognized keyword args.
-
-    resolution_log2 = int(np.log2(resolution))
-    assert resolution == 2**resolution_log2 and resolution >= 4
+        images_in,                          # First input: Images [minibatch, channel, height, width].
+        num_channels=3,            # Number of input color channels. Overridden based on dataset.
+        label_size=0,            # Label dimensionality.
+        resolution=1024,         # Input resolution. Overridden based on dataset.
+        fmap_base=16384,        # Overall multiplier for the number of feature maps.
+        fmap_decay=1.0,          # log2 feature map reduction when doubling the resolution.
+        fmap_min=1,            # Minimum number of feature maps in any layer.
+        fmap_max=512,          # Maximum number of feature maps in any layer.
+        architecture='resnet',     # Architecture: 'orig', 'skip', 'resnet'.
+        nonlinearity='lrelu',      # Activation function: 'relu', 'lrelu', etc.
+        mbstd_group_size=4,            # Group size for the minibatch standard deviation layer, 0 = disable.
+        mbstd_num_features=1,            # Number of features for the minibatch standard deviation layer.
+        dtype='float32',    # Data type to use for activations and outputs.
+        resample_kernel=[1, 3, 3, 1],    # Low-pass filter to apply when resampling activations. None = no filtering.
+        impl='cuda',
+        avg_pooling=False,
+        **_kwargs):                         # Ignore unrecognized keyword args.
+
+    resolution_log2 = int(np.ceil(np.log2(resolution)))
+    pad = (2 ** resolution_log2 - resolution) // 2
     def nf(stage): return np.clip(int(fmap_base / (2.0 ** (stage * fmap_decay))), fmap_min, fmap_max)
     assert architecture in ['orig', 'skip', 'resnet']
     act = nonlinearity
 
     images_in.set_shape([None, num_channels, resolution, resolution])
-    labels_in.set_shape([None, label_size])
     images_in = tf.cast(images_in, dtype)
-    labels_in = tf.cast(labels_in, dtype)
 
     # Building blocks for main layers.
-    def fromrgb(x, y, res): # res = 2..resolution_log2
+    def fromrgb(x, y, res):  # res = 2..resolution_log2
         with tf.variable_scope('FromRGB'):
-            t = apply_bias_act(conv2d_layer(y, fmaps=nf(res-1), kernel=1), act=act)
+            t = apply_bias_act(conv2d_layer(y, fmaps=nf(res - 1), kernel=1, impl=impl), act=act, impl=impl)
             return t if x is None else x + t
-    def block(x, res): # res = 2..resolution_log2
+
+    def block(x, res):  # res = 2..resolution_log2
         t = x
         with tf.variable_scope('Conv0'):
-            x = apply_bias_act(conv2d_layer(x, fmaps=nf(res-1), kernel=3), act=act)
+            x = apply_bias_act(conv2d_layer(x, fmaps=nf(res - 1), kernel=3, impl=impl), act=act, impl=impl)
         with tf.variable_scope('Conv1_down'):
-            x = apply_bias_act(conv2d_layer(x, fmaps=nf(res-2), kernel=3, down=True, resample_kernel=resample_kernel), act=act)
+            x = apply_bias_act(conv2d_layer(x, fmaps=nf(res - 2), kernel=3, down=True, resample_kernel=resample_kernel, impl=impl), act=act, impl=impl)
         if architecture == 'resnet':
             with tf.variable_scope('Skip'):
-                t = conv2d_layer(t, fmaps=nf(res-2), kernel=1, down=True, resample_kernel=resample_kernel)
+                t = conv2d_layer(t, fmaps=nf(res - 2), kernel=1, down=True, resample_kernel=resample_kernel, impl=impl)
                 x = (x + t) * (1 / np.sqrt(2))
         return x
+
     def downsample(y):
         with tf.variable_scope('Downsample'):
-            return downsample_2d(y, k=resample_kernel)
+            return downsample_2d(y, k=resample_kernel, impl=impl)
 
     # Main layers.
     x = None
-    y = images_in
+    y = tf.pad(images_in, [[0, 0], [0, 0], [pad, pad], [pad, pad]])
     for res in range(resolution_log2, 2, -1):
         with tf.variable_scope('%dx%d' % (2**res, 2**res)):
             if architecture == 'skip' or res == resolution_log2:
@@ -678,20 +488,20 @@ def D_stylegan2(
             with tf.variable_scope('MinibatchStddev'):
                 x = minibatch_stddev_layer(x, mbstd_group_size, mbstd_num_features)
         with tf.variable_scope('Conv'):
-            x = apply_bias_act(conv2d_layer(x, fmaps=nf(1), kernel=3), act=act)
+            x = apply_bias_act(conv2d_layer(x, fmaps=nf(1), kernel=3, impl=impl), act=act, impl=impl)
+        if avg_pooling:
+            x = tf.reduce_mean(x, axis=[2, 3])
         with tf.variable_scope('Dense0'):
-            x = apply_bias_act(dense_layer(x, fmaps=nf(0)), act=act)
+            x = apply_bias_act(dense_layer(x, fmaps=nf(0)), act=act, impl=impl)
 
-    # Output layer with label conditioning from "Which Training Methods for GANs do actually Converge?"
     with tf.variable_scope('Output'):
-        x = apply_bias_act(dense_layer(x, fmaps=max(labels_in.shape[1], 1)))
-        if labels_in.shape[1] > 0:
-            x = tf.reduce_sum(x * labels_in, axis=1, keepdims=True)
-    scores_out = x
+        if label_size > 0:
+            scores_out = apply_bias_act(dense_layer(x, fmaps=label_size), impl=impl)
+        else:
+            scores_out = tf.squeeze(apply_bias_act(dense_layer(x, fmaps=1), impl=impl), axis=1)
 
-    # Output.
     assert scores_out.dtype == tf.as_dtype(dtype)
     scores_out = tf.identity(scores_out, name='scores_out')
     return scores_out
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
diff --git a/training/training_loop.py b/training/training_loop.py
index c2d88cf..747f11e 100755
--- a/training/training_loop.py
+++ b/training/training_loop.py
@@ -16,51 +16,53 @@ from training import dataset
 from training import misc
 from metrics import metric_base
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Just-in-time processing of training images before feeding them to the networks.
 
-def process_reals(x, labels, lod, mirror_augment, drange_data, drange_net):
+
+def process_reals(x, lod, mirror_augment, drange_data, drange_net):
     with tf.name_scope('DynamicRange'):
         x = tf.cast(x, tf.float32)
         x = misc.adjust_dynamic_range(x, drange_data, drange_net)
     if mirror_augment:
         with tf.name_scope('MirrorAugment'):
             x = tf.where(tf.random_uniform([tf.shape(x)[0]]) < 0.5, x, tf.reverse(x, [3]))
-    with tf.name_scope('FadeLOD'): # Smooth crossfade between consecutive levels-of-detail.
+    with tf.name_scope('FadeLOD'):  # Smooth crossfade between consecutive levels-of-detail.
         s = tf.shape(x)
-        y = tf.reshape(x, [-1, s[1], s[2]//2, 2, s[3]//2, 2])
+        y = tf.reshape(x, [-1, s[1], s[2] // 2, 2, s[3] // 2, 2])
         y = tf.reduce_mean(y, axis=[3, 5], keepdims=True)
         y = tf.tile(y, [1, 1, 1, 2, 1, 2])
         y = tf.reshape(y, [-1, s[1], s[2], s[3]])
         x = tflib.lerp(x, y, lod - tf.floor(lod))
-    with tf.name_scope('UpscaleLOD'): # Upscale to match the expected input/output size of the networks.
+    with tf.name_scope('UpscaleLOD'):  # Upscale to match the expected input/output size of the networks.
         s = tf.shape(x)
         factor = tf.cast(2 ** tf.floor(lod), tf.int32)
         x = tf.reshape(x, [-1, s[1], s[2], 1, s[3], 1])
         x = tf.tile(x, [1, 1, 1, factor, 1, factor])
         x = tf.reshape(x, [-1, s[1], s[2] * factor, s[3] * factor])
-    return x, labels
+    return x
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Evaluate time-varying training parameters.
 
+
 def training_schedule(
-    cur_nimg,
-    training_set,
-    lod_initial_resolution  = None,     # Image resolution used at the beginning.
-    lod_training_kimg       = 600,      # Thousands of real images to show before doubling the resolution.
-    lod_transition_kimg     = 600,      # Thousands of real images to show when fading in new layers.
-    minibatch_size_base     = 32,       # Global minibatch size.
-    minibatch_size_dict     = {},       # Resolution-specific overrides.
-    minibatch_gpu_base      = 4,        # Number of samples processed at a time by one GPU.
-    minibatch_gpu_dict      = {},       # Resolution-specific overrides.
-    G_lrate_base            = 0.002,    # Learning rate for the generator.
-    G_lrate_dict            = {},       # Resolution-specific overrides.
-    D_lrate_base            = 0.002,    # Learning rate for the discriminator.
-    D_lrate_dict            = {},       # Resolution-specific overrides.
-    lrate_rampup_kimg       = 0,        # Duration of learning rate ramp-up.
-    tick_kimg_base          = 4,        # Default interval of progress snapshots.
-    tick_kimg_dict          = {8:28, 16:24, 32:20, 64:16, 128:12, 256:8, 512:6, 1024:4}): # Resolution-specific overrides.
+        cur_nimg,
+        training_set,
+        lod_initial_resolution=None,     # Image resolution used at the beginning.
+        lod_training_kimg=600,      # Thousands of real images to show before doubling the resolution.
+        lod_transition_kimg=600,      # Thousands of real images to show when fading in new layers.
+        minibatch_size_base=32,       # Global minibatch size.
+        minibatch_size_dict={},       # Resolution-specific overrides.
+        minibatch_gpu_base=4,        # Number of samples processed at a time by one GPU.
+        minibatch_gpu_dict={},       # Resolution-specific overrides.
+        G_lrate_base=0.002,    # Learning rate for the generator.
+        G_lrate_dict={},       # Resolution-specific overrides.
+        D_lrate_base=0.002,    # Learning rate for the discriminator.
+        D_lrate_dict={},       # Resolution-specific overrides.
+        lrate_rampup_kimg=0,        # Duration of learning rate ramp-up.
+        tick_kimg_base=4,        # Default interval of progress snapshots.
+        tick_kimg_dict={8: 28, 16: 24, 32: 20, 64: 16, 128: 12, 256: 10, 512: 10, 1024: 10}):  # Resolution-specific overrides.
 
     # Initialize result dict.
     s = dnnlib.EasyDict()
@@ -99,46 +101,50 @@ def training_schedule(
     s.tick_kimg = tick_kimg_dict.get(s.resolution, tick_kimg_base)
     return s
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
 # Main training script.
 
+
 def training_loop(
-    G_args                  = {},       # Options for generator network.
-    D_args                  = {},       # Options for discriminator network.
-    G_opt_args              = {},       # Options for generator optimizer.
-    D_opt_args              = {},       # Options for discriminator optimizer.
-    G_loss_args             = {},       # Options for generator loss.
-    D_loss_args             = {},       # Options for discriminator loss.
-    dataset_args            = {},       # Options for dataset.load_dataset().
-    sched_args              = {},       # Options for train.TrainingSchedule.
-    grid_args               = {},       # Options for train.setup_snapshot_image_grid().
-    metric_arg_list         = [],       # Options for MetricGroup.
-    tf_config               = {},       # Options for tflib.init_tf().
-    data_dir                = None,     # Directory to load datasets from.
-    G_smoothing_kimg        = 10.0,     # Half-life of the running average of generator weights.
-    minibatch_repeats       = 4,        # Number of minibatches to run before adjusting training parameters.
-    lazy_regularization     = True,     # Perform regularization as a separate training step?
-    G_reg_interval          = 4,        # How often the perform regularization for G? Ignored if lazy_regularization=False.
-    D_reg_interval          = 16,       # How often the perform regularization for D? Ignored if lazy_regularization=False.
-    reset_opt_for_new_lod   = True,     # Reset optimizer internal state (e.g. Adam moments) when new layers are introduced?
-    total_kimg              = 25000,    # Total length of the training, measured in thousands of real images.
-    mirror_augment          = False,    # Enable mirror augment?
-    drange_net              = [-1,1],   # Dynamic range used when feeding image data to the networks.
-    image_snapshot_ticks    = 50,       # How often to save image snapshots? None = only save 'reals.png' and 'fakes-init.png'.
-    network_snapshot_ticks  = 50,       # How often to save network snapshots? None = only save 'networks-final.pkl'.
-    save_tf_graph           = False,    # Include full TensorFlow computation graph in the tfevents file?
-    save_weight_histograms  = False,    # Include weight histograms in the tfevents file?
-    resume_pkl              = None,     # Network pickle to resume training from, None = train from scratch.
-    resume_kimg             = 0.0,      # Assumed training progress at the beginning. Affects reporting and training schedule.
-    resume_time             = 0.0,      # Assumed wallclock time at the beginning. Affects reporting.
-    resume_with_new_nets    = False):   # Construct new networks according to G_args and D_args before resuming training?
+        G_args={},       # Options for generator network.
+        D_args={},       # Options for discriminator network.
+        G_opt_args={},       # Options for generator optimizer.
+        D_opt_args={},       # Options for discriminator optimizer.
+        loss_args={},       # Options for loss.
+        dataset_args={},       # Options for dataset.load_dataset().
+        sched_args={},       # Options for train.TrainingSchedule.
+        grid_args={},       # Options for train.setup_snapshot_image_grid().
+        metric_arg_list=[],       # Options for metrics.
+        metric_args={},       # Options for MetricGroup.
+        tf_config={},       # Options for tflib.init_tf().
+        ema_start_kimg=None,     # Start of the exponential moving average. Default to the half-life period.
+        G_ema_kimg=10,       # Half-life of the exponential moving average of generator weights.
+        minibatch_repeats=4,        # Number of minibatches to run before adjusting training parameters.
+        lazy_regularization=False,    # Perform regularization as a separate training step?
+        G_reg_interval=4,        # How often the perform regularization for G? Ignored if lazy_regularization=False.
+        D_reg_interval=4,        # How often the perform regularization for D? Ignored if lazy_regularization=False.
+        reset_opt_for_new_lod=True,     # Reset optimizer internal state (e.g. Adam moments) when new layers are introduced?
+        total_kimg=25000,    # Total length of the training, measured in thousands of real images.
+        mirror_augment=False,    # Enable mirror augment?
+        drange_net=[-1, 1],   # Dynamic range used when feeding image data to the networks.
+        image_snapshot_ticks=10,       # How often to save image snapshots? None = only save 'reals.png' and 'fakes-init.png'.
+        network_snapshot_ticks=10,       # How often to save network snapshots? None = only save 'networks-final.pkl'.
+        save_tf_graph=False,    # Include full TensorFlow computation graph in the tfevents file?
+        save_weight_histograms=False,    # Include weight histograms in the tfevents file?
+        resume_pkl=None,     # Network pickle to resume training from, None = train from scratch.
+        resume_kimg=0.0,      # Assumed training progress at the beginning. Affects reporting and training schedule.
+        resume_time=0.0,      # Assumed wallclock time at the beginning. Affects reporting.
+        resume_with_new_nets=False):   # Construct new networks according to G_args and D_args before resuming training?
+
+    if ema_start_kimg is None:
+        ema_start_kimg = G_ema_kimg
 
     # Initialize dnnlib and TensorFlow.
     tflib.init_tf(tf_config)
     num_gpus = dnnlib.submit_config.num_gpus
 
     # Load training set.
-    training_set = dataset.load_dataset(data_dir=dnnlib.convert_path(data_dir), verbose=True, **dataset_args)
+    training_set = dataset.load_dataset(verbose=True, **dataset_args)
     grid_size, grid_reals, grid_labels = misc.setup_snapshot_image_grid(training_set, **grid_args)
     misc.save_image_grid(grid_reals, dnnlib.make_run_dir_path('reals.png'), drange=training_set.dynamic_range, grid_size=grid_size)
 
@@ -150,14 +156,18 @@ def training_loop(
             D = tflib.Network('D', num_channels=training_set.shape[0], resolution=training_set.shape[1], label_size=training_set.label_size, **D_args)
             Gs = G.clone('Gs')
         if resume_pkl is not None:
-            print('Loading networks from "%s"...' % resume_pkl)
-            rG, rD, rGs = misc.load_pkl(resume_pkl)
-            if resume_with_new_nets: G.copy_vars_from(rG); D.copy_vars_from(rD); Gs.copy_vars_from(rGs)
-            else: G = rG; D = rD; Gs = rGs
+            resume_networks = misc.load_pkl(resume_pkl)
+            rG, rD, rGs = resume_networks
+            if resume_with_new_nets:
+                G.copy_vars_from(rG)
+                D.copy_vars_from(rD)
+                Gs.copy_vars_from(rGs)
+            else:
+                G, D, Gs = rG, rD, rGs
 
     # Print layers and generate initial image snapshot.
     G.print_layers(); D.print_layers()
-    sched = training_schedule(cur_nimg=total_kimg*1000, training_set=training_set, **sched_args)
+    sched = training_schedule(cur_nimg=total_kimg * 1000, training_set=training_set, **sched_args)
     grid_latents = np.random.randn(np.prod(grid_size), *G.input_shape[1:])
     grid_fakes = Gs.run(grid_latents, grid_labels, is_validation=True, minibatch_size=sched.minibatch_gpu)
     misc.save_image_grid(grid_fakes, dnnlib.make_run_dir_path('fakes_init.png'), drange=drange_net, grid_size=grid_size)
@@ -165,79 +175,62 @@ def training_loop(
     # Setup training inputs.
     print('Building TensorFlow graph...')
     with tf.name_scope('Inputs'), tf.device('/cpu:0'):
-        lod_in               = tf.placeholder(tf.float32, name='lod_in', shape=[])
-        lrate_in             = tf.placeholder(tf.float32, name='lrate_in', shape=[])
-        minibatch_size_in    = tf.placeholder(tf.int32, name='minibatch_size_in', shape=[])
-        minibatch_gpu_in     = tf.placeholder(tf.int32, name='minibatch_gpu_in', shape=[])
+        lod_in = tf.placeholder(tf.float32, name='lod_in', shape=[])
+        G_lrate_in = tf.placeholder(tf.float32, name='G_lrate_in', shape=[])
+        D_lrate_in = tf.placeholder(tf.float32, name='D_lrate_in', shape=[])
+        minibatch_size_in = tf.placeholder(tf.int32, name='minibatch_size_in', shape=[])
+        minibatch_gpu_in = tf.placeholder(tf.int32, name='minibatch_gpu_in', shape=[])
+        run_D_reg_in = tf.placeholder(tf.bool, name='run_D_reg', shape=[])
         minibatch_multiplier = minibatch_size_in // (minibatch_gpu_in * num_gpus)
-        Gs_beta              = 0.5 ** tf.div(tf.cast(minibatch_size_in, tf.float32), G_smoothing_kimg * 1000.0) if G_smoothing_kimg > 0.0 else 0.0
+        Gs_beta_mul_in = tf.placeholder(tf.float32, name='Gs_beta_in', shape=[])
+        Gs_beta = 0.5 ** tf.div(tf.cast(minibatch_size_in, tf.float32), G_ema_kimg * 1000.0) if G_ema_kimg > 0.0 else 0.0
 
     # Setup optimizers.
     G_opt_args = dict(G_opt_args)
     D_opt_args = dict(D_opt_args)
-    for args, reg_interval in [(G_opt_args, G_reg_interval), (D_opt_args, D_reg_interval)]:
+    G_opt_args['learning_rate'] = G_lrate_in
+    D_opt_args['learning_rate'] = D_lrate_in
+    for args in [G_opt_args, D_opt_args]:
         args['minibatch_multiplier'] = minibatch_multiplier
-        args['learning_rate'] = lrate_in
-        if lazy_regularization:
-            mb_ratio = reg_interval / (reg_interval + 1)
-            args['learning_rate'] *= mb_ratio
-            if 'beta1' in args: args['beta1'] **= mb_ratio
-            if 'beta2' in args: args['beta2'] **= mb_ratio
     G_opt = tflib.Optimizer(name='TrainG', **G_opt_args)
     D_opt = tflib.Optimizer(name='TrainD', **D_opt_args)
-    G_reg_opt = tflib.Optimizer(name='RegG', share=G_opt, **G_opt_args)
-    D_reg_opt = tflib.Optimizer(name='RegD', share=D_opt, **D_opt_args)
 
     # Build training graph for each GPU.
-    data_fetch_ops = []
     for gpu in range(num_gpus):
         with tf.name_scope('GPU%d' % gpu), tf.device('/gpu:%d' % gpu):
+            with tf.name_scope('DataFetch'):
+                reals_read, labels_read = training_set.get_minibatch_tf()
+                reals_read = process_reals(reals_read, lod_in, mirror_augment, training_set.dynamic_range, drange_net)
 
             # Create GPU-specific shadow copies of G and D.
             G_gpu = G if gpu == 0 else G.clone(G.name + '_shadow')
             D_gpu = D if gpu == 0 else D.clone(D.name + '_shadow')
 
-            # Fetch training data via temporary variables.
-            with tf.name_scope('DataFetch'):
-                sched = training_schedule(cur_nimg=int(resume_kimg*1000), training_set=training_set, **sched_args)
-                reals_var = tf.Variable(name='reals', trainable=False, initial_value=tf.zeros([sched.minibatch_gpu] + training_set.shape))
-                labels_var = tf.Variable(name='labels', trainable=False, initial_value=tf.zeros([sched.minibatch_gpu, training_set.label_size]))
-                reals_write, labels_write = training_set.get_minibatch_tf()
-                reals_write, labels_write = process_reals(reals_write, labels_write, lod_in, mirror_augment, training_set.dynamic_range, drange_net)
-                reals_write = tf.concat([reals_write, reals_var[minibatch_gpu_in:]], axis=0)
-                labels_write = tf.concat([labels_write, labels_var[minibatch_gpu_in:]], axis=0)
-                data_fetch_ops += [tf.assign(reals_var, reals_write)]
-                data_fetch_ops += [tf.assign(labels_var, labels_write)]
-                reals_read = reals_var[:minibatch_gpu_in]
-                labels_read = labels_var[:minibatch_gpu_in]
-
             # Evaluate loss functions.
             lod_assign_ops = []
-            if 'lod' in G_gpu.vars: lod_assign_ops += [tf.assign(G_gpu.vars['lod'], lod_in)]
-            if 'lod' in D_gpu.vars: lod_assign_ops += [tf.assign(D_gpu.vars['lod'], lod_in)]
+            if 'lod' in G_gpu.vars:
+                lod_assign_ops += [tf.assign(G_gpu.vars['lod'], lod_in)]
+            if 'lod' in D_gpu.vars:
+                lod_assign_ops += [tf.assign(D_gpu.vars['lod'], lod_in)]
             with tf.control_dependencies(lod_assign_ops):
-                with tf.name_scope('G_loss'):
-                    G_loss, G_reg = dnnlib.util.call_func_by_name(G=G_gpu, D=D_gpu, opt=G_opt, training_set=training_set, minibatch_size=minibatch_gpu_in, **G_loss_args)
-                with tf.name_scope('D_loss'):
-                    D_loss, D_reg = dnnlib.util.call_func_by_name(G=G_gpu, D=D_gpu, opt=D_opt, training_set=training_set, minibatch_size=minibatch_gpu_in, reals=reals_read, labels=labels_read, **D_loss_args)
+                with tf.name_scope('loss'):
+                    G_loss, D_loss, D_reg = dnnlib.util.call_func_by_name(G=G_gpu, D=D_gpu, training_set=training_set, minibatch_size=minibatch_gpu_in, reals=reals_read, real_labels=labels_read, **loss_args)
 
             # Register gradients.
             if not lazy_regularization:
-                if G_reg is not None: G_loss += G_reg
-                if D_reg is not None: D_loss += D_reg
+                if D_reg is not None:
+                    D_loss += D_reg
             else:
-                if G_reg is not None: G_reg_opt.register_gradients(tf.reduce_mean(G_reg * G_reg_interval), G_gpu.trainables)
-                if D_reg is not None: D_reg_opt.register_gradients(tf.reduce_mean(D_reg * D_reg_interval), D_gpu.trainables)
+                if D_reg is not None:
+                    D_loss = tf.cond(run_D_reg_in, lambda: D_loss + D_reg * D_reg_interval, lambda: D_loss)
             G_opt.register_gradients(tf.reduce_mean(G_loss), G_gpu.trainables)
             D_opt.register_gradients(tf.reduce_mean(D_loss), D_gpu.trainables)
 
     # Setup training ops.
-    data_fetch_op = tf.group(*data_fetch_ops)
-    G_train_op = G_opt.apply_updates()
+    Gs_update_op = Gs.setup_as_moving_average_of(G, beta=Gs_beta * Gs_beta_mul_in)
+    with tf.control_dependencies([Gs_update_op]):
+        G_train_op = G_opt.apply_updates()
     D_train_op = D_opt.apply_updates()
-    G_reg_op = G_reg_opt.apply_updates(allow_no_op=True)
-    D_reg_op = D_reg_opt.apply_updates(allow_no_op=True)
-    Gs_update_op = Gs.setup_as_moving_average_of(G, beta=Gs_beta)
 
     # Finalize graph.
     with tf.device('/gpu:0'):
@@ -253,7 +246,7 @@ def training_loop(
         summary_log.add_graph(tf.get_default_graph())
     if save_weight_histograms:
         G.setup_weight_histograms(); D.setup_weight_histograms()
-    metrics = metric_base.MetricGroup(metric_arg_list)
+    metrics = metric_base.MetricGroup(metric_arg_list, **metric_args)
 
     print('Training for %d kimg...\n' % total_kimg)
     dnnlib.RunContext.get().update('', cur_epoch=resume_kimg, max_epoch=total_kimg)
@@ -264,49 +257,38 @@ def training_loop(
     prev_lod = -1.0
     running_mb_counter = 0
     while cur_nimg < total_kimg * 1000:
-        if dnnlib.RunContext.get().should_stop(): break
+        if dnnlib.RunContext.get().should_stop():
+            break
 
         # Choose training parameters and configure training ops.
         sched = training_schedule(cur_nimg=cur_nimg, training_set=training_set, **sched_args)
         assert sched.minibatch_size % (sched.minibatch_gpu * num_gpus) == 0
-        training_set.configure(sched.minibatch_gpu, sched.lod)
+        training_set.configure(sched.minibatch_gpu)
         if reset_opt_for_new_lod:
             if np.floor(sched.lod) != np.floor(prev_lod) or np.ceil(sched.lod) != np.ceil(prev_lod):
                 G_opt.reset_optimizer_state(); D_opt.reset_optimizer_state()
         prev_lod = sched.lod
 
         # Run training ops.
-        feed_dict = {lod_in: sched.lod, lrate_in: sched.G_lrate, minibatch_size_in: sched.minibatch_size, minibatch_gpu_in: sched.minibatch_gpu}
+        feed_dict = {
+            lod_in: sched.lod,
+            G_lrate_in: sched.G_lrate,
+            D_lrate_in: sched.D_lrate,
+            minibatch_size_in: sched.minibatch_size,
+            minibatch_gpu_in: sched.minibatch_gpu,
+            Gs_beta_mul_in: 1 if cur_nimg >= ema_start_kimg * 1000 else 0,
+        }
         for _repeat in range(minibatch_repeats):
             rounds = range(0, sched.minibatch_size, sched.minibatch_gpu * num_gpus)
-            run_G_reg = (lazy_regularization and running_mb_counter % G_reg_interval == 0)
             run_D_reg = (lazy_regularization and running_mb_counter % D_reg_interval == 0)
+            feed_dict[run_D_reg_in] = run_D_reg
             cur_nimg += sched.minibatch_size
             running_mb_counter += 1
 
             # Fast path without gradient accumulation.
-            if len(rounds) == 1:
-                tflib.run([G_train_op, data_fetch_op], feed_dict)
-                if run_G_reg:
-                    tflib.run(G_reg_op, feed_dict)
-                tflib.run([D_train_op, Gs_update_op], feed_dict)
-                if run_D_reg:
-                    tflib.run(D_reg_op, feed_dict)
-
-            # Slow path with gradient accumulation.
-            else:
-                for _round in rounds:
-                    tflib.run(G_train_op, feed_dict)
-                if run_G_reg:
-                    for _round in rounds:
-                        tflib.run(G_reg_op, feed_dict)
-                tflib.run(Gs_update_op, feed_dict)
-                for _round in rounds:
-                    tflib.run(data_fetch_op, feed_dict)
-                    tflib.run(D_train_op, feed_dict)
-                if run_D_reg:
-                    for _round in rounds:
-                        tflib.run(D_reg_op, feed_dict)
+            for _ in rounds:
+                tflib.run(G_train_op, feed_dict)
+                tflib.run(D_train_op, feed_dict)
 
         # Perform maintenance tasks once per tick.
         done = (cur_nimg >= total_kimg * 1000)
@@ -338,7 +320,7 @@ def training_loop(
             if network_snapshot_ticks is not None and (cur_tick % network_snapshot_ticks == 0 or done):
                 pkl = dnnlib.make_run_dir_path('network-snapshot-%06d.pkl' % (cur_nimg // 1000))
                 misc.save_pkl((G, D, Gs), pkl)
-                metrics.run(pkl, run_dir=dnnlib.make_run_dir_path(), data_dir=dnnlib.convert_path(data_dir), num_gpus=num_gpus, tf_config=tf_config)
+                metrics.run(pkl, run_dir=dnnlib.make_run_dir_path(), num_gpus=num_gpus, tf_config=tf_config)
 
             # Update summaries and RunContext.
             metrics.update_autosummaries()
@@ -353,4 +335,4 @@ def training_loop(
     summary_log.close()
     training_set.close()
 
-#----------------------------------------------------------------------------
+# ----------------------------------------------------------------------------
